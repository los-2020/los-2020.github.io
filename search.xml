<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深度解密Go语言之channel</title>
      <link href="/2019/09/22/dive-into-go-channel/"/>
      <url>/2019/09/22/dive-into-go-channel/</url>
      
        <content type="html"><![CDATA[<p>大家好！“深度解密 Go 语言”系列好久未见，我们今天讲 channel，预祝阅读愉快！在开始正文之前，我们先说些题外话。</p><p>上一篇关于 Go 语言的文章讲 Go 程序的整个编码、编译、运行、退出的全过程。文章发出后，反响强烈，在各大平台的阅读量都不错。例如博客园登上了 48 小时阅读排行榜，并且受到了编辑推荐，占据首页头条位置整整一天；在开发者头条首页精选的位置霸榜一周时间……</p><p><img src="https://user-images.githubusercontent.com/7698088/61573877-801c8c80-aae8-11e9-9f3c-c364ec4d2726.png" alt="博客园头条推荐"></p><p><img src="https://user-images.githubusercontent.com/7698088/61576219-ce8e5300-ab09-11e9-9c9d-1cb244475812.png" alt="开发者头条精选"></p><p>熟悉码农桃花源的朋友们都知道，这里每篇文章都很长，要花很长时间才能读完。但长并不是目的，把每个问题都讲深、讲透才是最重要的。首先我自己得完全理解才行，所以写每篇文章时我都会看很多参考资料，看源码，请教大牛，自己还要去写样例代码跑结果……从创建文稿到真正完成写作需要很长时间。</p><p><img src="https://user-images.githubusercontent.com/7698088/61576233-05fcff80-ab0a-11e9-92a9-eef8fbd2f812.png" alt="写作时间"></p><p>做这些事情，无非是想力求我写出来的文字，都是我目前所能理解的最深层次。如果我暂时理解不了，我会说出来，或者不写进文章里面去，留到以后有能力的时候再来写。</p><p>我自己平时有这种体会：看微信公众号的文章都是想快速地看完，快速地拉到最后，目的快点开始看下一篇，新鲜感才能不断刺激大脑。有时候碰到长文很花时间，可能就没耐心看下去了，里面说的东西也觉得很难理解，可能直接就放弃了。但是，如果我知道一篇文章价值很高，就会选一个精力比较充沛的时间段，花整块时间看完，这时候反倒很容易看进去。这种情况下，潜意识里就会知道我今天是一定要读完这篇文章的，并且要把里面有价值的东西都吸收进来。</p><p>所以，对于码农桃花源的文章，我建议你收藏之后，找个空闲时间再好好看。</p><p>上周，我把 GitHub 项目 Go-Question 的内容整合成了开源电子书，阅读体验提升 N 倍，建议关注项目，现在已经 400 star 了，年底目标是 1k star。项目地址列在了参考资料里。</p><p><img src="https://user-images.githubusercontent.com/7698088/61576338-9ab42d00-ab0b-11e9-9ea1-9efc3c661ae1.png" alt="GitBook"></p><p>另外，公众号的文章也可以使用微信读书看，体验也非常赞，并且可以放到书架上，每个公众号就是一本书，简直酷炫。</p><p><img src="https://user-images.githubusercontent.com/7698088/61576313-2bd6d400-ab0b-11e9-8585-35b51d0493d8.png" alt="微信读书"></p><p>闲话最后，一直“吹”了很久的曹大，新书《Go 语言高级编程》出版了！书的另一位作者是柴树杉老师，这是给 Go 语言提交 pull 的人，他在 Go 语言上面的研究不用我多说了吧。我第一时间下了单，并且到曹大工位要了签名。</p> <img src="https://user-images.githubusercontent.com/7698088/61576352-cb946200-ab0b-11e9-9324-7cee1d74cf4a.png" width="600" height="400" alt="Go 语言高级编程" align="center"><p>这本书的推荐人有很多大佬，像许世伟，郝林，雨痕等，评价非常高。重点给大家看下雨痕老师对这本书的评价（上图第二排左侧图）：</p><blockquote><p>本书阐明了官方文档某些语焉不详的部分，有助于 Gopher 了解更多内在实现，以及日常工作中需要用到的 RPC、Web、分布式应用等内容。我认识本书作者之一曹春晖，对他的学习态度和能力颇为钦佩，因此推荐大家阅读本书。</p></blockquote><p>大家可能不知道，出书一点都不赚钱，但投入的精力却很大。但是像曹大在给读者的书签名时所说的：书籍是时代的生命。多少知识都是通过书本一代代传承！</p><p>搬过几次家就知道，纸质书太多，过程会比较痛苦。所以，我现在买纸书都会考虑再三。但是，这次我还是在第一时间下单了《Go 语言高级编程》。我也强烈推荐你买一本，支持原创者。</p><p>柴老师在武汉，我接触不多。但和曹大却是经常能见面（在同一个公司工作）。他本人经常活跃在各种微信群，社区，也非常乐于解答各种疑难杂症。上周还和曹大一起吃了个饭，请教了很多问题，我总结了一些对家都有用的东西，放在我的朋友圈：</p><p><img src="https://user-images.githubusercontent.com/7698088/61576424-815fb080-ab0c-11e9-8864-a7c32889487a.png" alt="曹大交流总结"></p><p>如果你想围观我的朋友圈，想和我交流，可以长按下面的二维码加我好友，备注下来自公众号。</p><p><img src="https://user-images.githubusercontent.com/7698088/61592413-7f2d4d00-ac05-11e9-9d8a-47f575862060.png" alt="wechat-QR"></p><p>好了，下面开始我们的正文。</p><h1 id="并发模型"><a href="#并发模型" class="headerlink" title="并发模型"></a>并发模型</h1><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>大家都知道著名的摩尔定律。1965 年，时任仙童公司的 Gordon Moore 发表文章，预测在未来十年，半导体芯片上的晶体管和电阻数量将每年增加一倍；1975 年，Moore 再次发表论文，将“每年”修改为“每两年”。这个预测在 2012 年左右基本是正确的。</p><p>但随着晶体管电路逐渐接近性能极限，摩尔定律终将走到尽头。靠增加晶体管数量来提高计算机的性能不灵了。于是，人们开始转换思路，用其他方法来提升计算机的性能，这就是多核计算机产生的原因。</p><p>这一招看起来还不错，但是人们又遇到了一个另一个定律的限制，那就是 Amdahl’s Law，它提出了一个模型用来衡量在并行模式下程序运行效率的提升。这个定律是说，一个程序能从并行上获得性能提升的上限取决于有多少代码必须写成串行的。</p><p>举个例子，对于一个和用户打交道的界面程序，它必须和用户打交道。用户点一个按钮，然后才能继续运行下一步，这必须是串行执行的。这种程序的运行效率就取决于和用户交互的速度，你有多少核都白瞎。用户就是不按下一步，你怎么办？</p><p>2000 年左右云计算兴起，人们可以方便地获取计算云上的资源，方便地水平扩展自己的服务，可以轻而易举地就调动多台机器资源甚至将计算任务分发到分布在全球范围的机器。但是也因此带来了很多问题和挑战。例如怎样在机器间进行通信、聚合结果等。最难的一个挑战是如何找到一个模型能用来描述 concurrent。</p><p>我们都知道，要想一段并发的代码没有任何 bug，是非常困难的。有些并发 bug 是在系统上线数年后才发现的，原因常常是很诡异的，比如用户数增加到了某个界限。</p><p>并发问题一般有下面这几种：</p><p>数据竞争。简单来说就是两个或多个线程同时读写某个变量，造成了预料之外的结果。</p><p>原子性。在一个定义好的上下文里，原子性操作不可分割。上下文的定义非常重要。有些代码，你在程序里看起来是原子的，如最简单的 i++，但在机器层面看来，这条语句通常需要几条指令来完成（Load，Incr，Store），不是不可分割的，也就不是原子性的。原子性可以让我们放心地构造并发安全的程序。</p><p>内存访问同步。代码中需要控制同时只有一个线程访问的区域称为临界区。Go 语言中一般使用 sync 包里的 Mutex 来完成同步访问控制。锁一般会带来比较大的性能开销，因此一般要考虑加锁的区域是否会频繁进入、锁的粒度如何控制等问题。</p><p>死锁。在一个死锁的程序里，每个线程都在等待其他线程，形成了一个首尾相连的尴尬局面，程序无法继续运行下去。</p><p>活锁。想象一下，你走在一条小路上，一个人迎面走来。你往左边走，想避开他；他做了相反的事情，他往右边走，结果两个都过不了。之后，两个人又都想从原来自己相反的方向走，还是同样的结果。这就是活锁，看起来都像在工作，但工作进度就是无法前进。</p><p>饥饿。并发的线程不能获取它所需要的资源以进行下一步的工作。通常是有一个非常贪婪的线程，长时间占据资源不释放，导致其他线程无法获得资源。</p><p>关于并发和并行的区别，引用一个经典的描述：</p><blockquote><p>并发是同一时间应对（dealing with）多件事情的能力。<br>并行是同一时间动手（doing）做多件事情的能力。</p></blockquote><p>雨痕老师《Go 语言学习笔记》上的解释：</p><blockquote><p>并发是指逻辑上具备同时处理多个任务的能力；并行则是物理上同时执行多个任务。</p></blockquote><p>而根据《Concurrency in Go》这本书，计算机的概念都是抽象的结果，并发和并行也不例外。它这样描述并发和并行的区别：</p><blockquote><p>Concurrency is a property of the code; parallelism is a property of the running program.</p></blockquote><p>并发是代码的特性，并行是正在运行的程序的特性。先忽略我拙劣的翻译。很新奇，不是吗？我也是第一次见到这样的说法，细想一下，还是很有道理的。</p><p>我们一直说写的代码是并发的或者是并行的，但是我们能提供什么保证吗？如果在只有一个核的机器上跑并行的代码，它还能并行吗？你就是再天才，也无法写出并行的程序。充其量也就是代码上看起来“并发”的，如此而已。</p><p>当然，表面上看起来还是并行的，但那不过 CPU 的障眼法，多个线程在分时共享 CPU 的资源，在一个粗糙的时间隔里看起来就是“并行”。</p><p>所以，我们实际上只能编写“并发”的代码，而不能编写“并行”的代码，而且只是希望并发的代码能够并行地执行。并发的代码能否并行，取决于抽象的层级：代码里的并发原语、runtime，操作系统（虚拟机、容器）。层级越来越底层，要求也越来越高。因此，我们谈并发或并行实际上要指定上下文，也就是抽象的层级。</p><p>《Concurrency in Go》书里举了一个例子：假如两个人同时打开电脑上的计算器程序，这两个程序肯定不会影响彼此，这就是并行。在这个例子中，上下文就是两个人的机器，而两个计算器进程就是并行的元素。</p><p>随着抽象层次的降低，并发模型实际上变得更难也更重要，而越低层次的并发模型对我们也越重要。要想并发程序正确地执行，就要深入研究并发模型。</p><p>在 Go 语言发布前，我们写并发代码时，考虑到的最底层抽象是：系统线程。Go 发布之后，在这条抽象链上，又加一个 goroutine。而且 Go 从著名的计算机科学家 Tony Hoare 那借来一个概念：channel。Tony Hoare 就是那篇著名文章《Communicating Sequential Processes》的作者。</p><p>看起来事情变得更加复杂，因为 Go 又引入了一个更底层的抽象，但事实并不是这样。因为 goroutine 并不是看起来的那样又抽象了一层，它其实是替代了系统线程。Gopher 在写代码的时候，并不会去关心系统线程，大部分时候只需要考虑到 goroutine 和 channel。当然有时候会用到一些共享内存的概念，一般就是指 sync 包里的东西，比如 sync.Mutex。</p><h2 id="什么是-CSP"><a href="#什么是-CSP" class="headerlink" title="什么是 CSP"></a>什么是 CSP</h2><p>CSP 经常被认为是 Go 在并发编程上成功的关键因素。CSP 全称是 “Communicating Sequential Processes”，这也是 Tony Hoare 在 1978 年发表在 ACM 的一篇论文。论文里指出一门编程语言应该重视 input 和 output 的原语，尤其是并发编程的代码。</p><p>在那篇文章发表的时代，人们正在研究模块化编程的思想，该不该用 goto 语句在当时是最激烈的议题。彼时，面向对象编程的思想正在崛起，几乎没什么人关心并发编程。</p><p>在文章中，CSP 也是一门自定义的编程语言，作者定义了输入输出语句，用于 processes 间的通信（communicatiton）。processes 被认为是需要输入驱动，并且产生输出，供其他 processes 消费，processes 可以是进程、线程、甚至是代码块。输入命令是：!，用来向 processes 写入；输出是：?，用来从 processes 读出。这篇文章要讲的 channel 正是借鉴了这一设计。</p><p>Hoare 还提出了一个 -&gt; 命令，如果 -&gt; 左边的语句返回 false，那它右边的语句就不会执行。</p><p>通过这些输入输出命令，Hoare 证明了如果一门编程语言中把 processes 间的通信看得第一等重要，那么并发编程的问题就会变得简单。</p><p>Go 是第一个将 CSP 的这些思想引入，并且发扬光大的语言。仅管内存同步访问控制（原文是 memory access synchronization）在某些情况下大有用处，Go 里也有相应的 sync 包支持，但是这在大型程序很容易出错。</p><p>Go 一开始就把 CSP 的思想融入到语言的核心里，所以并发编程成为 Go 的一个独特的优势，而且很容易理解。</p><p>大多数的编程语言的并发编程模型是基于线程和内存同步访问控制，Go 的并发编程的模型则用 goroutine 和 channel 来替代。Goroutine 和线程类似，channel 和 mutex (用于内存同步访问控制)类似。</p><p>Goroutine 解放了程序员，让我们更能贴近业务去思考问题。而不用考虑各种像线程库、线程开销、线程调度等等这些繁琐的底层问题，goroutine 天生替你解决好了。</p><p>Channel 则天生就可以和其他 channel 组合。我们可以把收集各种子系统结果的 channel 输入到同一个 channel。Channel 还可以和 select, cancel, timeout 结合起来。而 mutex 就没有这些功能。</p><p>Go 的并发原则非常优秀，目标就是简单：尽量使用 channel；把 goroutine 当作免费的资源，随便用。</p><p>说明一下，前面这两部分的内容来自英文开源书《Concurrency In Go》，强烈推荐阅读。</p><p>引入结束，我们正式开始今天的主角：channel。</p><h1 id="什么是-channel"><a href="#什么是-channel" class="headerlink" title="什么是 channel"></a>什么是 channel</h1><p>Goroutine 和 channel 是 Go 语言并发编程的 两大基石。Goroutine 用于执行并发任务，channel 用于 goroutine 之间的同步、通信。</p><p>Channel 在 gouroutine 间架起了一条管道，在管道里传输数据，实现 gouroutine 间的通信；由于它是线程安全的，所以用起来非常方便；channel 还提供“先进先出”的特性；它还能影响 goroutine 的阻塞和唤醒。</p><p>相信大家一定见过一句话：</p><blockquote><p>Do not communicate by sharing memory; instead, share memory by communicating.</p></blockquote><p>不要通过共享内存来通信，而要通过通信来实现内存共享。</p><p>这就是 Go 的并发哲学，它依赖 CSP 模型，基于 channel 实现。</p><p>简直是一头雾水，这两句话难道不是同一个意思？</p><p>通过前面两节的内容，我个人这样理解这句话：前面半句说的是通过 sync 包里的一些组件进行并发编程；而后面半句则是说 Go 推荐使用 channel 进行并发编程。两者其实都是必要且有效的。实际上看完本文后面对 channel 的源码分析，你会发现，channel 的底层就是通过 mutex 来控制并发的。只是 channel 是更高一层次的并发编程原语，封装了更多的功能。</p><p>关于是选择 sync 包里的底层并发编程原语还是 channel，《Concurrency In Go》这本书的第 2 章 “Go’s Philosophy on Concurrency” 里有一张决策树和详细的论述，再次推荐你去阅读。我把图贴出来：</p><p><img src="https://user-images.githubusercontent.com/7698088/61507065-e0db9480-aa16-11e9-9fab-2ba43ee90c95.png" alt="concurrency code decision tree"></p><h2 id="channel-实现-CSP"><a href="#channel-实现-CSP" class="headerlink" title="channel 实现 CSP"></a>channel 实现 CSP</h2><p>Channel 是 Go 语言中一个非常重要的类型，是 Go 里的第一对象。通过 channel，Go 实现了通过通信来实现内存共享。Channel 是在多个 goroutine 之间传递数据和同步的重要手段。</p><p>使用原子函数、读写锁可以保证资源的共享访问安全，但使用 channel 更优雅。</p><p>channel 字面意义是“通道”，类似于 Linux 中的管道。声明 channel 的语法如下：</p><pre class=" language-golang"><code class="language-golang">chan T // 声明一个双向通道chan<- T // 声明一个只能用于发送的通道<-chan T // 声明一个只能用于接收的通道</code></pre><p>单向通道的声明，用 <code>&lt;-</code> 来表示，它指明通道的方向。你只要明白，代码的书写顺序是从左到右就马上能掌握通道的方向是怎样的。</p><p>因为 channel 是一个引用类型，所以在它被初始化之前，它的值是 nil，channel 使用 make 函数进行初始化。可以向它传递一个 int 值，代表 channel 缓冲区的大小（容量），构造出来的是一个缓冲型的 channel；不传或传 0 的，构造的就是一个非缓冲型的 channel。</p><p>两者有一些差别：非缓冲型 channel 无法缓冲元素，对它的操作一定顺序是“发送-&gt; 接收 -&gt; 发送 -&gt; 接收 -&gt; ……”，如果连续向一个非缓冲 chan 发送 2 个元素，并且没有接收的话，第二次一定会被阻塞；对于缓冲型 channel 的操作，则要“宽松”一些，毕竟是带了“缓冲”光环。</p><h1 id="为什么要-channel"><a href="#为什么要-channel" class="headerlink" title="为什么要 channel"></a>为什么要 channel</h1><p>Go 通过 channel 实现 CSP 通信模型，主要用于 goroutine 之间的消息传递和事件通知。</p><p>有了 channel 和 goroutine 之后，Go 的并发编程变得异常容易和安全，得以让程序员把注意力留到业务上去，实现开发效率的提升。</p><p>要知道，技术并不是最重要的，它只是实现业务的工具。一门高效的开发语言让你把节省下来的时间，留着去做更有意义的事情，比如写写文章。</p><h1 id="channel-实现原理"><a href="#channel-实现原理" class="headerlink" title="channel 实现原理"></a>channel 实现原理</h1><p>对 chan 的发送和接收操作都会在编译期间转换成为底层的发送接收函数。</p><p>Channel 分为两种：带缓冲、不带缓冲。对不带缓冲的 channel 进行的操作实际上可以看作“同步模式”，带缓冲的则称为“异步模式”。</p><p>同步模式下，发送方和接收方要同步就绪，只有在两者都 ready 的情况下，数据才能在两者间传输（后面会看到，实际上就是内存拷贝）。否则，任意一方先行进行发送或接收操作，都会被挂起，等待另一方的出现才能被唤醒。</p><p>异步模式下，在缓冲槽可用的情况下（有剩余容量），发送和接收操作都可以顺利进行。否则，操作的一方（如写入）同样会被挂起，直到出现相反操作（如接收）才会被唤醒。</p><p>小结一下：同步模式下，必须要使发送方和接收方配对，操作才会成功，否则会被阻塞；异步模式下，缓冲槽要有剩余容量，操作才会成功，否则也会被阻塞。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>直接上源码（版本是 1.9.2）：</p><pre class=" language-golang"><code class="language-golang">type hchan struct {    // chan 里元素数量    qcount   uint    // chan 底层循环数组的长度    dataqsiz uint    // 指向底层循环数组的指针    // 只针对有缓冲的 channel    buf      unsafe.Pointer    // chan 中元素大小    elemsize uint16    // chan 是否被关闭的标志    closed   uint32    // chan 中元素类型    elemtype *_type // element type    // 已发送元素在循环数组中的索引    sendx    uint   // send index    // 已接收元素在循环数组中的索引    recvx    uint   // receive index    // 等待接收的 goroutine 队列    recvq    waitq  // list of recv waiters    // 等待发送的 goroutine 队列    sendq    waitq  // list of send waiters    // 保护 hchan 中所有字段    lock mutex}</code></pre><p>关于字段的含义都写在注释里了，再来重点说几个字段：</p><p><code>buf</code> 指向底层循环数组，只有缓冲型的 channel 才有。</p><p><code>sendx</code>，<code>recvx</code> 均指向底层循环数组，表示当前可以发送和接收的元素位置索引值（相对于底层数组）。</p><p><code>sendq</code>，<code>recvq</code> 分别表示被阻塞的 goroutine，这些 goroutine 由于尝试读取 channel 或向 channel 发送数据而被阻塞。</p><p><code>waitq</code> 是 <code>sudog</code> 的一个双向链表，而 <code>sudog</code> 实际上是对 goroutine 的一个封装：</p><pre class=" language-golang"><code class="language-golang">type waitq struct {    first *sudog    last  *sudog}</code></pre><p><code>lock</code> 用来保证每个读 channel 或写 channel 的操作都是原子的。</p><p>例如，创建一个容量为 6 的，元素为 int 型的 channel 数据结构如下 ：</p><p><img src="https://user-images.githubusercontent.com/7698088/61179068-806ee080-a62d-11e9-818c-16af42025b1b.png" alt="chan data structure"></p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>我们知道，通道有两个方向，发送和接收。理论上来说，我们可以创建一个只发送或只接收的通道，但是这种通道创建出来后，怎么使用呢？一个只能发的通道，怎么接收呢？同样，一个只能收的通道，如何向其发送数据呢？</p><p>一般而言，使用 <code>make</code> 创建一个能收能发的通道：</p><pre class=" language-golang"><code class="language-golang">// 无缓冲通道ch1 := make(chan int)// 有缓冲通道ch2 := make(chan int, 10)</code></pre><p>通过<a href="https://mp.weixin.qq.com/s/obnnVkO2EiFnuXk_AIDHWw" target="_blank" rel="noopener">汇编</a>分析，我们知道，最终创建 chan 的函数是 <code>makechan</code>：</p><pre class=" language-golang"><code class="language-golang">func makechan(t *chantype, size int64) *hchan</code></pre><p>从函数原型来看，创建的 chan 是一个指针。所以我们能在函数间直接传递 channel，而不用传递 channel 的指针。</p><p>具体来看下代码：</p><pre class=" language-golang"><code class="language-golang">const hchanSize = unsafe.Sizeof(hchan{}) + uintptr(-int(unsafe.Sizeof(hchan{}))&(maxAlign-1))func makechan(t *chantype, size int64) *hchan {    elem := t.elem    // 省略了检查 channel size，align 的代码    // ……    var c *hchan    // 如果元素类型不含指针 或者 size 大小为 0（无缓冲类型）    // 只进行一次内存分配    if elem.kind&kindNoPointers != 0 || size == 0 {        // 如果 hchan 结构体中不含指针，GC 就不会扫描 chan 中的元素        // 只分配 "hchan 结构体大小 + 元素大小*个数" 的内存        c = (*hchan)(mallocgc(hchanSize+uintptr(size)*elem.size, nil, true))        // 如果是缓冲型 channel 且元素大小不等于 0（大小等于 0的元素类型：struct{}）        if size > 0 && elem.size != 0 {            c.buf = add(unsafe.Pointer(c), hchanSize)        } else {            // race detector uses this location for synchronization            // Also prevents us from pointing beyond the allocation (see issue 9401).            // 1. 非缓冲型的，buf 没用，直接指向 chan 起始地址处            // 2. 缓冲型的，能进入到这里，说明元素无指针且元素类型为 struct{}，也无影响            // 因为只会用到接收和发送游标，不会真正拷贝东西到 c.buf 处（这会覆盖 chan的内容）            c.buf = unsafe.Pointer(c)        }    } else {        // 进行两次内存分配操作        c = new(hchan)        c.buf = newarray(elem, int(size))    }    c.elemsize = uint16(elem.size)    c.elemtype = elem    // 循环数组长度    c.dataqsiz = uint(size)    // 返回 hchan 指针    return c}</code></pre><p>新建一个 chan 后，内存在堆上分配，大概长这样：</p><p><img src="https://user-images.githubusercontent.com/7698088/61337268-4d179600-a867-11e9-98ac-f979e3da00a6.png" alt="make chan"></p><p>说明一下，这张图来源于 Gopher Con 上的一份 PPT，地址见参考资料。这份材料非常清晰易懂，推荐你去读。</p><p>接下来，我们用一个来自参考资料【深入 channel 底层】的例子来理解创建、发送、接收的整个过程。</p><pre class=" language-golang"><code class="language-golang">func goroutineA(a <-chan int) {    val := <- a    fmt.Println("G1 received data: ", val)    return}func goroutineB(b <-chan int) {    val := <- b    fmt.Println("G2 received data: ", val)    return}func main() {    ch := make(chan int)    go goroutineA(ch)    go goroutineB(ch)    ch <- 3    time.Sleep(time.Second)}</code></pre><p>首先创建了一个无缓冲的 channel，接着启动两个 goroutine，并将前面创建的 channel 传递进去。然后，向这个 channel 中发送数据 3，最后 sleep 1 秒后程序退出。</p><p>程序第 14 行创建了一个非缓冲型的 channel，我们只看 chan 结构体中的一些重要字段，来从整体层面看一下 chan 的状态，一开始什么都没有：</p><p><img src="https://user-images.githubusercontent.com/7698088/61338760-91a63000-a86d-11e9-9c7e-edee8a594f66.png" alt="unbuffered chan"></p><h2 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h2><p>在继续分析前面小节的例子前，我们先来看一下接收相关的源码。在清楚了接收的具体过程之后，也就能轻松理解具体的例子了。</p><p>接收操作有两种写法，一种带 “ok”，反应 channel 是否关闭；一种不带  “ok”，这种写法，当接收到相应类型的零值时无法知道是真实的发送者发送过来的值，还是 channel 被关闭后，返回给接收者的默认类型的零值。两种写法，都有各自的应用场景。</p><p>经过编译器的处理后，这两种写法最后对应源码里的这两个函数：</p><pre class=" language-golang"><code class="language-golang">// entry points for <- c from compiled codefunc chanrecv1(c *hchan, elem unsafe.Pointer) {    chanrecv(c, elem, true)}func chanrecv2(c *hchan, elem unsafe.Pointer) (received bool) {    _, received = chanrecv(c, elem, true)    return}</code></pre><p><code>chanrecv1</code> 函数处理不带 “ok” 的情形，<code>chanrecv2</code> 则通过返回 “received” 这个字段来反应 channel 是否被关闭。接收值则比较特殊，会“放到”参数 <code>elem</code> 所指向的地址了，这很像 C/C++ 里的写法。如果代码里忽略了接收值，这里的 elem 为 nil。</p><p>无论如何，最终转向了 <code>chanrecv</code> 函数：</p><pre class=" language-golang"><code class="language-golang">// 位于 src/runtime/chan.go// chanrecv 函数接收 channel c 的元素并将其写入 ep 所指向的内存地址。// 如果 ep 是 nil，说明忽略了接收值。// 如果 block == false，即非阻塞型接收，在没有数据可接收的情况下，返回 (false, false)// 否则，如果 c 处于关闭状态，将 ep 指向的地址清零，返回 (true, false)// 否则，用返回值填充 ep 指向的内存地址。返回 (true, true)// 如果 ep 非空，则应该指向堆或者函数调用者的栈func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {    // 省略 debug 内容 …………    // 如果是一个 nil 的 channel    if c == nil {        // 如果不阻塞，直接返回 (false, false)        if !block {            return        }        // 否则，接收一个 nil 的 channel，goroutine 挂起        gopark(nil, nil, "chan receive (nil chan)", traceEvGoStop, 2)        // 不会执行到这里        throw("unreachable")    }    // 在非阻塞模式下，快速检测到失败，不用获取锁，快速返回    // 当我们观察到 channel 没准备好接收：    // 1. 非缓冲型，等待发送列队 sendq 里没有 goroutine 在等待    // 2. 缓冲型，但 buf 里没有元素    // 之后，又观察到 closed == 0，即 channel 未关闭。    // 因为 channel 不可能被重复打开，所以前一个观测的时候 channel 也是未关闭的，    // 因此在这种情况下可以直接宣布接收失败，返回 (false, false)    if !block && (c.dataqsiz == 0 && c.sendq.first == nil ||        c.dataqsiz > 0 && atomic.Loaduint(&c.qcount) == 0) &&        atomic.Load(&c.closed) == 0 {        return    }    var t0 int64    if blockprofilerate > 0 {        t0 = cputicks()    }    // 加锁    lock(&c.lock)    // channel 已关闭，并且循环数组 buf 里没有元素    // 这里可以处理非缓冲型关闭 和 缓冲型关闭但 buf 无元素的情况    // 也就是说即使是关闭状态，但在缓冲型的 channel，    // buf 里有元素的情况下还能接收到元素    if c.closed != 0 && c.qcount == 0 {        if raceenabled {            raceacquire(unsafe.Pointer(c))        }        // 解锁        unlock(&c.lock)        if ep != nil {            // 从一个已关闭的 channel 执行接收操作，且未忽略返回值            // 那么接收的值将是一个该类型的零值            // typedmemclr 根据类型清理相应地址的内存            typedmemclr(c.elemtype, ep)        }        // 从一个已关闭的 channel 接收，selected 会返回true        return true, false    }    // 等待发送队列里有 goroutine 存在，说明 buf 是满的    // 这有可能是：    // 1. 非缓冲型的 channel    // 2. 缓冲型的 channel，但 buf 满了    // 针对 1，直接进行内存拷贝（从 sender goroutine -> receiver goroutine）    // 针对 2，接收到循环数组头部的元素，并将发送者的元素放到循环数组尾部    if sg := c.sendq.dequeue(); sg != nil {        // Found a waiting sender. If buffer is size 0, receive value        // directly from sender. Otherwise, receive from head of queue        // and add sender's value to the tail of the queue (both map to        // the same buffer slot because the queue is full).        recv(c, sg, ep, func() { unlock(&c.lock) }, 3)        return true, true    }    // 缓冲型，buf 里有元素，可以正常接收    if c.qcount > 0 {        // 直接从循环数组里找到要接收的元素        qp := chanbuf(c, c.recvx)        // …………        // 代码里，没有忽略要接收的值，不是 "<- ch"，而是 "val <- ch"，ep 指向 val        if ep != nil {            typedmemmove(c.elemtype, ep, qp)        }        // 清理掉循环数组里相应位置的值        typedmemclr(c.elemtype, qp)        // 接收游标向前移动        c.recvx++        // 接收游标归零        if c.recvx == c.dataqsiz {            c.recvx = 0        }        // buf 数组里的元素个数减 1        c.qcount--        // 解锁        unlock(&c.lock)        return true, true    }    if !block {        // 非阻塞接收，解锁。selected 返回 false，因为没有接收到值        unlock(&c.lock)        return false, false    }    // 接下来就是要被阻塞的情况了    // 构造一个 sudog    gp := getg()    mysg := acquireSudog()    mysg.releasetime = 0    if t0 != 0 {        mysg.releasetime = -1    }    // 待接收数据的地址保存下来    mysg.elem = ep    mysg.waitlink = nil    gp.waiting = mysg    mysg.g = gp    mysg.selectdone = nil    mysg.c = c    gp.param = nil    // 进入channel 的等待接收队列    c.recvq.enqueue(mysg)    // 将当前 goroutine 挂起    goparkunlock(&c.lock, "chan receive", traceEvGoBlockRecv, 3)    // 被唤醒了，接着从这里继续执行一些扫尾工作    if mysg != gp.waiting {        throw("G waiting list is corrupted")    }    gp.waiting = nil    if mysg.releasetime > 0 {        blockevent(mysg.releasetime-t0, 2)    }    closed := gp.param == nil    gp.param = nil    mysg.c = nil    releaseSudog(mysg)    return true, !closed}</code></pre><p>上面的代码注释地比较详细了，你可以对着源码一行行地去看，我们再来详细看一下。</p><ul><li><p>如果 channel 是一个空值（nil），在非阻塞模式下，会直接返回。在阻塞模式下，会调用 gopark 函数挂起 goroutine，这个会一直阻塞下去。因为在 channel 是 nil 的情况下，要想不阻塞，只有关闭它，但关闭一个 nil 的 channel 又会发生 panic，所以没有机会被唤醒了。更详细地可以在 closechan 函数的时候再看。</p></li><li><p>和发送函数一样，接下来搞了一个在非阻塞模式下，不用获取锁，快速检测到失败并且返回的操作。顺带插一句，我们平时在写代码的时候，找到一些边界条件，快速返回，能让代码逻辑更清晰，因为接下来的正常情况就比较少，更聚焦了，看代码的人也更能专注地看核心代码逻辑了。</p></li></ul><pre class=" language-golang"><code class="language-golang">    // 在非阻塞模式下，快速检测到失败，不用获取锁，快速返回 (false, false)    if !block && (c.dataqsiz == 0 && c.sendq.first == nil ||        c.dataqsiz > 0 && atomic.Loaduint(&c.qcount) == 0) &&        atomic.Load(&c.closed) == 0 {        return    }</code></pre><p>当我们观察到 channel 没准备好接收：</p><ol><li>非缓冲型，等待发送列队里没有 goroutine 在等待</li><li>缓冲型，但 buf 里没有元素</li></ol><p>之后，又观察到 closed == 0，即 channel 未关闭。</p><p>因为 channel 不可能被重复打开，所以前一个观测的时候， channel 也是未关闭的，因此在这种情况下可以直接宣布接收失败，快速返回。因为没被选中，也没接收到数据，所以返回值为 (false, false)。</p><ul><li><p>接下来的操作，首先会上一把锁，粒度比较大。如果 channel 已关闭，并且循环数组 buf 里没有元素。对应非缓冲型关闭和缓冲型关闭但 buf 无元素的情况，返回对应类型的零值，但 received 标识是 false，告诉调用者此 channel 已关闭，你取出来的值并不是正常由发送者发送过来的数据。但是如果处于 select 语境下，这种情况是被选中了的。很多将 channel 用作通知信号的场景就是命中了这里。</p></li><li><p>接下来，如果有等待发送的队列，说明 channel 已经满了，要么是非缓冲型的 channel，要么是缓冲型的 channel，但 buf 满了。这两种情况下都可以正常接收数据。</p></li></ul><p>于是，调用 recv 函数：</p><pre class=" language-golang"><code class="language-golang">func recv(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {    // 如果是非缓冲型的 channel    if c.dataqsiz == 0 {        if raceenabled {            racesync(c, sg)        }        // 未忽略接收的数据        if ep != nil {            // 直接拷贝数据，从 sender goroutine -> receiver goroutine            recvDirect(c.elemtype, sg, ep)        }    } else {        // 缓冲型的 channel，但 buf 已满。        // 将循环数组 buf 队首的元素拷贝到接收数据的地址        // 将发送者的数据入队。实际上这时 revx 和 sendx 值相等        // 找到接收游标        qp := chanbuf(c, c.recvx)        // …………        // 将接收游标处的数据拷贝给接收者        if ep != nil {            typedmemmove(c.elemtype, ep, qp)        }        // 将发送者数据拷贝到 buf        typedmemmove(c.elemtype, qp, sg.elem)        // 更新游标值        c.recvx++        if c.recvx == c.dataqsiz {            c.recvx = 0        }        c.sendx = c.recvx    }    sg.elem = nil    gp := sg.g    // 解锁    unlockf()    gp.param = unsafe.Pointer(sg)    if sg.releasetime != 0 {        sg.releasetime = cputicks()    }    // 唤醒发送的 goroutine。需要等到调度器的光临    goready(gp, skip+1)}</code></pre><p>如果是非缓冲型的，就直接从发送者的栈拷贝到接收者的栈。</p><pre class=" language-golang"><code class="language-golang">func recvDirect(t *_type, sg *sudog, dst unsafe.Pointer) {    // dst is on our stack or the heap, src is on another stack.    src := sg.elem    typeBitsBulkBarrier(t, uintptr(dst), uintptr(src), t.size)    memmove(dst, src, t.size)}</code></pre><p>否则，就是缓冲型 channel，而 buf 又满了的情形。说明发送游标和接收游标重合了，因此需要先找到接收游标：</p><pre class=" language-golang"><code class="language-golang">// chanbuf(c, i) is pointer to the i'th slot in the buffer.func chanbuf(c *hchan, i uint) unsafe.Pointer {    return add(c.buf, uintptr(i)*uintptr(c.elemsize))}</code></pre><p>将该处的元素拷贝到接收地址。然后将发送者待发送的数据拷贝到接收游标处。这样就完成了接收数据和发送数据的操作。接着，分别将发送游标和接收游标向前进一，如果发生“环绕”，再从 0 开始。</p><p>最后，取出 sudog 里的 goroutine，调用 goready 将其状态改成 “runnable”，待发送者被唤醒，等待调度器的调度。</p><ul><li><p>然后，如果 channel 的 buf 里还有数据，说明可以比较正常地接收。注意，这里，即使是在 channel 已经关闭的情况下，也是可以走到这里的。这一步比较简单，正常地将 buf 里接收游标处的数据拷贝到接收数据的地址。</p></li><li><p>到了最后一步，走到这里来的情形是要阻塞的。当然，如果 block 传进来的值是 false，那就不阻塞，直接返回就好了。</p></li></ul><p>先构造一个 sudog，接着就是保存各种值了。注意，这里会将接收数据的地址存储到了 <code>elem</code> 字段，当被唤醒时，接收到的数据就会保存到这个字段指向的地址。然后将 sudog 添加到 channel 的 recvq 队列里。调用 goparkunlock 函数将 goroutine 挂起。</p><p>接下来的代码就是 goroutine 被唤醒后的各种收尾工作了。</p><p>我们继续之前的例子。前面说到第 14 行，创建了一个非缓冲型的 channel，接着，第 15、16 行分别创建了一个 goroutine，各自执行了一个接收操作。通过前面的源码分析，我们知道，这两个 goroutine （后面称为 G1 和 G2 好了）都会被阻塞在接收操作。G1 和 G2 会挂在 channel 的 recq 队列中，形成一个双向循环链表。</p><p>在程序的 17 行之前，chan 的整体数据结构如下：</p><p><img src="https://user-images.githubusercontent.com/7698088/61179141-19eac200-a62f-11e9-836d-b6b95d52f6fb.png" alt="chan struct at the runtime"></p><p><code>buf</code> 指向一个长度为 0 的数组，qcount 为 0，表示 channel 中没有元素。重点关注 <code>recvq</code> 和 <code>sendq</code>，它们是 waitq 结构体，而 waitq 实际上就是一个双向链表，链表的元素是 sudog，里面包含 <code>g</code> 字段，<code>g</code> 表示一个 goroutine，所以 sudog 可以看成一个 goroutine。recvq 存储那些尝试读取 channel 但被阻塞的 goroutine，sendq 则存储那些尝试写入 channel，但被阻塞的 goroutine。</p><p>此时，我们可以看到，recvq 里挂了两个 goroutine，也就是前面启动的 G1 和 G2。因为没有 goroutine 接收，而 channel 又是无缓冲类型，所以 G1 和 G2 被阻塞。sendq 没有被阻塞的 goroutine。</p><p><code>recvq</code> 的数据结构如下。这里直接引用文章中的一幅图，用了三维元素，画得很好：</p><p><img src="https://user-images.githubusercontent.com/7698088/61179210-d3966280-a630-11e9-8c73-5a22340910a6.png" alt="recvq structure"></p><p>再从整体上来看一下 chan 此时的状态：</p><p><img src="https://user-images.githubusercontent.com/7698088/61340165-bbfaec00-a873-11e9-83de-66bc63e603f1.png" alt="chan state"></p><p>G1 和 G2 被挂起了，状态是 <code>WAITING</code>。关于 goroutine 调度器这块不是今天的重点，当然后面肯定会写相关的文章。这里先简单说下，goroutine 是用户态的协程，由 Go runtime 进行管理，作为对比，内核线程由 OS 进行管理。Goroutine 更轻量，因此我们可以轻松创建数万 goroutine。</p><p>一个内核线程可以管理多个 goroutine，当其中一个 goroutine 阻塞时，内核线程可以调度其他的 goroutine 来运行，内核线程本身不会阻塞。这就是通常我们说的 <code>M:N</code> 模型：</p><p><img src="https://user-images.githubusercontent.com/7698088/61340362-8c001880-a874-11e9-9237-d97e6105cd62.png" alt="M:N scheduling"></p><p><code>M:N</code> 模型通常由三部分构成：M、P、G。M 是内核线程，负责运行 goroutine；P 是 context，保存 goroutine 运行所需要的上下文，它还维护了可运行（runnable）的 goroutine 列表；G 则是待运行的 goroutine。M 和 P 是 G 运行的基础。</p><p><img src="https://user-images.githubusercontent.com/7698088/61340473-1183c880-a875-11e9-9b3e-86f376d3ae55.png" alt="MGP"></p><p>继续回到例子。假设我们只有一个 M，当 G1（<code>go goroutineA(ch)</code>） 运行到 <code>val := &lt;- a</code> 时，它由本来的 running 状态变成了 waiting 状态（调用了 gopark 之后的结果）：</p><p><img src="https://user-images.githubusercontent.com/7698088/61340756-45abb900-a876-11e9-8ac7-4c40b4c23253.png" alt="G1 running"></p><p>G1 脱离与 M 的关系，但调度器可不会让 M 闲着，所以会接着调度另一个 goroutine 来运行：</p><p><img src="https://user-images.githubusercontent.com/7698088/61340787-67a53b80-a876-11e9-94a4-a6c3698eb8ed.png" alt="G1 waiting"></p><p>G2 也是同样的遭遇。现在 G1 和 G2 都被挂起了，等待着一个 sender 往 channel 里发送数据，才能得到解救。</p><h2 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h2><p>接着上面的例子，G1 和 G2 现在都在 recvq 队列里了。</p><pre class=" language-golang"><code class="language-golang">ch <- 3</code></pre><p>第 17 行向 channel 发送了一个元素 3。</p><p>发送操作最终转化为 <code>chansend</code> 函数，直接上源码，同样大部分都注释了，可以看懂主流程：</p><pre class=" language-golang"><code class="language-golang">// 位于 src/runtime/chan.gofunc chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {    // 如果 channel 是 nil    if c == nil {        // 不能阻塞，直接返回 false，表示未发送成功        if !block {            return false        }        // 当前 goroutine 被挂起        gopark(nil, nil, "chan send (nil chan)", traceEvGoStop, 2)        throw("unreachable")    }    // 省略 debug 相关……    // 对于不阻塞的 send，快速检测失败场景    //    // 如果 channel 未关闭且 channel 没有多余的缓冲空间。这可能是：    // 1. channel 是非缓冲型的，且等待接收队列里没有 goroutine    // 2. channel 是缓冲型的，但循环数组已经装满了元素    if !block && c.closed == 0 && ((c.dataqsiz == 0 && c.recvq.first == nil) ||        (c.dataqsiz > 0 && c.qcount == c.dataqsiz)) {        return false    }    var t0 int64    if blockprofilerate > 0 {        t0 = cputicks()    }    // 锁住 channel，并发安全    lock(&c.lock)    // 如果 channel 关闭了    if c.closed != 0 {        // 解锁        unlock(&c.lock)        // 直接 panic        panic(plainError("send on closed channel"))    }    // 如果接收队列里有 goroutine，直接将要发送的数据拷贝到接收 goroutine    if sg := c.recvq.dequeue(); sg != nil {        send(c, sg, ep, func() { unlock(&c.lock) }, 3)        return true    }    // 对于缓冲型的 channel，如果还有缓冲空间    if c.qcount < c.dataqsiz {        // qp 指向 buf 的 sendx 位置        qp := chanbuf(c, c.sendx)        // ……        // 将数据从 ep 处拷贝到 qp        typedmemmove(c.elemtype, qp, ep)        // 发送游标值加 1        c.sendx++        // 如果发送游标值等于容量值，游标值归 0        if c.sendx == c.dataqsiz {            c.sendx = 0        }        // 缓冲区的元素数量加一        c.qcount++        // 解锁        unlock(&c.lock)        return true    }    // 如果不需要阻塞，则直接返回错误    if !block {        unlock(&c.lock)        return false    }    // channel 满了，发送方会被阻塞。接下来会构造一个 sudog    // 获取当前 goroutine 的指针    gp := getg()    mysg := acquireSudog()    mysg.releasetime = 0    if t0 != 0 {        mysg.releasetime = -1    }    mysg.elem = ep    mysg.waitlink = nil    mysg.g = gp    mysg.selectdone = nil    mysg.c = c    gp.waiting = mysg    gp.param = nil    // 当前 goroutine 进入发送等待队列    c.sendq.enqueue(mysg)    // 当前 goroutine 被挂起    goparkunlock(&c.lock, "chan send", traceEvGoBlockSend, 3)    // 从这里开始被唤醒了（channel 有机会可以发送了）    if mysg != gp.waiting {        throw("G waiting list is corrupted")    }    gp.waiting = nil    if gp.param == nil {        if c.closed == 0 {            throw("chansend: spurious wakeup")        }        // 被唤醒后，channel 关闭了。坑爹啊，panic        panic(plainError("send on closed channel"))    }    gp.param = nil    if mysg.releasetime > 0 {        blockevent(mysg.releasetime-t0, 2)    }    // 去掉 mysg 上绑定的 channel    mysg.c = nil    releaseSudog(mysg)    return true}</code></pre><p>上面的代码注释地比较详细了，我们来详细看看。</p><ul><li><p>如果检测到 channel 是空的，当前 goroutine 会被挂起。</p></li><li><p>对于不阻塞的发送操作，如果 channel 未关闭并且没有多余的缓冲空间（说明：a. channel 是非缓冲型的，且等待接收队列里没有 goroutine；b. channel 是缓冲型的，但循环数组已经装满了元素）</p></li></ul><p>对于这一点，runtime 源码里注释了很多。这一条判断语句是为了在不阻塞发送的场景下快速检测到发送失败，好快速返回。</p><pre class=" language-golang"><code class="language-golang">if !block && c.closed == 0 && ((c.dataqsiz == 0 && c.recvq.first == nil) || (c.dataqsiz > 0 && c.qcount == c.dataqsiz)) {    return false}</code></pre><p>注释里主要讲为什么这一块可以不加锁，我详细解释一下。<code>if</code> 条件里先读了两个变量：block 和 c.closed。block 是函数的参数，不会变；c.closed 可能被其他 goroutine 改变，因为没加锁嘛，这是“与”条件前面两个表达式。</p><p>最后一项，涉及到三个变量：c.dataqsiz，c.recvq.first，c.qcount。<code>c.dataqsiz == 0 &amp;&amp; c.recvq.first == nil</code> 指的是非缓冲型的 channel，并且 recvq 里没有等待接收的 goroutine；<code>c.dataqsiz &gt; 0 &amp;&amp; c.qcount == c.dataqsiz</code> 指的是缓冲型的 channel，但循环数组已经满了。这里 <code>c.dataqsiz</code> 实际上也是不会被修改的，在创建的时候就已经确定了。不加锁真正影响地是 <code>c.qcount</code> 和 <code>c.recvq.first</code>。</p><p>这一部分的条件就是两个 <code>word-sized read</code>，就是读两个 word 操作：<code>c.closed</code> 和 <code>c.recvq.first</code>（非缓冲型） 或者 <code>c.qcount</code>（缓冲型）。</p><p>当我们发现 <code>c.closed == 0</code> 为真，也就是 channel 未被关闭，再去检测第三部分的条件时，观测到 <code>c.recvq.first == nil</code> 或者 <code>c.qcount == c.dataqsiz</code> 时（这里忽略 <code>c.dataqsiz</code>），就断定要将这次发送操作作失败处理，快速返回 false。</p><p>这里涉及到两个观测项：channel 未关闭、channel not ready for sending。这两项都会因为没加锁而出现观测前后不一致的情况。例如我先观测到 channel 未被关闭，再观察到 channel not ready for sending，这时我以为能满足这个 if 条件了，但是如果这时 c.closed 变成 1，这时其实就不满足条件了，谁让你不加锁呢！</p><p>但是，因为一个 closed channel 不能将 channel 状态从 ‘ready for sending’ 变成 ‘not ready for sending’，所以当我观测到 ‘not ready for sending’ 时，channel 不是 closed。即使 <code>c.closed == 1</code>，即 channel 是在这两个观测中间被关闭的，那也说明在这两个观测中间，channel 满足两个条件：<code>not closed</code> 和 <code>not ready for sending</code>，这时，我直接返回 false 也是没有问题的。</p><p>这部分解释地比较绕，其实这样做的目的就是少获取一次锁，提升性能。</p><ul><li><p>如果检测到 channel 已经关闭，直接 panic。</p></li><li><p>如果能从等待接收队列 recvq 里出队一个 sudog（代表一个 goroutine），说明此时 channel 是空的，没有元素，所以才会有等待接收者。这时会调用 send 函数将元素直接从发送者的栈拷贝到接收者的栈，关键操作由 <code>sendDirect</code> 函数完成。</p></li></ul><pre class=" language-golang"><code class="language-golang">// send 函数处理向一个空的 channel 发送操作// ep 指向被发送的元素，会被直接拷贝到接收的 goroutine// 之后，接收的 goroutine 会被唤醒// c 必须是空的（因为等待队列里有 goroutine，肯定是空的）// c 必须被上锁，发送操作执行完后，会使用 unlockf 函数解锁// sg 必须已经从等待队列里取出来了// ep 必须是非空，并且它指向堆或调用者的栈func send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {    // 省略一些用不到的    // ……    // sg.elem 指向接收到的值存放的位置，如 val <- ch，指的就是 &val    if sg.elem != nil {        // 直接拷贝内存（从发送者到接收者）        sendDirect(c.elemtype, sg, ep)        sg.elem = nil    }    // sudog 上绑定的 goroutine    gp := sg.g    // 解锁    unlockf()    gp.param = unsafe.Pointer(sg)    if sg.releasetime != 0 {        sg.releasetime = cputicks()    }    // 唤醒接收的 goroutine. skip 和打印栈相关，暂时不理会    goready(gp, skip+1)}</code></pre><p>继续看 <code>sendDirect</code> 函数：</p><pre class=" language-golang"><code class="language-golang">// 向一个非缓冲型的 channel 发送数据、从一个无元素的（非缓冲型或缓冲型但空）的 channel// 接收数据，都会导致一个 goroutine 直接操作另一个 goroutine 的栈// 由于 GC 假设对栈的写操作只能发生在 goroutine 正在运行中并且由当前 goroutine 来写// 所以这里实际上违反了这个假设。可能会造成一些问题，所以需要用到写屏障来规避func sendDirect(t *_type, sg *sudog, src unsafe.Pointer) {    // src 在当前 goroutine 的栈上，dst 是另一个 goroutine 的栈    // 直接进行内存"搬迁"    // 如果目标地址的栈发生了栈收缩，当我们读出了 sg.elem 后    // 就不能修改真正的 dst 位置的值了    // 因此需要在读和写之前加上一个屏障    dst := sg.elem    typeBitsBulkBarrier(t, uintptr(dst), uintptr(src), t.size)    memmove(dst, src, t.size)}</code></pre><p>这里涉及到一个 goroutine 直接写另一个 goroutine 栈的操作，一般而言，不同 goroutine 的栈是各自独有的。而这也违反了 GC 的一些假设。为了不出问题，写的过程中增加了写屏障，保证正确地完成写操作。这样做的好处是减少了一次内存 copy：不用先拷贝到 channel 的 buf，直接由发送者到接收者，没有中间商赚差价，效率得以提高，完美。</p><p>然后，解锁、唤醒接收者，等待调度器的光临，接收者也得以重见天日，可以继续执行接收操作之后的代码了。</p><ul><li>如果 <code>c.qcount &lt; c.dataqsiz</code>，说明缓冲区可用（肯定是缓冲型的 channel）。先通过函数取出待发送元素应该去到的位置：</li></ul><pre class=" language-golang"><code class="language-golang">qp := chanbuf(c, c.sendx)// 返回循环队列里第 i 个元素的地址处func chanbuf(c *hchan, i uint) unsafe.Pointer {    return add(c.buf, uintptr(i)*uintptr(c.elemsize))}</code></pre><p><code>c.sendx</code> 指向下一个待发送元素在循环数组中的位置，然后调用 <code>typedmemmove</code> 函数将其拷贝到循环数组中。之后 <code>c.sendx</code> 加 1，元素总量加 1 ：<code>c.qcount++</code>，最后，解锁并返回。</p><ul><li><p>如果没有命中以上条件的，说明 channel 已经满了。不管这个 channel 是缓冲型的还是非缓冲型的，都要将这个 sender “关起来”（goroutine 被阻塞）。如果 block 为 false，直接解锁，返回 false。</p></li><li><p>最后就是真的需要被阻塞的情况。先构造一个 sudog，将其入队（channel 的 sendq 字段）。然后调用 <code>goparkunlock</code> 将当前 goroutine 挂起，并解锁，等待合适的时机再唤醒。</p></li></ul><p>唤醒之后，从 <code>goparkunlock</code> 下一行代码开始继续往下执行。</p><p>这里有一些绑定操作，sudog 通过 g 字段绑定 goroutine，而 goroutine 通过 waiting 绑定 sudog，sudog 还通过 <code>elem</code> 字段绑定待发送元素的地址，以及 <code>c</code> 字段绑定被“坑”在此处的 channel。</p><p>所以，待发送的元素地址其实是存储在 sudog 结构体里，也就是当前 goroutine 里。</p><p>好了，看完源码。我们接着来分析例子，相信大家已经把例子忘得差不多了，我再贴一下代码：</p><pre class=" language-golang"><code class="language-golang">func goroutineA(a <-chan int) {    val := <- a    fmt.Println("goroutine A received data: ", val)    return}func goroutineB(b <-chan int) {    val := <- b    fmt.Println("goroutine B received data: ", val)    return}func main() {    ch := make(chan int)    go goroutineA(ch)    go goroutineB(ch)    ch <- 3    time.Sleep(time.Second)    ch1 := make(chan struct{})}</code></pre><p>在发送小节里我们说到 G1 和 G2 现在被挂起来了，等待 sender 的解救。在第 17 行，主协程向 ch 发送了一个元素 3，来看下接下来会发生什么。</p><p>根据前面源码分析的结果，我们知道，sender 发现 ch 的 recvq 里有 receiver 在等待着接收，就会出队一个 sudog，把 recvq 里 first 指针的 sudo “推举”出来了，并将其加入到 P 的可运行 goroutine 队列中。</p><p>然后，sender 把发送元素拷贝到 sudog 的 elem 地址处，最后会调用 goready 将 G1 唤醒，状态变为 runnable。</p><p><img src="https://user-images.githubusercontent.com/7698088/61342598-4bf16380-a87d-11e9-8667-c22b02030d6b.png" alt="G1 runnable"></p><p>当调度器光顾 G1 时，将 G1 变成 running 状态，执行 goroutineA 接下来的代码。G 表示其他可能有的 goroutine。</p><p>这里其实涉及到一个协程写另一个协程栈的操作。有两个 receiver 在 channel 的一边虎视眈眈地等着，这时 channel 另一边来了一个 sender 准备向 channel 发送数据，为了高效，用不着通过 channel 的 buf “中转”一次，直接从源地址把数据 copy 到目的地址就可以了，效率高啊！</p><p><img src="https://user-images.githubusercontent.com/7698088/61342620-64fa1480-a87d-11e9-8cac-eacd2f4892f8.png" alt="send direct"></p><p>上图是一个示意图，<code>3</code> 会被拷贝到 G1 栈上的某个位置，也就是 val 的地址处，保存在 elem 字段。</p><h2 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h2><p>关闭某个 channel，会执行函数 <code>closechan</code>：</p><pre class=" language-golang"><code class="language-golang">func closechan(c *hchan) {    // 关闭一个 nil channel，panic    if c == nil {        panic(plainError("close of nil channel"))    }    // 上锁    lock(&c.lock)    // 如果 channel 已经关闭    if c.closed != 0 {        unlock(&c.lock)        // panic        panic(plainError("close of closed channel"))    }    // …………    // 修改关闭状态    c.closed = 1    var glist *g    // 将 channel 所有等待接收队列的里 sudog 释放    for {        // 从接收队列里出队一个 sudog        sg := c.recvq.dequeue()        // 出队完毕，跳出循环        if sg == nil {            break        }        // 如果 elem 不为空，说明此 receiver 未忽略接收数据        // 给它赋一个相应类型的零值        if sg.elem != nil {            typedmemclr(c.elemtype, sg.elem)            sg.elem = nil        }        if sg.releasetime != 0 {            sg.releasetime = cputicks()        }        // 取出 goroutine        gp := sg.g        gp.param = nil        if raceenabled {            raceacquireg(gp, unsafe.Pointer(c))        }        // 相连，形成链表        gp.schedlink.set(glist)        glist = gp    }    // 将 channel 等待发送队列里的 sudog 释放    // 如果存在，这些 goroutine 将会 panic    for {        // 从发送队列里出队一个 sudog        sg := c.sendq.dequeue()        if sg == nil {            break        }        // 发送者会 panic        sg.elem = nil        if sg.releasetime != 0 {            sg.releasetime = cputicks()        }        gp := sg.g        gp.param = nil        if raceenabled {            raceacquireg(gp, unsafe.Pointer(c))        }        // 形成链表        gp.schedlink.set(glist)        glist = gp    }    // 解锁    unlock(&c.lock)    // Ready all Gs now that we've dropped the channel lock.    // 遍历链表    for glist != nil {        // 取最后一个        gp := glist        // 向前走一步，下一个唤醒的 g        glist = glist.schedlink.ptr()        gp.schedlink = 0        // 唤醒相应 goroutine        goready(gp, 3)    }}</code></pre><p>close 逻辑比较简单，对于一个 channel，recvq 和 sendq 中分别保存了阻塞的发送者和接收者。关闭 channel 后，对于等待接收者而言，会收到一个相应类型的零值。对于等待发送者，会直接 panic。所以，在不了解 channel 还有没有接收者的情况下，不能贸然关闭 channel。</p><p>close 函数先上一把大锁，接着把所有挂在这个 channel 上的 sender 和 receiver 全都连成一个 sudog 链表，再解锁。最后，再将所有的 sudog 全都唤醒。</p><p>唤醒之后，该干嘛干嘛。sender 会继续执行 chansend 函数里 goparkunlock 函数之后的代码，很不幸，检测到 channel 已经关闭了，panic。receiver 则比较幸运，进行一些扫尾工作后，返回。这里，selected 返回 true，而返回值 received 则要根据 channel 是否关闭，返回不同的值。如果 channel 关闭，received 为 false，否则为 true。这我们分析的这种情况下，received 返回 false。</p><h1 id="channel-进阶"><a href="#channel-进阶" class="headerlink" title="channel 进阶"></a>channel 进阶</h1><p>总结一下操作 channel 的结果：</p><table><thead><tr><th>操作</th><th>nil channel</th><th>closed channel</th><th>not nil, not closed channel</th></tr></thead><tbody><tr><td>close</td><td>panic</td><td>panic</td><td>正常关闭</td></tr><tr><td>读 &lt;- ch</td><td>阻塞</td><td>读到对应类型的零值</td><td>阻塞或正常读取数据。缓冲型 channel 为空或非缓冲型 channel 没有等待发送者时会阻塞</td></tr><tr><td>写 ch &lt;-</td><td>阻塞</td><td>panic</td><td>阻塞或正常写入数据。非缓冲型 channel 没有等待接收者或缓冲型 channel buf 满时会被阻塞</td></tr></tbody></table><p>总结一下，发生 panic 的情况有三种：向一个关闭的 channel 进行写操作；关闭一个 nil 的 channel；重复关闭一个 channel。</p><p>读、写一个 nil channel 都会被阻塞。</p><h2 id="发送和接收元素的本质"><a href="#发送和接收元素的本质" class="headerlink" title="发送和接收元素的本质"></a>发送和接收元素的本质</h2><p>Channel 发送和接收元素的本质是什么？参考资料【深入 channel 底层】里是这样回答的：</p><blockquote><p>Remember all transfer of value on the go channels happens with the copy of value.</p></blockquote><p>就是说 channel 的发送和接收操作本质上都是 “值的拷贝”，无论是从 sender goroutine 的栈到 chan buf，还是从 chan buf 到 receiver goroutine，或者是直接从 sender goroutine 到 receiver goroutine。</p><p>这里再引用文中的一个例子，我会加上更加详细地解释。顺带说一下，这是一篇英文的博客，写得很好，没有像我们这篇文章那样大段的源码分析，它是将代码里情况拆开来各自描述的，各有利弊吧。推荐去读下原文，阅读体验比较好。</p><pre class=" language-golang"><code class="language-golang">type user struct {    name string    age int8}var u = user{name: "Ankur", age: 25}var g = &ufunc modifyUser(pu *user) {    fmt.Println("modifyUser Received Vaule", pu)    pu.name = "Anand"}func printUser(u <-chan *user) {    time.Sleep(2 * time.Second)    fmt.Println("printUser goRoutine called", <-u)}func main() {    c := make(chan *user, 5)    c <- g    fmt.Println(g)    // modify g    g = &user{name: "Ankur Anand", age: 100}    go printUser(c)    go modifyUser(g)    time.Sleep(5 * time.Second)    fmt.Println(g)}</code></pre><p>运行结果：</p><pre class=" language-shell"><code class="language-shell">&{Ankur 25}modifyUser Received Value &{Ankur Anand 100}printUser goRoutine called &{Ankur 25}&{Anand 100}</code></pre><p>这里就是一个很好的 <code>share memory by communicating</code> 的例子。</p><p><img src="https://user-images.githubusercontent.com/7698088/61191276-16ad1000-a6db-11e9-9729-cdea7744f002.png" alt="output"></p><p>一开始构造一个结构体 u，地址是 0x56420，图中地址上方就是它的内容。接着把 <code>&amp;u</code> 赋值给指针 <code>g</code>，g 的地址是 0x565bb0，它的内容就是一个地址，指向 u。</p><p>main 程序里，先把 g 发送到 c，根据 <code>copy value</code> 的本质，进入到 chan buf 里的就是 <code>0x56420</code>，它是指针 g 的值（不是它指向的内容），所以打印从 channel 接收到的元素时，它就是 <code>&amp;{Ankur 25}</code>。因此，这里并不是将指针 g “发送” 到了 channel 里，只是拷贝它的值而已。</p><p>再强调一次：</p><blockquote><p>Remember all transfer of value on the go channels happens with the copy of value.</p></blockquote><h2 id="资源泄漏"><a href="#资源泄漏" class="headerlink" title="资源泄漏"></a>资源泄漏</h2><p>Channel 可能会引发 goroutine 泄漏。</p><p>泄漏的原因是 goroutine 操作 channel 后，处于发送或接收阻塞状态，而 channel 处于满或空的状态，一直得不到改变。同时，垃圾回收器也不会回收此类资源，进而导致 gouroutine 会一直处于等待队列中，不见天日。</p><p>雨痕老师的《Go 语言学习笔记》第 8 章通道的“资源泄露”一节举了个例子，大家可以自己去看。</p><h2 id="happened-before"><a href="#happened-before" class="headerlink" title="happened before"></a>happened before</h2><p>维基百科上给的定义：</p><blockquote><p>In computer science, the happened-before relation (denoted: -&gt;) is a relation between the result of two events, such that if one event should happen before another event, the result must reflect that, even if those events are in reality executed out of order (usually to optimize program flow).</p></blockquote><p>简单来说就是如果事件 a 和事件 b 存在 happened-before 关系，即 a -&gt; b，那么 a，b 完成后的结果一定要体现这种关系。由于现代编译器、CPU 会做各种优化，包括编译器重排、内存重排等等，在并发代码里，happened-before 限制就非常重要了。</p><p>根据晃岳攀老师在 Gopher China 2019 上的并发编程分享，关于 channel 的发送（send）、发送完成（send finished）、接收（receive）、接收完成（receive finished）的 happened-before 关系如下：</p><ol><li>第 n 个 <code>send</code> 一定 <code>happened before</code> 第 n 个 <code>receive finished</code>，无论是缓冲型还是非缓冲型的 channel。</li><li>对于容量为 m 的缓冲型 channel，第 n 个 <code>receive</code> 一定 <code>happened before</code> 第 n+m 个 <code>send finished</code>。</li><li>对于非缓冲型的 channel，第 n 个 <code>receive</code> 一定 <code>happened before</code> 第 n 个 <code>send finished</code>。</li><li>channel close 一定 <code>happened before</code> receiver 得到通知。</li></ol><p>我们来逐条解释一下。</p><p>第一条，我们从源码的角度看也是对的，send 不一定是 <code>happened before</code> receive，因为有时候是先 receive，然后 goroutine 被挂起，之后被 sender 唤醒，send happened after receive。但不管怎样，要想完成接收，一定是要先有发送。</p><p>第二条，缓冲型的 channel，当第 n+m 个 send 发生后，有下面两种情况：</p><p>若第 n 个 receive 没发生。这时，channel 被填满了，send 就会被阻塞。那当第 n 个 receive 发生时，sender goroutine 会被唤醒，之后再继续发送过程。这样，第 n 个 <code>receive</code> 一定 <code>happened before</code> 第 n+m 个 <code>send finished</code>。</p><p>若第 n 个 receive 已经发生过了，这直接就符合了要求。</p><p>第三条，也是比较好理解的。第 n 个 send 如果被阻塞，sender goroutine 挂起，第 n 个 receive 这时到来，先于第 n 个 send finished。如果第 n 个 send 未被阻塞，说明第 n 个 receive 早就在那等着了，它不仅 happened before send finished，它还 happened before send。</p><p>第四条，回忆一下源码，先设置完 closed = 1，再唤醒等待的 receiver，并将零值拷贝给 receiver。</p><p>参考资料【鸟窝 并发编程分享】这篇博文的评论区有 PPT 的下载链接，这是晁老师在 Gopher 2019 大会上的演讲。</p><p>关于 happened before，这里再介绍一个柴大和曹大的新书《Go 语言高级编程》里面提到的一个例子。</p><p>书中 1.5 节先讲了顺序一致性的内存模型，这是并发编程的基础。</p><p>我们直接来看例子：</p><pre class=" language-golang"><code class="language-golang">var done = make(chan bool)var msg stringfunc aGoroutine() {    msg = "hello, world"    done <- true}func main() {    go aGoroutine()    <-done    println(msg)}</code></pre><p>先定义了一个 done channel 和一个待打印的字符串。在 main 函数里，启动一个 goroutine，等待从 done 里接收到一个值后，执行打印 msg 的操作。如果 main 函数中没有 <code>&lt;-done</code> 这行代码，打印出来的 msg 为空，因为 aGoroutine 来不及被调度，还来不及给 msg 赋值，主程序就会退出。而在 Go 语言里，主协程退出时不会等待其他协程。</p><p>加了 <code>&lt;-done</code> 这行代码后，就会阻塞在此。等 aGoroutine 里向 done 发送了一个值之后，才会被唤醒，继续执行打印 msg 的操作。而这在之前，msg 已经被赋值过了，所以会打印出 <code>hello, world</code>。</p><p>这里依赖的 happened before 就是前面讲的第一条。第一个 send 一定 happened before 第一个 receive finished，即 <code>done &lt;- true</code> 先于 <code>&lt;-done</code> 发生，这意味着 main 函数里执行完 <code>&lt;-done</code> 后接着执行 <code>println(msg)</code> 这一行代码时，msg 已经被赋过值了，所以会打印出想要的结果。</p><p>书中，又进一步利用前面提到的第 3 条 happened before 规则，修改了一下代码：</p><pre class=" language-golang"><code class="language-golang">var done = make(chan bool)var msg stringfunc aGoroutine() {    msg = "hello, world"    <-done}func main() {    go aGoroutine()    done <- true    println(msg)}</code></pre><p>同样可以得到相同的结果，为什么？根据第三条规则，对于非缓冲型的 channel，第一个 receive 一定 happened before 第一个 send finished。也就是说，<br>在 <code>done &lt;- true</code> 完成之前，<code>&lt;-done</code> 就已经发生了，也就意味着 msg 已经被赋上值了，最终也会打印出 <code>hello, world</code>。</p><h2 id="如何优雅地关闭-channel"><a href="#如何优雅地关闭-channel" class="headerlink" title="如何优雅地关闭 channel"></a>如何优雅地关闭 channel</h2><p>这部分内容主要来自 Go 101 上的一篇英文文章，参考资料【如何优雅地关闭 channel】可以直达原文。</p><p>文章先“吐槽”了下 Go channel 在设计上的一些问题，接着给出了几种不同情况下如何优雅地关闭 channel 的例子。按照惯例，我会在原作者内容的基础上给出自己的解读，看完这一节你可以再回头看一下英文原文，会觉得很有意思。</p><p>关于 channel 的使用，有几点不方便的地方：</p><ol><li>在不改变 channel 自身状态的情况下，无法获知一个 channel 是否关闭。</li><li>关闭一个 closed channel 会导致 panic。所以，如果关闭 channel 的一方在不知道 channel 是否处于关闭状态时就去贸然关闭 channel 是很危险的事情。</li><li>向一个 closed channel 发送数据会导致 panic。所以，如果向 channel 发送数据的一方不知道 channel 是否处于关闭状态时就去贸然向 channel 发送数据是很危险的事情。</li></ol><p>文中还真的就给出了一个检查 channel 是否关闭的函数：</p><pre class=" language-golang"><code class="language-golang">func IsClosed(ch <-chan T) bool {    select {    case <-ch:        return true    default:    }    return false}func main() {    c := make(chan T)    fmt.Println(IsClosed(c)) // false    close(c)    fmt.Println(IsClosed(c)) // true}</code></pre><p>看一下代码，其实存在很多问题。首先，IsClosed 函数是一个有副作用的函数。每调用一次，都会读出 channel 里的一个元素，改变了 channel 的状态。这不是一个好的函数，干活就干活，还顺手牵羊！</p><p>其次，IsClosed 函数返回的结果仅代表调用那个瞬间，并不能保证调用之后会不会有其他 goroutine 对它进行了一些操作，改变了它的这种状态。例如，IsClosed 函数返回 true，但这时有另一个 goroutine 关闭了 channel，而你还拿着这个过时的 “channel 未关闭”的信息，向其发送数据，就会导致 panic 的发生。当然，一个 channel 不会被重复关闭两次，如果 IsClosed 函数返回的结果是 true，说明 channel 是真的关闭了。</p><p>有一条广泛流传的关闭 channel 的原则：</p><blockquote><p>don’t close a channel from the receiver side and don’t close a channel if the channel has multiple concurrent senders.</p></blockquote><p>不要从一个 receiver 侧关闭 channel，也不要在有多个 sender 时，关闭 channel。</p><p>比较好理解，向 channel 发送元素的就是 sender，因此 sender 可以决定何时不发送数据，并且关闭 channel。但是如果有多个 sender，某个 sender 同样没法确定其他 sender 的情况，这时也不能贸然关闭 channel。</p><p>但是上面所说的并不是最本质的，最本质的原则就只有一条：</p><blockquote><p>don’t close (or send values to) closed channels.</p></blockquote><p>有两个不那么优雅地关闭 channel 的方法：</p><ol><li><p>使用 defer-recover 机制，放心大胆地关闭 channel 或者向 channel 发送数据。即使发生了 panic，有 defer-recover 在兜底。</p></li><li><p>使用 sync.Once 来保证只关闭一次。</p></li></ol><p>代码我就不贴上来了，直接去看原文。</p><p>这一节的重头戏来了，那应该如何优雅地关闭 channel？</p><p>根据 sender 和 receiver 的个数，分下面几种情况：</p><ol><li>一个 sender，一个 receiver</li><li>一个 sender， M 个 receiver</li><li>N 个 sender，一个 reciver</li><li>N 个 sender， M 个 receiver</li></ol><p>对于 1，2，只有一个 sender 的情况就不用说了，直接从 sender 端关闭就好了，没有问题。重点关注第 3，4 种情况。</p><p>第 3 种情形下，优雅关闭 channel 的方法是：the only receiver says “please stop sending more” by closing an additional signal channel。</p><p>解决方案就是增加一个传递关闭信号的 channel，receiver 通过信号 channel 下达关闭数据 channel 指令。senders 监听到关闭信号后，停止发送数据。我把代码修改地更简洁了：</p><pre class=" language-golang"><code class="language-golang">func main() {    rand.Seed(time.Now().UnixNano())    const Max = 100000    const NumSenders = 1000    dataCh := make(chan int, 100)    stopCh := make(chan struct{})    // senders    for i := 0; i < NumSenders; i++ {        go func() {            for {                select {                case <- stopCh:                    return                case dataCh <- rand.Intn(Max):                }            }        }()    }    // the receiver    go func() {        for value := range dataCh {            if value == Max-1 {                fmt.Println("send stop signal to senders.")                close(stopCh)                return            }            fmt.Println(value)        }    }()    select {    case <- time.After(time.Hour):    }}</code></pre><p>这里的 stopCh 就是信号 channel，它本身只有一个 sender，因此可以直接关闭它。senders 收到了关闭信号后，select 分支 “case &lt;- stopCh” 被选中，退出函数，不再发送数据。</p><p>需要说明的是，上面的代码并没有明确关闭 dataCh。在 Go 语言中，对于一个 channel，如果最终没有任何 goroutine 引用它，不管 channel 有没有被关闭，最终都会被 gc 回收。所以，在这种情形下，所谓的优雅地关闭 channel 就是不关闭 channel，让 gc 代劳。</p><p>最后一种情况，优雅关闭 channel 的方法是：any one of them says “let’s end the game” by notifying a moderator to close an additional signal channel。</p><p>和第 3 种情况不同，这里有 M 个 receiver，如果直接还是采取第 3 种解决方案，由 receiver 直接关闭 stopCh 的话，就会重复关闭一个 channel，导致 panic。因此需要增加一个中间人，M 个 receiver 都向它发送关闭 dataCh 的“请求”，中间人收到第一个请求后，就会直接下达关闭 dataCh 的指令（通过关闭 stopCh，这时就不会发生重复关闭的情况，因为 stopCh 的发送方只有中间人一个）。另外，这里的 N 个 sender 也可以向中间人发送关闭 dataCh 的请求。</p><pre class=" language-golang"><code class="language-golang">func main() {    rand.Seed(time.Now().UnixNano())    const Max = 100000    const NumReceivers = 10    const NumSenders = 1000    dataCh := make(chan int, 100)    stopCh := make(chan struct{})    // It must be a buffered channel.    toStop := make(chan string, 1)    var stoppedBy string    // moderator    go func() {        stoppedBy = <-toStop        close(stopCh)    }()    // senders    for i := 0; i < NumSenders; i++ {        go func(id string) {            for {                value := rand.Intn(Max)                if value == 0 {                    select {                    case toStop <- "sender#" + id:                    default:                    }                    return                }                select {                case <- stopCh:                    return                case dataCh <- value:                }            }        }(strconv.Itoa(i))    }    // receivers    for i := 0; i < NumReceivers; i++ {        go func(id string) {            for {                select {                case <- stopCh:                    return                case value := <-dataCh:                    if value == Max-1 {                        select {                        case toStop <- "receiver#" + id:                        default:                        }                        return                    }                    fmt.Println(value)                }            }        }(strconv.Itoa(i))    }    select {    case <- time.After(time.Hour):    }}</code></pre><p>代码里 toStop 就是中间人的角色，使用它来接收 senders 和 receivers 发送过来的关闭 dataCh 请求。</p><p>这里将 toStop 声明成了一个 缓冲型的 channel。假设 toStop 声明的是一个非缓冲型的 channel，那么第一个发送的关闭 dataCh 请求可能会丢失。因为无论是 sender 还是 receiver 都是通过 select 语句来发送请求，如果中间人所在的 goroutine 没有准备好，那 select 语句就不会选中，直接走 default 选项，什么也不做。这样，第一个关闭 dataCh 的请求就会丢失。</p><p>如果，我们把 toStop 的容量声明成 Num(senders) + Num(receivers)，那发送 dataCh 请求的部分可以改成更简洁的形式：</p><pre class=" language-golang"><code class="language-golang">...toStop := make(chan string, NumReceivers + NumSenders)...            value := rand.Intn(Max)            if value == 0 {                toStop <- "sender#" + id                return            }...                if value == Max-1 {                    toStop <- "receiver#" + id                    return                }...</code></pre><p>直接向 toStop 发送请求，因为 toStop 容量足够大，所以不用担心阻塞，自然也就不用 select 语句再加一个 default case 来避免阻塞。</p><p>可以看到，这里同样没有真正关闭 dataCh，原样同第 3 种情况。</p><p>以上，就是最基本的一些情形，但已经能覆盖几乎所有的情况及其变种了。只要记住：</p><blockquote><p>don’t close a channel from the receiver side and don’t close a channel if the channel has multiple concurrent senders.</p></blockquote><p>以及更本质的原则：</p><blockquote><p>don’t close (or send values to) closed channels.</p></blockquote><h2 id="关闭的-channel-仍能读出数据"><a href="#关闭的-channel-仍能读出数据" class="headerlink" title="关闭的 channel 仍能读出数据"></a>关闭的 channel 仍能读出数据</h2><p>从一个有缓冲的 channel 里读数据，当 channel 被关闭，依然能读出有效值。只有当返回的 ok 为 false 时，读出的数据才是无效的。</p><pre class=" language-golang"><code class="language-golang">func main() {    ch := make(chan int, 5)    ch <- 18    close(ch)    x, ok := <-ch    if ok {        fmt.Println("received: ", x)    }    x, ok = <-ch    if !ok {        fmt.Println("channel closed, data invalid.")    }}</code></pre><p>运行结果：</p><pre class=" language-golang"><code class="language-golang">received:  18channel closed, data invalid.</code></pre><p>先创建了一个有缓冲的 channel，向其发送一个元素，然后关闭此 channel。之后两次尝试从 channel 中读取数据，第一次仍然能正常读出值。第二次返回的 ok 为 false，说明 channel 已关闭，且通道里没有数据。</p><h1 id="channel-应用"><a href="#channel-应用" class="headerlink" title="channel 应用"></a>channel 应用</h1><p>Channel 和 goroutine 的结合是 Go 并发编程的大杀器。而 Channel 的实际应用也经常让人眼前一亮，通过与 select，cancel，timer 等结合，它能实现各种各样的功能。接下来，我们就要梳理一下 channel 的应用。</p><h2 id="停止信号"><a href="#停止信号" class="headerlink" title="停止信号"></a>停止信号</h2><p>前面一节如何优雅关闭 channel 那一节已经讲得很多了，这块就略过了。</p><p>channel 用于停止信号的场景还是挺多的，经常是关闭某个 channel 或者向 channel 发送一个元素，使得接收 channel 的那一方获知道此信息，进而做一些其他的操作。</p><h2 id="任务定时"><a href="#任务定时" class="headerlink" title="任务定时"></a>任务定时</h2><p>与 timer 结合，一般有两种玩法：实现超时控制，实现定期执行某个任务。</p><p>有时候，需要执行某项操作，但又不想它耗费太长时间，上一个定时器就可以搞定：</p><pre class=" language-golang"><code class="language-golang">select {    case <-time.After(100 * time.Millisecond):    case <-s.stopc:        return false}</code></pre><p>等待 100 ms 后，如果 s.stopc 还没有读出数据或者被关闭，就直接结束。这是来自 etcd 源码里的一个例子，这样的写法随处可见。</p><p>定时执行某个任务，也比较简单：</p><pre class=" language-golang"><code class="language-golang">func worker() {    ticker := time.Tick(1 * time.Second)    for {        select {        case <- ticker:            // 执行定时任务            fmt.Println("执行 1s 定时任务")        }    }}</code></pre><p>每隔 1 秒种，执行一次定时任务。</p><h2 id="解耦生产方和消费方"><a href="#解耦生产方和消费方" class="headerlink" title="解耦生产方和消费方"></a>解耦生产方和消费方</h2><p>服务启动时，启动 n 个 worker，作为工作协程池，这些协程工作在一个 <code>for {}</code> 无限循环里，从某个 channel 消费工作任务并执行：</p><pre class=" language-golang"><code class="language-golang">func main() {    taskCh := make(chan int, 100)    go worker(taskCh)    // 塞任务    for i := 0; i < 10; i++ {        taskCh <- i    }    // 等待 1 小时     select {    case <-time.After(time.Hour):    }}func worker(taskCh <-chan int) {    const N = 5    // 启动 5 个工作协程    for i := 0; i < N; i++ {        go func(id int) {            for {                task := <- taskCh                fmt.Printf("finish task: %d by worker %d\n", task, id)                time.Sleep(time.Second)            }        }(i)    }}</code></pre><p>5 个工作协程在不断地从工作队列里取任务，生产方只管往 channel 发送任务即可，解耦生产方和消费方。</p><p>程序输出：</p><pre class=" language-shell"><code class="language-shell">finish task: 1 by worker 4finish task: 2 by worker 2finish task: 4 by worker 3finish task: 3 by worker 1finish task: 0 by worker 0finish task: 6 by worker 0finish task: 8 by worker 3finish task: 9 by worker 1finish task: 7 by worker 4finish task: 5 by worker 2</code></pre><h2 id="控制并发数"><a href="#控制并发数" class="headerlink" title="控制并发数"></a>控制并发数</h2><p>有时需要定时执行几百个任务，例如每天定时按城市来执行一些离线计算的任务。但是并发数又不能太高，因为任务执行过程依赖第三方的一些资源，对请求的速率有限制。这时就可以通过 channel 来控制并发数。</p><p>下面的例子来自《Go 语言高级编程》：</p><pre class=" language-golang"><code class="language-golang">var limit = make(chan int, 3)func main() {    // …………    for _, w := range work {        go func() {            limit <- 1            w()            <-limit        }()    }    // …………}</code></pre><p>构建一个缓冲型的 channel，容量为 3。接着遍历任务列表，每个任务启动一个 goroutine 去完成。真正执行任务，访问第三方的动作在 w() 中完成，在执行 w() 之前，先要从 limit 中拿“许可证”，拿到许可证之后，才能执行 w()，并且在执行完任务，要将“许可证”归还。这样就可以控制同时运行的 goroutine 数。</p><p>这里，<code>limit &lt;- 1</code> 放在 func 内部而不是外部，书籍作者柴大在读者群里的解释是：</p><blockquote><p>如果在外层，就是控制系统 goroutine 的数量，可能会阻塞 for 循环，影响业务逻辑。</p></blockquote><blockquote><p>limit 其实和逻辑无关，只是性能调优，放在内层和外层的语义不太一样。</p></blockquote><p>还有一点要注意的是，如果 w() 发生 panic，那“许可证”可能就还不回去了，因此需要使用 defer 来保证。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>终于写完了，你也终于看完了，恭喜！</p><p>回顾一下，这篇文章先从并发和并行讲起，又讲到了 CSP，Go 语言用 channel 实现 CSP。接着讲了什么是 channel，为什么需要 channel，然后详细分析了 channel 的实现原理，这也是全文最重要的部分。之后，又讲了几个进阶的例子，最后，列举了几个 channel 应用的场景。</p><p>希望大家能借助本文去读一下 Go 源码，这部分源码也不长，和 context 包一样，短小精悍，值得一读。</p><p>我在参考资料里列举了很多文章、书籍，很多都值得去细看，我在文中也有提及。</p><p>当你理解这 channel 的底层原理后，再去看这些英文文章，会觉得很有意思。以前对他有一种“畏难”心理，理解了之后再读，就会觉得很有意思，因为你确实都能看懂。</p><p>最后，阅读愉快！</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【Concurrency In Go】<a href="https://github.com/arpitjindal97/technology_books/blob/master/Golang/Concurrency-in-Go:Tools-and-Techniques-for-Developers.pdf">https://github.com/arpitjindal97/technology_books/blob/master/Golang/Concurrency-in-Go:Tools-and-Techniques-for-Developers.pdf</a></p><p>【Go 语言高级编程开源书】<a href="https://chai2010.cn/advanced-go-programming-book/ch1-basic/ch1-05-mem.html" target="_blank" rel="noopener">https://chai2010.cn/advanced-go-programming-book/ch1-basic/ch1-05-mem.html</a></p><p>【简洁清晰明了】<a href="http://litang.me/post/golang-channel/" target="_blank" rel="noopener">http://litang.me/post/golang-channel/</a></p><p>【柴大 &amp;&amp; 曹大 《Go语言高级编程》】<a href="https://chai2010.cn/advanced-go-programming-book/ch1-basic/ch1-05-mem.html" target="_blank" rel="noopener">https://chai2010.cn/advanced-go-programming-book/ch1-basic/ch1-05-mem.html</a></p><p>【Go 并发编程实战】<a href="https://book.douban.com/subject/26244729/" target="_blank" rel="noopener">https://book.douban.com/subject/26244729/</a></p><p>【曹大 golang notes】<a href="https://github.com/cch123/golang-notes/blob/master/channel.md">https://github.com/cch123/golang-notes/blob/master/channel.md</a></p><p>【互联网技术窝 图解 channel 实现 动画】<a href="https://mp.weixin.qq.com/s/40uxAPdubIk0lU321LmfRg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/40uxAPdubIk0lU321LmfRg</a></p><p>【一起学 Golang，推荐的资料非常有用】<a href="https://segmentfault.com/a/1190000018385779" target="_blank" rel="noopener">https://segmentfault.com/a/1190000018385779</a></p><p>【如何优雅地关闭 channel】<a href="https://go101.org/article/channel-closing.html" target="_blank" rel="noopener">https://go101.org/article/channel-closing.html</a></p><p>【深入 channel 底层】<a href="https://codeburst.io/diving-deep-into-the-golang-channels-549fd4ed21a8" target="_blank" rel="noopener">https://codeburst.io/diving-deep-into-the-golang-channels-549fd4ed21a8</a></p><p>【Kavya在Gopher Con 上关于 channel 的设计，非常好】<a href="https://speakerd.s3.amazonaws.com/presentations/10ac0b1d76a6463aa98ad6a9dec917a7/GopherCon_v10.0.pdf" target="_blank" rel="noopener">https://speakerd.s3.amazonaws.com/presentations/10ac0b1d76a6463aa98ad6a9dec917a7/GopherCon_v10.0.pdf</a></p><p>【channel 应用】<a href="https://www.s0nnet.com/archives/go-channels-practice" target="_blank" rel="noopener">https://www.s0nnet.com/archives/go-channels-practice</a></p><p>【应用举例】<a href="https://zhuyasen.com/post/go_queue.html" target="_blank" rel="noopener">https://zhuyasen.com/post/go_queue.html</a></p><p>【应用】<a href="https://tonybai.com/2014/09/29/a-channel-compendium-for-golang/" target="_blank" rel="noopener">https://tonybai.com/2014/09/29/a-channel-compendium-for-golang/</a></p><p>【鸟窝 并发编程分享】<a href="https://colobu.com/2019/04/28/gopher-2019-concurrent-in-action/" target="_blank" rel="noopener">https://colobu.com/2019/04/28/gopher-2019-concurrent-in-action/</a></p><p>【Go-Questions，码农桃花源项目】<a href="https://github.com/qcrao/Go-Questions">https://github.com/qcrao/Go-Questions</a></p><p>【GitBook 码农桃花源开源书】<a href="https://qcrao91.gitbook.io/go/" target="_blank" rel="noopener">https://qcrao91.gitbook.io/go/</a></p><p><img src="https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png" alt="QR"></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dive-into-three-way-handshake</title>
      <link href="/2019/07/24/dive-into-three-way-handshake/"/>
      <url>/2019/07/24/dive-into-three-way-handshake/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>dive-into-http</title>
      <link href="/2019/07/24/dive-into-http/"/>
      <url>/2019/07/24/dive-into-http/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>dive-into-go-defer</title>
      <link href="/2019/07/24/how-to-keep-off-trap-of-defer/"/>
      <url>/2019/07/24/how-to-keep-off-trap-of-defer/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>dive-into-go-interface</title>
      <link href="/2019/07/24/dive-into-go-interface/"/>
      <url>/2019/07/24/dive-into-go-interface/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>dive-into-go-unsafe</title>
      <link href="/2019/07/24/dive-into-go-unsafe/"/>
      <url>/2019/07/24/dive-into-go-unsafe/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>dive-into-go-reflection</title>
      <link href="/2019/07/24/dive-into-go-reflection/"/>
      <url>/2019/07/24/dive-into-go-reflection/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>graphic-go-memory-allocation</title>
      <link href="/2019/07/24/graphic-go-memory-allocation/"/>
      <url>/2019/07/24/graphic-go-memory-allocation/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>where-go-variable-go</title>
      <link href="/2019/07/24/where-go-variables-go/"/>
      <url>/2019/07/24/where-go-variables-go/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Go 程序是怎样跑起来的</title>
      <link href="/2019/07/24/how-go-runs/"/>
      <url>/2019/07/24/how-go-runs/</url>
      
        <content type="html"><![CDATA[<p>刚开始写这篇文章的时候，目标非常大，想要探索 Go 程序的一生：编码、编译、汇编、链接、运行、退出。它的每一步具体如何进行，力图弄清 Go 程序的这一生。</p><p>在这个过程中，我又复习了一遍《程序员的自我修养》。这是一本讲编译、链接的书，非常详细，值得一看！数年前，我第一次看到这本书的书名，就非常喜欢。因为它模仿了周星驰喜剧之王里出现的一本书 ——《演员的自我修养》。心向往之！</p><p>在开始本文之前，先推荐一位头条大佬的博客——《面向信仰编程》，他的 Go 编译系列文章，非常有深度，直接深入编译器源代码，我是看了很多遍了。博客链接可以从参考资料里获取。</p><p>理想很大，实现的难度也是非常大。为了避免砸了“深度解密”这个牌子，这次起了个更温和的名字，嘿嘿。</p><h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>我们从一个 <code>Hello World</code> 的例子开始：</p><pre class=" language-golang"><code class="language-golang">package mainimport "fmt"func main() {    fmt.Println("hello world")}</code></pre><p>当我用我那价值 1800 元的 cherry 键盘潇洒地敲完上面的 hello world 代码时，保存在硬盘上的 <code>hello.go</code> 文件就是一个字节序列了，每个字节代表一个字符。</p><p>用 vim 打开 hello.go 文件，在命令行模式下，输入命令：</p><pre class=" language-shell"><code class="language-shell">:%!xxd</code></pre><p>就能在 vim 里以十六进制查看文件内容：</p><p><img src="https://user-images.githubusercontent.com/7698088/59696461-9d76e600-921e-11e9-9253-533d55e2c8f5.png" alt="hex .go"></p><p>最左边的一列代表地址值，中间一列代表文本对应的 ASCII 字符，最右边的列就是我们的代码。再在终端里执行 <code>man ascii</code>：</p><p><img src="https://user-images.githubusercontent.com/7698088/59696702-15dda700-921f-11e9-838f-897a5d3f21fb.png" alt="ASCII"></p><p>和 ASCII 字符表一对比，就能发现，中间的列和最右边的列是一一对应的。也就是说，刚刚写完的 hello.go 文件都是由 ASCII 字符表示的，它被称为<code>文本文件</code>，其他文件被称为<code>二进制文件</code>。</p><p>当然，更深入地看，计算机中的所有数据，像磁盘文件、网络中的数据其实都是一串比特位组成，取决于如何看待它。在不同的情景下，一个相同的字节序列可能表示成一个整数、浮点数、字符串或者是机器指令。</p><p>而像 hello.go 这个文件，8 个 bit，也就是一个字节看成一个单位（假定源程序的字符都是 ASCII 码），最终解释成人类能读懂的 Go 源码。</p><p>Go 程序并不能直接运行，每条 Go 语句必须转化为一系列的低级机器语言指令，将这些指令打包到一起，并以二进制磁盘文件的形式存储起来，也就是可执行目标文件。</p><p>从源文件到可执行目标文件的转化过程：</p><p><img src="https://user-images.githubusercontent.com/7698088/60523966-44c74300-9d1e-11e9-9ba9-d1f594607edc.png" alt="compile"></p><p>完成以上各个阶段的就是 Go 编译系统。你肯定知道大名鼎鼎的 GCC（GNU Compile Collection），中文名为 GNU 编译器套装，它支持像 C，C++，Java，Python，Objective-C，Ada，Fortran，Pascal，能够为很多不同的机器生成机器码。</p><p>可执行目标文件可以直接在机器上执行。一般而言，先执行一些初始化的工作；找到 main 函数的入口，执行用户写的代码；执行完成后，main 函数退出；再执行一些收尾的工作，整个过程完毕。</p><p>在接下来的文章里，我们将探索<code>编译</code>和<code>运行</code>的过程。</p><h1 id="编译链接概述"><a href="#编译链接概述" class="headerlink" title="编译链接概述"></a>编译链接概述</h1><p>Go 源码里的编译器源码位于 <code>src/cmd/compile</code> 路径下，链接器源码位于 <code>src/cmd/link</code> 路径下。</p><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>我比较喜欢用 IDE（集成开发环境）来写代码， Go 源码用的 Goland，有时候直接点击 IDE 菜单栏里的“运行”按钮，程序就跑起来了。这实际上隐含了编译和链接的过程，我们通常将编译和链接合并到一起的过程称为构建（Build）。</p><p>编译过程就是对源文件进行词法分析、语法分析、语义分析、优化，最后生成汇编代码文件，以 <code>.s</code> 作为文件后缀。</p><p>之后，汇编器会将汇编代码转变成机器可以执行的指令。由于每一条汇编语句几乎都与一条机器指令相对应，所以只是一个简单的一一对应，比较简单，没有语法、语义分析，也没有优化这些步骤。</p><p>编译器是将高级语言翻译成机器语言的一个工具，编译过程一般分为 6 步：扫描、语法分析、语义分析、源代码优化、代码生成、目标代码优化。下图来自《程序员的自我修养》：</p><p><img src="https://user-images.githubusercontent.com/7698088/59910602-d4c6dc00-9444-11e9-8155-fbe59eec4e89.png" alt="编译过程总览"></p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>通过前面的例子，我们知道，Go 程序文件在机器看来不过是一堆二进制位。我们能读懂，是因为 Goland 按照 ASCII 码（实际上是 UTF-8）把这堆二进制位进行了编码。例如，把 8个 bit 位分成一组，对应一个字符，通过对照 ASCII 码表就可以查出来。</p><p>当把所有的二进制位都对应成了 ASCII 码字符后，我们就能看到有意义的字符串。它可能是关键字，例如：package；可能是字符串，例如：“Hello World”。</p><p>词法分析其实干的就是这个。输入是原始的 Go 程序文件，在词法分析器看来，就是一堆二进制位，根本不知道是什么东西，经过它的分析后，变成有意义的记号。简单来说，词法分析是计算机科学中将字符序列转换为标记（token）序列的过程。</p><p>我们来看一下维基百科上给出的定义：</p><blockquote><p>词法分析（lexical analysis）是计算机科学中将字符序列转换为标记（token）序列的过程。进行词法分析的程序或者函数叫作词法分析器（lexical analyzer，简称lexer），也叫扫描器（scanner）。词法分析器一般以函数的形式存在，供语法分析器调用。</p></blockquote><p><code>.go</code> 文件被输入到扫描器（Scanner），它使用一种类似于<code>有限状态机</code>的算法，将源代码的字符系列分割成一系列的记号（Token）。</p><p>记号一般分为这几类：关键字、标识符、字面量（包含数字、字符串）、特殊符号（如加号、等号）。</p><p>例如，对于如下的代码：</p><pre class=" language-golang"><code class="language-golang">slice[i] = i * (2 + 6)</code></pre><p>总共包含 16 个非空字符，经过扫描后，</p><table><thead><tr><th>记号</th><th>类型</th></tr></thead><tbody><tr><td>slice</td><td>标识符</td></tr><tr><td>[</td><td>左方括号</td></tr><tr><td>i</td><td>标识符</td></tr><tr><td>]</td><td>右方括号</td></tr><tr><td>=</td><td>赋值</td></tr><tr><td>i</td><td>标识符</td></tr><tr><td>*</td><td>乘号</td></tr><tr><td>(</td><td>左圆括号</td></tr><tr><td>2</td><td>数字</td></tr><tr><td>+</td><td>加号</td></tr><tr><td>6</td><td>数字</td></tr><tr><td>)</td><td>右圆括号</td></tr></tbody></table><p>上面的例子源自《程序员的自我修养》，主要讲解编译、链接相关的内容，很精彩，推荐研读。</p><p>Go 语言（本文的 Go 版本是 1.9.2）扫描器支持的 Token 在源码中的路径：</p><pre class=" language-shell"><code class="language-shell">src/cmd/compile/internal/syntax/token.go</code></pre><p>感受一下：</p><pre class=" language-golang"><code class="language-golang">var tokstrings = [...]string{    // source control    _EOF: "EOF",    // names and literals    _Name:    "name",    _Literal: "literal",    // operators and operations    _Operator: "op",    _AssignOp: "op=",    _IncOp:    "opop",    _Assign:   "=",    _Define:   ":=",    _Arrow:    "<-",    _Star:     "*",    // delimitors    _Lparen:    "(",    _Lbrack:    "[",    _Lbrace:    "{",    _Rparen:    ")",    _Rbrack:    "]",    _Rbrace:    "}",    _Comma:     ",",    _Semi:      ";",    _Colon:     ":",    _Dot:       ".",    _DotDotDot: "...",    // keywords    _Break:       "break",    _Case:        "case",    _Chan:        "chan",    _Const:       "const",    _Continue:    "continue",    _Default:     "default",    _Defer:       "defer",    _Else:        "else",    _Fallthrough: "fallthrough",    _For:         "for",    _Func:        "func",    _Go:          "go",    _Goto:        "goto",    _If:          "if",    _Import:      "import",    _Interface:   "interface",    _Map:         "map",    _Package:     "package",    _Range:       "range",    _Return:      "return",    _Select:      "select",    _Struct:      "struct",    _Switch:      "switch",    _Type:        "type",    _Var:         "var",}</code></pre><p>还是比较熟悉的，包括名称和字面量、操作符、分隔符和关键字。</p><p>而扫描器的路径是：</p><pre class=" language-shell"><code class="language-shell">src/cmd/compile/internal/syntax/scanner.go</code></pre><p>其中最关键的函数就是 next 函数，它不断地读取下一个字符（不是下一个字节，因为 Go 语言支持 Unicode 编码，并不是像我们前面举得 ASCII 码的例子，一个字符只有一个字节），直到这些字符可以构成一个 Token。</p><pre class=" language-golang"><code class="language-golang">func (s *scanner) next() {// ……redo:    // skip white space    c := s.getr()    for c == ' ' || c == '\t' || c == '\n' && !nlsemi || c == '\r' {        c = s.getr()    }    // token start    s.line, s.col = s.source.line0, s.source.col0    if isLetter(c) || c >= utf8.RuneSelf && s.isIdentRune(c, true) {        s.ident()        return    }    switch c {    // ……    case '\n':        s.lit = "newline"        s.tok = _Semi    case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':        s.number(c)    // ……   default:        s.tok = 0        s.error(fmt.Sprintf("invalid character %#U", c))        goto redo    returnassignop:    if c == '=' {        s.tok = _AssignOp        return    }    s.ungetr()    s.tok = _Operator}</code></pre><p>代码的主要逻辑就是通过 <code>c := s.getr()</code>  获取下一个未被解析的字符，并且会跳过之后的空格、回车、换行、tab 字符，然后进入一个大的 <code>switch-case</code> 语句，匹配各种不同的情形，最终可以解析出一个 Token，并且把相关的行、列数字记录下来，这样就完成一次解析过程。</p><blockquote><p>当前包中的词法分析器 scanner 也只是为上层提供了 next 方法，词法解析的过程都是惰性的，只有在上层的解析器需要时才会调用 next 获取最新的 Token。</p></blockquote><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>上一步生成的 Token 序列，需要经过进一步处理，生成一棵以<code>表达式</code>为结点的<code>语法树</code>。</p><p>比如最开始的那个例子，<code>slice[i] = i * (2 + 6)</code>，得到的一棵语法树如下：</p><p><img src="https://user-images.githubusercontent.com/7698088/59962830-3490b600-951d-11e9-8ae6-53d6375f0246.png" alt="语法树"></p><p>整个语句被看作是一个赋值表达式，左子树是一个数组表达式，右子树是一个乘法表达式；数组表达式由 2 个符号表达式组成；乘号表达式则是由一个符号表达式和一个加号表达式组成；加号表达式则是由两个数字组成。符号和数字是最小的表达式，它们不能再被分解，通常作为树的叶子节点。</p><p>语法分析的过程可以检测一些形式上的错误，例如：括号是否缺少一半，<code>+</code> 号表达式缺少一个操作数等。</p><blockquote><p>语法分析是根据某种特定的形式文法（Grammar）对 Token 序列构成的输入文本进行分析并确定其语法结构的一种过程。</p></blockquote><h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>语法分析完成后，我们并不知道语句的具体意义是什么。像上面的 <code>*</code> 号的两棵子树如果是两个指针，这是不合法的，但语法分析检测不出来，语义分析就是干这个事。</p><p>编译期所能检查的是静态语义，可以认为这是在“代码”阶段，包括变量类型的匹配、转换等。例如，将一个浮点值赋给一个指针变量的时候，明显的类型不匹配，就会报编译错误。而对于运行期间才会出现的错误：不小心除了一个 0 ，语义分析是没办法检测的。</p><p>语义分析阶段完成之后，会在每个节点上标注上类型：</p><p><img src="https://user-images.githubusercontent.com/7698088/59962838-512cee00-951d-11e9-8581-18e12ffde230.png" alt="语义分析完成"></p><p>Go 语言编译器在这一阶段检查常量、类型、函数声明以及变量赋值语句的类型，然后检查哈希中键的类型。实现类型检查的函数通常都是几千行的巨型 switch/case 语句。</p><blockquote><p>类型检查是 Go 语言编译的第二个阶段，在词法和语法分析之后我们得到了每个文件对应的抽象语法树，随后的类型检查会遍历抽象语法树中的节点，对每个节点的类型进行检验，找出其中存在的语法错误。</p></blockquote><blockquote><p>在这个过程中也可能会对抽象语法树进行改写，这不仅能够去除一些不会被执行的代码对编译进行优化提高执行效率，而且也会修改 make、new 等关键字对应节点的操作类型。</p></blockquote><p>例如比较常用的 make 关键字，用它可以创建各种类型，如 slice，map，channel 等等。到这一步的时候，对于 make 关键字，也就是 OMAKE 节点，会先检查它的参数类型，根据类型的不同，进入相应的分支。如果参数类型是 slice，就会进入 TSLICE case 分支，检查 len 和 cap 是否满足要求，如 len &lt;= cap。最后节点类型会从 OMAKE 改成 OMAKESLICE。</p><h3 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h3><p>我们知道，编译过程一般可以分为前端和后端，前端生成和平台无关的中间代码，后端会针对不同的平台，生成不同的机器码。</p><p>前面词法分析、语法分析、语义分析等都属于编译器前端，之后的阶段属于编译器后端。</p><p>编译过程有很多优化的环节，在这个环节是指源代码级别的优化。它将语法树转换成中间代码，它是语法树的顺序表示。</p><p>中间代码一般和目标机器以及运行时环境无关，它有几种常见的形式：三地址码、P-代码。例如，最基本的<code>三地址码</code>是这样的：</p><pre class=" language-shell"><code class="language-shell">x = y op z</code></pre><p>表示变量 y 和 变量 z 进行 op 操作后，赋值给 x。op 可以是数学运算，例如加减乘除。</p><p>前面我们举的例子可以写成如下的形式：</p><pre class=" language-shell"><code class="language-shell">t1 = 2 + 6t2 = i * t1slice[i] = t2</code></pre><p>这里 2 + 6 是可以直接计算出来的，这样就把 t1 这个临时变量“优化”掉了，而且 t1 变量可以重复利用，因此 t2 也可以“优化”掉。优化之后：</p><pre class=" language-shell"><code class="language-shell">t1 = i * 8slice[i] = t1</code></pre><p>Go 语言的中间代码表示形式为 SSA（Static Single-Assignment，静态单赋值），之所以称之为单赋值，是因为每个名字在 SSA 中仅被赋值一次。。</p><p>这一阶段会根据 CPU 的架构设置相应的用于生成中间代码的变量，例如编译器使用的指针和寄存器的大小、可用寄存器列表等。中间代码生成和机器码生成这两部分会共享相同的设置。</p><p>在生成中间代码之前，会对抽象语法树中节点的一些元素进行替换。这里引用《面向信仰编程》编译原理相关博客里的一张图：</p><p><img src="https://user-images.githubusercontent.com/7698088/60553849-a364df00-9d67-11e9-832a-450f4d8ee6ba.png" alt="builtin mapping"></p><p>例如对于 map 的操作 m[i]，在这里会被转换成 mapacess 或 mapassign。</p><blockquote><p>Go 语言的主程序在执行时会调用 runtime 中的函数，也就是说关键字和内置函数的功能其实是由语言的编译器和运行时共同完成的。</p></blockquote><blockquote><p>中间代码的生成过程其实就是从 AST 抽象语法树到 SSA 中间代码的转换过程，在这期间会对语法树中的关键字在进行一次更新，更新后的语法树会经过多轮处理转变最后的 SSA 中间代码。</p></blockquote><h3 id="目标代码生成与优化"><a href="#目标代码生成与优化" class="headerlink" title="目标代码生成与优化"></a>目标代码生成与优化</h3><p>不同机器的机器字长、寄存器等等都不一样，意味着在不同机器上跑的机器码是不一样的。最后一步的目的就是要生成能在不同 CPU 架构上运行的代码。</p><p>为了榨干机器的每一滴油水，目标代码优化器会对一些指令进行优化，例如使用移位指令代替乘法指令等。</p><p>这块实在没能力深入，幸好也不需要深入。对于应用层的软件开发工程师来说，了解一下就可以了。</p><h2 id="链接过程"><a href="#链接过程" class="headerlink" title="链接过程"></a>链接过程</h2><p>编译过程是针对单个文件进行的，文件与文件之间不可避免地要引用定义在其他模块的全局变量或者函数，这些变量或函数的地址只有在此阶段才能确定。</p><p>链接过程就是要把编译器生成的一个个目标文件链接成可执行文件。最终得到的文件是分成各种段的，比如数据段、代码段、BSS段等等，运行时会被装载到内存中。各个段具有不同的读写、执行属性，保护了程序的安全运行。</p><p>这部分内容，推荐看《程序员的自我修养》和《深入理解计算机系统》。</p><h1 id="Go-程序启动"><a href="#Go-程序启动" class="headerlink" title="Go 程序启动"></a>Go 程序启动</h1><p>仍然使用 hello-world 项目的例子。在项目根目录下执行：</p><pre class=" language-shell"><code class="language-shell">go build -gcflags "-N -l" -o hello src/main.go</code></pre><p><code>-gcflags &quot;-N -l&quot;</code> 是为了关闭编译器优化和函数内联，防止后面在设置断点的时候找不到相对应的代码位置。</p><p>得到了可执行文件 hello，执行：</p><pre class=" language-shell"><code class="language-shell">[qcrao@qcrao hello-world]$ gdb hello</code></pre><p>进入 gdb 调试模式，执行 <code>info files</code>，得到可执行文件的文件头，列出了各种段：</p><p><img src="https://user-images.githubusercontent.com/7698088/60392813-db88d980-9b3d-11e9-8b0f-7c1d845a8191.png" alt="gdb info"></p><p>同时，我们也得到了入口地址：0x450e20。</p><pre class=" language-shell"><code class="language-shell">(gdb) b *0x450e20Breakpoint 1 at 0x450e20: file /usr/local/go/src/runtime/rt0_linux_amd64.s, line 8.</code></pre><p>这就是 Go 程序的入口地址，我是在 linux 上运行的，所以入口文件为 <code>src/runtime/rt0_linux_amd64.s</code>，runtime 目录下有各种不同名称的程序入口文件，支持各种操作系统和架构，代码为：</p><pre class=" language-asm"><code class="language-asm">TEXT _rt0_amd64_linux(SB),NOSPLIT,$-8    LEAQ    8(SP), SI // argv    MOVQ    0(SP), DI // argc    MOVQ    $main(SB), AX    JMP    AX</code></pre><p>主要是把 argc，argv 从内存拉到了寄存器。这里 LEAQ 是计算内存地址，然后把内存地址本身放进寄存器里，也就是把 argv 的地址放到了 SI 寄存器中。最后跳转到：</p><pre class=" language-golang"><code class="language-golang">TEXT main(SB),NOSPLIT,$-8    MOVQ    $runtime·rt0_go(SB), AX    JMP    AX</code></pre><p>继续跳转到 <code>runtime·rt0_go(SB)</code>，位置：<code>/usr/local/go/src/runtime/asm_amd64.s</code>，代码：</p><pre class=" language-ams"><code class="language-ams">TEXT runtime·rt0_go(SB),NOSPLIT,$0    // 省略很多 CPU 相关的特性标志位检查的代码    // 主要是看不懂，^_^    // ………………………………    // 下面是最后调用的一些函数，比较重要    // 初始化执行文件的绝对路径    CALL    runtime·args(SB)    // 初始化 CPU 个数和内存页大小    CALL    runtime·osinit(SB)    // 初始化命令行参数、环境变量、gc、栈空间、内存管理、所有 P 实例、HASH算法等    CALL    runtime·schedinit(SB)    // 要在 main goroutine 上运行的函数    MOVQ    $runtime·mainPC(SB), AX        // entry    PUSHQ    AX    PUSHQ    $0            // arg size    // 新建一个 goroutine，该 goroutine 绑定 runtime.main，放在 P 的本地队列，等待调度    CALL    runtime·newproc(SB)    POPQ    AX    POPQ    AX    // 启动M，开始调度goroutine    CALL    runtime·mstart(SB)    MOVL    $0xf1, 0xf1  // crash    RETDATA    runtime·mainPC+0(SB)/8,$runtime·main(SB)GLOBL    runtime·mainPC(SB),RODATA,$8    </code></pre><p>参考文献里的一篇文章【探索 golang 程序启动过程】研究得比较深入，总结下：</p><blockquote><ol><li>检查运行平台的CPU，设置好程序运行需要相关标志。</li><li>TLS的初始化。</li><li>runtime.args、runtime.osinit、runtime.schedinit 三个方法做好程序运行需要的各种变量与调度器。</li><li>runtime.newproc创建新的goroutine用于绑定用户写的main方法。</li><li>runtime.mstart开始goroutine的调度。</li></ol></blockquote><p>最后用一张图来总结 go bootstrap 过程吧：</p><p><img src="https://user-images.githubusercontent.com/7698088/60493589-b2a04a00-9cdf-11e9-9c9e-a4b275973f60.png" alt="golang bootstrap"></p><p>main 函数里执行的一些重要的操作包括：新建一个线程执行 sysmon 函数，定期垃圾回收和调度抢占；启动 gc；执行所有的 init 函数等等。</p><p>上面是启动过程，看一下退出过程：</p><blockquote><p>当 main 函数执行结束之后，会执行 exit(0) 来退出进程。若执行 exit(0) 后，进程没有退出，main 函数最后的代码会一直访问非法地址：</p></blockquote><pre class=" language-golang"><code class="language-golang">exit(0)for {    var x *int32    *x = 0}</code></pre><blockquote><p>正常情况下，一旦出现非法地址访问，系统会把进程杀死，用这样的方法确保进程退出。</p></blockquote><p>关于程序退出这一段的阐述来自群聊《golang runtime 阅读》，又是一个高阶的读源码的组织，github 主页见参考资料。</p><p>当然 Go 程序启动这一部分其实还会涉及到 fork 一个新进程、装载可执行文件，控制权转移等问题。还是推荐看前面的两本书，我觉得我不会写得更好，就不叙述了。</p><h1 id="GoRoot-和-GoPath"><a href="#GoRoot-和-GoPath" class="headerlink" title="GoRoot 和 GoPath"></a>GoRoot 和 GoPath</h1><p>GoRoot 是  Go 的安装路径。mac 或 unix 是在 <code>/usr/local/go</code> 路径上，来看下这里都装了些什么：</p><p><img src="https://user-images.githubusercontent.com/7698088/60344492-41178180-99e9-11e9-98b0-b1f8d64ce97d.png" alt="/usr/local/go"></p><p>bin 目录下面：</p><p><img src="https://user-images.githubusercontent.com/7698088/60344698-b5522500-99e9-11e9-8883-a5bf2460fba0.png" alt="bin"></p><p>pkg 目录下面：</p><p><img src="https://user-images.githubusercontent.com/7698088/60344731-c7cc5e80-99e9-11e9-8002-83f3debc09a6.png" alt="pkg"></p><p>Go 工具目录如下，其中比较重要的有编译器 <code>compile</code>，链接器 <code>link</code>：</p><p><img src="https://user-images.githubusercontent.com/7698088/60379164-888d2480-9a60-11e9-9322-920c0e1b2b3d.png" alt="pkg/tool"></p><p>GoPath 的作用在于提供一个可以寻找 <code>.go</code> 源码的路径，它是一个工作空间的概念，可以设置多个目录。Go 官方要求，GoPath 下面需要包含三个文件夹：</p><pre class=" language-shell"><code class="language-shell">srcpkgbin</code></pre><p>src 存放源文件，pkg 存放源文件编译后的库文件，后缀为 <code>.a</code>；bin 则存放可执行文件。</p><h1 id="Go-命令详解"><a href="#Go-命令详解" class="headerlink" title="Go 命令详解"></a>Go 命令详解</h1><p>直接在终端执行：</p><pre class=" language-shell"><code class="language-shell">go</code></pre><p>就能得到和 go 相关的命令简介：</p><p><img src="https://user-images.githubusercontent.com/7698088/60248752-e2bda680-98f5-11e9-8b3b-7deaf70a919c.png" alt="go commands"></p><p>和编译相关的命令主要是：</p><pre class=" language-shell"><code class="language-shell">go buildgo installgo run</code></pre><h2 id="go-build"><a href="#go-build" class="headerlink" title="go build"></a>go build</h2><p><code>go build</code> 用来编译指定 packages 里的源码文件以及它们的依赖包，编译的时候会到 <code>$GoPath/src/package</code> 路径下寻找源码文件。<code>go build</code> 还可以直接编译指定的源码文件，并且可以同时指定多个。</p><p>通过执行 <code>go help build</code> 命令得到 <code>go build</code> 的使用方法：</p><pre class=" language-shell"><code class="language-shell">usage: go build [-o output] [-i] [build flags] [packages]</code></pre><p><code>-o</code> 只能在编译单个包的时候出现，它指定输出的可执行文件的名字。</p><p><code>-i</code> 会安装编译目标所依赖的包，安装是指生成与代码包相对应的 <code>.a</code> 文件，即静态库文件（后面要参与链接），并且放置到当前工作区的 pkg 目录下，且库文件的目录层级和源码层级一致。</p><p>至于 build flags 参数，<code>build, clean, get, install, list, run, test</code> 这些命令会共用一套：</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>强制重新编译所有涉及到的包，包括标准库中的代码包，这会重写 /usr/local/go 目录下的 <code>.a</code> 文件</td></tr><tr><td>-n</td><td>打印命令执行过程，不真正执行</td></tr><tr><td>-p n</td><td>指定编译过程中命令执行的并行数，n 默认为 CPU 核数</td></tr><tr><td>-race</td><td>检测并报告程序中的数据竞争问题</td></tr><tr><td>-v</td><td>打印命令执行过程中所涉及到的代码包名称</td></tr><tr><td>-x</td><td>打印命令执行过程中所涉及到的命令，并执行</td></tr><tr><td>-work</td><td>打印编译过程中的临时文件夹。通常情况下，编译完成后会被删除</td></tr></tbody></table><p>我们知道，Go 语言的源码文件分为三类：命令源码、库源码、测试源码。</p><blockquote><p>命令源码文件：是 Go 程序的入口，包含 <code>func main()</code> 函数，且第一行用 <code>package main</code> 声明属于 main 包。</p></blockquote><blockquote><p>库源码文件：主要是各种函数、接口等，例如工具类的函数。</p></blockquote><blockquote><p>测试源码文件：以 <code>_test.go</code> 为后缀的文件，用于测试程序的功能和性能。</p></blockquote><p>注意，<code>go build</code> 会忽略 <code>*_test.go</code> 文件。</p><p>我们通过一个很简单的例子来演示 <code>go build</code> 命令。我用 Goland 新建了一个 <code>hello-world</code> 项目（为了展示引用自定义的包，和之前的 hello-world 程序不同），项目的结构如下：</p><p><img src="https://user-images.githubusercontent.com/7698088/60383032-5b5f6700-9a9e-11e9-9613-03d9ba13b889.png" alt="example structure"></p><p>最左边可以看到项目的结构，包含三个文件夹：bin，pkg，src。其中 src 目录下有一个 main.go，里面定义了 main 函数，是整个项目的入口，也就是前面提过的所谓的命令源码文件；src 目录下还有一个 util 目录，里面有 util.go 文件，定义了一个可以获取本机 IP 地址的函数，也就是所谓的库源码文件。</p><p>中间是 main.go 的源码，引用了两个包，一个是标准库的 fmt；一个是 util 包，util 的导入路径是 <code>util</code>。所谓的导入路径是指相对于 Go 的源码目录 <code>$GoRoot/src</code> 或者 <code>$GoPath/src</code> 的下的子路径。例如 main 包里引用的 fmt 的源码路径是 <code>/usr/local/go/src/fmt</code>，而 util 的源码路径是 <code>/Users/qcrao/hello-world/src/util</code>，正好我们设置的 GoPath = /Users/qcrao/hello-world。</p><p>最右边是库函数的源码，实现了获取本机 IP 的函数。</p><p>在 src 目录下，直接执行 <code>go build</code> 命令，在同级目录生成了一个可执行文件，文件名为 <code>src</code>，使用 <code>./src</code> 命令直接执行，输出：</p><pre class=" language-shell"><code class="language-shell">hello world!Local IP: 192.168.1.3</code></pre><p>我们也可以指定生成的可执行文件的名称：</p><pre class=" language-shell"><code class="language-shell">go build -o bin/hello</code></pre><p>这样，在 bin 目录下会生成一个可执行文件，运行结果和上面的 <code>src</code> 一样。</p><p>其实，util 包可以单独被编译。我们可以在项目根目录下执行：</p><pre class=" language-shell"><code class="language-shell">go build util</code></pre><p>编译程序会去 $GoPath/src 路径找 util 包（其实是找文件夹）。还可以在 <code>./src/util</code> 目录下直接执行 <code>go build</code> 编译。</p><p>当然，直接编译库源码文件不会生成 .a 文件，因为：</p><blockquote><p>go build 命令在编译只包含库源码文件的代码包（或者同时编译多个代码包）时，只会做检查性的编译，而不会输出任何结果文件。</p></blockquote><p>为了展示整个编译链接的运行过程，我们在项目根目录执行如下的命令：</p><pre class=" language-shell"><code class="language-shell">go build -v -x -work -o bin/hello src/main.go</code></pre><p><code>-v</code> 会打印所编译过的包名字，<code>-x</code> 打印编译期间所执行的命令，<code>-work</code> 打印编译期间生成的临时文件路径，并且编译完成之后不会被删除。</p><p>执行结果：</p><p><img src="https://user-images.githubusercontent.com/7698088/60386219-e3586780-9ac4-11e9-871f-5acfa83372d0.png" alt="编译过程"></p><p>从结果来看，图中用箭头标注了本次编译过程涉及 2 个包：util，command-line-arguments。第二个包比较诡异，源码里根本就没有这个名字好吗？其实这是 <code>go build</code> 命令检测到 [packages] 处填的是一个 <code>.go</code> 文件，因此创建了一个虚拟的包：command-line-arguments。</p><p>同时，用红框圈出了 compile, link，也就是先编译了 util 包和 <code>main.go</code> 文件，分别得到 <code>.a</code> 文件，之后将两者进行链接，最终生成可执行文件，并且移动到 bin 目录下，改名为 hello。</p><p>另外，第一行显示了编译过程中的工作目录，此目录的文件结构是：</p><p><img src="https://user-images.githubusercontent.com/7698088/60386682-06861580-9acb-11e9-8367-d37ce03a46cc.png" alt="临时工作目录"></p><p>可以看到，和 hello-world 目录的层级基本一致。command-line-arguments 就是虚拟的 main.go 文件所处的包。exe 目录下的可执行文件在最后一步被移动到了 bin 目录下，所以这里是空的。</p><p>整体来看，<code>go build</code> 在执行时，会先递归寻找 main.go 所依赖的包，以及依赖的依赖，直至最底层的包。这里可以是深度优先遍历也可以是宽度优先遍历。如果发现有循环依赖，就会直接退出，这也是经常会发生的循环引用编译错误。</p><p>正常情况下，这些依赖关系会形成一棵倒着生长的树，树根在最上面，就是 main.go 文件，最下面是没有任何其他依赖的包。编译器会从最左的节点所代表的包开始挨个编译，完成之后，再去编译上一层的包。</p><p>这里，引用郝林老师几年前在 github 上发表的 go 命令教程，可以从参考资料找到原文地址。</p><blockquote><p>从代码包编译的角度来说，如果代码包 A 依赖代码包 B，则称代码包 B 是代码包 A 的依赖代码包（以下简称依赖包），代码包 A 是代码包 B 的触发代码包（以下简称触发包）。</p></blockquote><blockquote><p>执行 <code>go build</code> 命令的计算机如果拥有多个逻辑 CPU 核心，那么编译代码包的顺序可能会存在一些不确定性。但是，它一定会满足这样的约束条件：依赖代码包 -&gt; 当前代码包 -&gt; 触发代码包。</p></blockquote><p>顺便推荐一个浏览器插件 Octotree，在看 github 项目的时候，此插件可以在浏览器里直接展示整个项目的文件结构，非常方便：</p><p><img src="https://user-images.githubusercontent.com/7698088/60390988-d9f7eb00-9b16-11e9-83ec-64c3c0beb6ad.png" alt="github 插件"></p><p>到这里，你一定会发现，对于 hello-wrold 文件夹下的 pkg 目录好像一直没有涉及到。</p><p>其实，pkg 目录下面应该存放的是涉及到的库文件编译后的包，也就是一些 <code>.a</code> 文件。但是 go build 执行过程中，这些 <code>.a</code> 文件放在临时文件夹中，编译完成后会被直接删掉，因此一般不会用到。</p><p>前面我们提到过，在 go build 命令里加上 <code>-i</code> 参数会安装这些库文件编译的包，也就是这些 <code>.a</code> 文件会放到 pkg 目录下。</p><p>在项目根目录执行 <code>go build -i src/main.go</code> 后，pkg 目录里增加了 util.a 文件：</p><p><img src="https://user-images.githubusercontent.com/7698088/60386864-84e3b700-9acd-11e9-9513-68a52ff460bb.png" alt="pkg"></p><p><code>darwin_amd64</code> 表示的是：</p><blockquote><p>GOOS 和 GOARCH。这两个环境变量不用我们设置，系统默认的。</p></blockquote><blockquote><p>GOOS 是 Go 所在的操作系统类型，GOARCH 是 Go 所在的计算架构。</p></blockquote><blockquote><p>Mac 平台上这个目录名就是 darwin_amd64。</p></blockquote><p>生成了 util.a 文件后，再次编译的时候，就不会再重新编译 util.go 文件，加快了编译速度。</p><p>同时，在根目录下生成了名称为 main 的可执行文件，这是以 main.go 的文件名命令的。</p><p>hello-world 这个项目的代码已经上传到了 github 项目 <code>Go-Questions</code>，这个项目由问题导入，企图串连 Go 的所有知识点，正在完善，期待你的 star。 地址见参考资料【Go-Questions hello-world项目】。</p><h2 id="go-install"><a href="#go-install" class="headerlink" title="go install"></a>go install</h2><p><code>go install</code> 用于编译并安装指定的代码包及它们的依赖包。相比 <code>go build</code>，它只是多了一个“安装编译后的结果文件到指定目录”的步骤。</p><p>还是使用之前 hello-world 项目的例子，我们先将 pkg 目录删掉，在项目根目录执行：</p><pre class=" language-shell"><code class="language-shell">go install src/main.go或者go install util</code></pre><p>两者都会在根目录下新建一个 <code>pkg</code> 目录，并且生成一个 <code>util.a</code> 文件。</p><p>并且，在执行前者的时候，会在 GOBIN 目录下生成名为 main 的可执行文件。</p><p>所以，运行 <code>go install</code> 命令，库源码包对应的 <code>.a</code> 文件会被放置到 <code>pkg</code> 目录下，命令源码包生成的可执行文件会被放到 GOBIN 目录。</p><p><code>go install</code> 在 GoPath 有多个目录的时候，会产生一些问题，具体可以去看郝林老师的 <code>Go 命令教程</code>，这里不展开了。</p><h2 id="go-run"><a href="#go-run" class="headerlink" title="go run"></a>go run</h2><p><code>go run</code> 用于编译并运行命令源码文件。</p><p>在 hello-world 项目的根目录，执行 go run 命令：</p><pre class=" language-shell"><code class="language-shell">go run -x -work src/main.go</code></pre><p>-x 可以打印整个过程涉及到的命令，-work 可以看到临时的工作目录：</p><p><img src="https://user-images.githubusercontent.com/7698088/60391387-ae2d3300-9b1f-11e9-9355-a8f59c2eac9b.png" alt="go run 过程"></p><p>从上图中可以看到，仍然是先编译，再连接，最后直接执行，并打印出了执行结果。</p><p>第一行打印的就是工作目录，最终生成的可执行文件就是放置于此：</p><p><img src="https://user-images.githubusercontent.com/7698088/60391357-30692780-9b1f-11e9-8be4-48041779e293.png" alt="go run 结果"></p><p>main 就是最终生成的可执行文件。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次的话题太大了，困难重重。从编译原理到 go 启动时的流程，到 go 命令原理，每个话题单独抽出来都可以写很多。</p><p>幸好有一些很不错的书和博客文章可以去参考。这篇文章就作为一个引子，你可以跟随参考资料里推荐的一些内容去发散。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【《程序员的自我修养》全书】<a href="https://book.douban.com/subject/3652388/" target="_blank" rel="noopener">https://book.douban.com/subject/3652388/</a></p><p>【面向信仰编程 编译过程概述】<a href="https://draveness.me/golang-compile-intro" target="_blank" rel="noopener">https://draveness.me/golang-compile-intro</a></p><p>【golang runtime 阅读】<a href="https://github.com/zboya/golang_runtime_reading">https://github.com/zboya/golang_runtime_reading</a></p><p>【Go-Questions hello-world项目】<a href="https://github.com/qcrao/Go-Questions/tree/master/examples/hello-world">https://github.com/qcrao/Go-Questions/tree/master/examples/hello-world</a></p><p>【雨痕大佬的 Go 语言学习笔记】<a href="https://github.com/qyuhen/book">https://github.com/qyuhen/book</a></p><p>【vim 以 16 进制文本】<a href="https://www.cnblogs.com/meibenjin/archive/2012/12/06/2806396.html" target="_blank" rel="noopener">https://www.cnblogs.com/meibenjin/archive/2012/12/06/2806396.html</a></p><p>【Go 编译命令执行过程】<a href="https://halfrost.com/go_command/" target="_blank" rel="noopener">https://halfrost.com/go_command/</a></p><p>【Go 命令执行过程】<a href="https://github.com/hyper0x/go_command_tutorial">https://github.com/hyper0x/go_command_tutorial</a></p><p>【Go 词法分析】<a href="https://ggaaooppeenngg.github.io/zh-CN/2016/04/01/go-lexer-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">https://ggaaooppeenngg.github.io/zh-CN/2016/04/01/go-lexer-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/</a></p><p>【曹大博客 golang 与 ast】<a href="http://xargin.com/ast/" target="_blank" rel="noopener">http://xargin.com/ast/</a></p><p>【Golang 词法解析器，scanner 源码分析】<a href="https://blog.csdn.net/zhaoruixiang1111/article/details/89892435" target="_blank" rel="noopener">https://blog.csdn.net/zhaoruixiang1111/article/details/89892435</a></p><p>【Gopath Explained】<a href="https://flaviocopes.com/go-gopath/" target="_blank" rel="noopener">https://flaviocopes.com/go-gopath/</a></p><p>【Understanding the GOPATH】<a href="https://www.digitalocean.com/community/tutorials/understanding-the-gopath" target="_blank" rel="noopener">https://www.digitalocean.com/community/tutorials/understanding-the-gopath</a></p><p>【讨论】<a href="https://stackoverflow.com/questions/7970390/what-should-be-the-values-of-gopath-and-goroot" target="_blank" rel="noopener">https://stackoverflow.com/questions/7970390/what-should-be-the-values-of-gopath-and-goroot</a></p><p>【Go 官方 Gopath】<a href="https://golang.org/cmd/go/#hdr-GOPATH_environment_variable" target="_blank" rel="noopener">https://golang.org/cmd/go/#hdr-GOPATH_environment_variable</a></p><p>【Go package 的探索】<a href="https://mp.weixin.qq.com/s/OizVLXfZ6EC1jI-NL7HqeA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/OizVLXfZ6EC1jI-NL7HqeA</a></p><p>【Go 官方 关于 Go 项目的组织结构】<a href="https://golang.org/doc/code.html" target="_blank" rel="noopener">https://golang.org/doc/code.html</a></p><p>【Go modules】<a href="https://www.melvinvivas.com/go-version-1-11-modules/" target="_blank" rel="noopener">https://www.melvinvivas.com/go-version-1-11-modules/</a></p><p>【Golang Installation, Setup, GOPATH, and Go Workspace】<a href="https://www.callicoder.com/golang-installation-setup-gopath-workspace/" target="_blank" rel="noopener">https://www.callicoder.com/golang-installation-setup-gopath-workspace/</a></p><p>【编译、链接过程链接】<a href="https://mikespook.com/2013/11/%E7%BF%BB%E8%AF%91-go-build-%E5%91%BD%E4%BB%A4%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F/" target="_blank" rel="noopener">https://mikespook.com/2013/11/%E7%BF%BB%E8%AF%91-go-build-%E5%91%BD%E4%BB%A4%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F/</a></p><p>【1.5 编译器由 go 语言完成】<a href="https://www.infoq.cn/article/2015/08/go-1-5" target="_blank" rel="noopener">https://www.infoq.cn/article/2015/08/go-1-5</a></p><p>【Go 编译过程系列文章】<a href="https://www.ctolib.com/topics-3724.html" target="_blank" rel="noopener">https://www.ctolib.com/topics-3724.html</a></p><p>【曹大 go bootstrap】<a href="https://github.com/cch123/golang-notes/blob/master/bootstrap.md">https://github.com/cch123/golang-notes/blob/master/bootstrap.md</a></p><p>【golang 启动流程】<a href="https://blog.iceinto.com/posts/go/start/" target="_blank" rel="noopener">https://blog.iceinto.com/posts/go/start/</a></p><p>【探索 golang 程序启动过程】<a href="http://cbsheng.github.io/posts/%E6%8E%A2%E7%B4%A2golang%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/" target="_blank" rel="noopener">http://cbsheng.github.io/posts/%E6%8E%A2%E7%B4%A2golang%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</a></p><p>【探索 goroutine 的创建】<a href="http://cbsheng.github.io/posts/%E6%8E%A2%E7%B4%A2goroutine%E7%9A%84%E5%88%9B%E5%BB%BA/" target="_blank" rel="noopener">http://cbsheng.github.io/posts/%E6%8E%A2%E7%B4%A2goroutine%E7%9A%84%E5%88%9B%E5%BB%BA/</a></p><p><img src="https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png" alt="QR"></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang,编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度解密Go语言之context</title>
      <link href="/2019/07/24/dive-into-go-context/"/>
      <url>/2019/07/24/dive-into-go-context/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何打造一份优雅的简历</title>
      <link href="/2019/07/08/how-to-write-resume-gracefully/"/>
      <url>/2019/07/08/how-to-write-resume-gracefully/</url>
      
        <content type="html"><![CDATA[<p>最近一些朋友找我内推，并且给我发了他们的简历。很多简历在我看来都不合格，不只是内容，还有格式，在我这都没过关。然后，我都会把我的简历模板贡献出来，收获了诸多好评。</p><p>为了让更多读者朋友拥有一份优雅得体的简历，我会倾其所能，把经验全部传授出来，希望你能有收获。</p><p>虽然现在不是求职的高峰期，但是社招、实习还是随时都可以进行的。我也不是一个追热点的人，只求对你有所帮助。另外，简历的制作其实并不是一蹴而就的事，当你知道了写简历的套路，平时就会有意识的积累素材，所以什么时候都可以学习如何打造一份优雅的简历。</p><p>简历是什么？在我看来，在面试之前，直接代表你这个人。虽然简历不会说话，但是简历的内容会让面试官直接在脑海里勾勒出你的形象。如果简历排版非常精致，你就会被塑造成一位细心、得体的形象；反之，如果简历里出现了错别字，那粗心这个标签就会打到你身上了。</p><p>所以，对待简历一定要重视！它是找工作过程中的第一道关卡，过了这一关，才有在面试中展示自我的机会。当然，平时的积累，个人的真实水平，临场发挥、人脉、运气也都很重要。这篇文章假设那些因素大家都一样，只比拼简历，就看谁简历写得好。</p><p>好的简历就是你的名片，不好的简历可能就是你的黑历史。接下来我们进入正题，说说简历该怎么写。</p><p>先贴一份完成了的简历。为了不暴露隐私，简历中的信息都是虚构的，但是写法都是按照模板来的，所以仍然不失一份精彩的样例，可以细看研究的。</p><p><img src="https://user-images.githubusercontent.com/7698088/60750234-2d1ae380-9fd8-11e9-8071-8aee3887d960.png" alt="整体"></p><p>顺便说一句，这张图片，可以自由传播。如果你仔细研究一下简历中的三个项目，你肯定会被我的才华折服的。</p><p>接下来就按简历模板里各个板块的顺序，详细解释每个部分该怎么写。</p><h1 id="抬头"><a href="#抬头" class="headerlink" title="抬头"></a>抬头</h1><p>直接写名字，电话号码，邮箱，其他信息不用填写。</p><p>我找工作那会，实验室的信号不是太好，所以在手机号码后面还留了个座机号码，防止联系不上，这是细节。</p><p>关于电子邮箱，校招的同学可以留学校的邮箱；对于社招，gmail.com，163.com，foxmail.com 都不错，qq.com 也是可以的，只是需要把邮箱前缀改成一些有意义的，例如姓名的缩写之类的，这在邮箱设置里直接设置就好了，一定不要出现一些“中二”的邮箱名，例如“今夜无眠”之类的绝对不要出现。</p><p>有些同学问，需不需要挂个相片上去？其实，在抬头右侧空白部分，是可以挂上的。但是，我建议男生一率不要挂照片（当然如果你有吴彦祖的风彩当我没说），女生可以适当挂上证件照，前提是颜值是你的一大优势。</p><p>当然，一些国企事业单位会强制要求你贴上照片，那就贴好了。但也不要随便找一个白拍照就放上去了，找一家正规的照相馆，化好妆，照片精修后的效果肯定可以提高你在面试官那里的第一印象，这是好的开始。</p><h1 id="教育背景"><a href="#教育背景" class="headerlink" title="教育背景"></a>教育背景</h1><p>这块直接从最高学历写起，写到本科即可。包括时间，学位，学校，专业，排名这些信息。有些可以体现你实力的东西是可以备注上的，例如优秀毕业生，免试推荐研究生，这些是可以在挂号里备注上的。</p><p>有些人说，这样是不是太高调了？借用 caoz 的一句话：你矜持，你活该。</p><p>最后，关于排名，如果你是专业第一名，就直接写上；否则，就计算一下你的排名大概占比百分之多少。如果班级排名高，就按班级的排名来，如果学校排名高，就写学校的排名。总之，按最高的来写。研究生一般没有排名这个说法，那你就估个数好了，填上 Top 5%，一般没有问题。</p><p>这里教大家一个小技巧，你看前面贴出来的简历是不是排列得很整齐？让你自己动手做，你不一定排得这么整齐。教你一招：</p><p><img src="https://user-images.githubusercontent.com/7698088/60749990-b6301b80-9fd4-11e9-9002-b0c09a0061b3.png" alt="表格"></p><p>通过表格，能自动地让文字对齐。写完之后，只需要将表格的边框设置为不可见就行了！深藏功与名！隐藏表格边框后的效果是这样的：</p><p><img src="https://user-images.githubusercontent.com/7698088/60750002-ea0b4100-9fd4-11e9-9eca-b286b61894fc.png" alt="表格去边框"></p><p>有没有被惊艳到？如果你早就知道了这个技巧，当我没说。</p><h1 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h1><p>如实写就好了，校招同学这一项可以写下实习经历，如果没有实习，这一项整体就不要了。社招同学不要在这上面弄虚作假，因为社招入职都会做尽调，被查出不诚信就尴尬了。</p><p>同样，可以用到上面提到的用表格排版的小技巧。</p><h1 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h1><p>找互联网工作的同学，一定刷过《剑指 offer》这本书，书里面的题在面试过程中出场率还是挺高的。但是，很多同学都只看了其中的题目部分，对于前两章可能就略读了，甚至直接跳过去了。其实，书的前两章是讲如何面试的，同样写得很精彩，值得细细研究。</p><p>咱们这篇文章不说面试，只说简历。但书里面有一个非常好的点 —— 描述项目的 STAR 模型：</p><p><img src="https://user-images.githubusercontent.com/7698088/60749073-7b73b680-9fc7-11e9-8cd2-4ca103a827b4.png" alt="STAR模型"></p><p>项目经历这一项按照这个模型来写就 OK 了。</p><p>先简述项目背景，为什么要做它，要简短、清晰，也就是 <code>Situation</code>；</p><p>再来说你负责哪一块，做了哪些有价值的工作，这一块要学会提炼，不能是简单的工作罗列，尽量让人觉得这是有技术含量的，包含 <code>Task &amp; Action</code>；</p><p>最后，就是这件事完成的效果如何，是性能提升了 100 倍还是从零到一完成了某个复杂的系统，关键在于你要用数字来表达。例如，我经过一系列的优化过程，使得系统响应时间缩短为原来的 50%，或者说响应时间提升 1 倍，平均响应时间达到 1 ms 等等。</p><p>举个例子来说：</p><p><img src="https://user-images.githubusercontent.com/7698088/60750894-59872d80-9fe1-11e9-9fe3-9c6b48aade9e.png" alt="project"></p><p>最开始一行，项目的简要信息。首先<code>项目的起止时间</code>，这个要斟酌一下，太长显得效率太低，太短可能又显得不深入。不是要教大家不诚信，这块适当“优化”下没太大问题；然后是<code>地点</code>，可以是学校，也可以是公司，照实写；接着是<code>项目名</code>，简短、清晰；最后是你的<code>角色</code>，一般可以写项目总负责人，核心参与者，项目主导者等等，不要太浮夸，也不要太低下。</p><p>接着，项目介绍。主要是讲清楚你做这个事的背景是什么。注意，不能说“这是实验室项目要求”或者“老师指定我做的”，要写这个项目的背景，业界是个什么进展，本项目它能解决什么问题，价值在哪，这是应该写的。有些项目确实垃圾，但编也得编一个高大上的介绍，毕竟它代表了你的水平不是嘛？</p><p>接着，个人职责。先是概要的一句话，例如负责系统的整体架构，打上一个句号，这是总起，后面用更细致的话来解释。例如，充分调研市面上的相关系统，反复设计修改，设计出一套高可用、高性能、可扩展的系统架构。一般要列三点，多了太长，少了显得工作量少。所以，要挑选最重要的点来说，例如，设计并实现了某个算法，性能是之前的多少倍。</p><p>最后，项目成果。这块一定要挑最亮点的来说，而且一定要能用数字量化。常见的就是性能提升了多少倍，支持了多少并发，支持了多少用户，不可用时长为 0，发表文章专利多少篇……</p><p>重要词语、数字用加粗来突出显示。这些加粗就是你最擅长的点，也是面试官可能会问你。所以你想让他问你什么，就加粗吧！</p><h1 id="个人技能"><a href="#个人技能" class="headerlink" title="个人技能"></a>个人技能</h1><p>这一项比较好搞定，把你的技能罗列出来，注意是和工作相关的。你找互联网的工作，写上一句“熟悉 office 的操作”就不太合适了吧。可以写：熟练掌握常见的数据结构和算法，熟悉 C/C++，熟悉 mysql/codis/etcd/zookper……</p><p>英语听说读写能力也可以写上，例如“能熟练进行英文的听说读写”。</p><p>唯一需要注意的是，不要也不能写“精通”。“精通”是一个非常强的词，很少人能做到。这里并不是谦虚的问题，还涉及到一个预期管理的问题，也就是面对“精通”和“熟悉”，面试官对你的期待是不一样的。</p><p>如果你写上“熟悉 Golang”，那么当面试官问你一个比较深入的问题时（例如 Golang 的 map 是怎么进行扩容的），你答上来了，他会觉得你水平比较高，而且还很谦虚。相反，你写的是“精通 Golang”，面试过程中，只要有一个问题没答上，那是不是一下子印象就下去了？</p><p>还写人写“精通 C/C++”，要知道，就是 C++ 的作者，他也不能完全掌握 C++ 的特性啊，即使 C++ 编译器，也不是所有的特性它都支持。换句话说，即使是编译器，也不能说它精通 C++。</p><h1 id="个人评价"><a href="#个人评价" class="headerlink" title="个人评价"></a>个人评价</h1><p>这一栏，可以展示你在工作技能之外的特性。例如，我看到有师兄这样写：</p><blockquote><p>高中班主任这样评价我：你是一个严于律己的人，一个精诚团结的人，一个志向远大的人。</p></blockquote><p>面试官可能会问：班主任为什么要这么评价？这时，他就掉入你提前挖好的“坑”，因为一个可以展示你优秀品质的故事正在等着他，这是你提前准备的已经演练了无数遍了。而且，面试进程也在你的掌握之中了。</p><p>注意，不要太多，也不要太浮夸，着重展示你是一个可以合作，善于沟通，工作积极的人。</p><h1 id="其他事项"><a href="#其他事项" class="headerlink" title="其他事项"></a>其他事项</h1><p>这块说一下其他未尽事项。</p><p>校招简历一般只要一页，就算你有再多内容要写，也只能压缩到一页，把那些最重要的，最能展示你能力的那部分内容保留下来，其他的干掉。</p><p>社招简历也不要超过两页，这样显得简练，展示的也都是高质量的项目，不能是简单的罗列，要总结升华。这样也可以打印到一页纸上，方便面试官，也就是方便你自己。</p><p>工作中，有一项非常重要的能力就是总结、提炼、升华。可能实验室的项目是一些企业的横向项目，就是 1+1=2 的事，非常简单，可能你觉得没啥可写的。这就是你发挥能力的时候了，从这些日常操作中，总结出一些高大上的东西来。如果不会，多参考一下优秀学长学姐的简历。</p><p>总之，你写到简历上的项目一定是经过总结升华的，这需要经过你无数次的修改。</p><p>还有一点要注意的是，发给别人的简历一定要是 pdf 格式，有些同学直接把 word 版 丟给别人，不同软件版本的电脑上可能会有兼容性问题啊，可能会有乱码，而且 word 版可能会被篡改。另外，打印简历的时候，也是要用 pdf 版本，不会出问题。</p><p>简历文件命名也是一个要注意的点。一般用 “码农桃花源-桃花源工作室-18888888888”，也就是“姓名-学校/公司-手机”这样的格式。这样，方便 HR 或者面试官联系你，因为只看文件名就能知道你的联系方式，和一些最重要的信息。再说一次，方便面试官就是方便你自己。</p><p>还有一个点，针对不同职位的简历应该是不一样的。这时，你可以把你的项目进行组合，不同职位的简历对应不同的项目组合，有的放矢。有些人会用 git 的不同分支维护不同的简历版本。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>简历是你的代表，无声代表你这个人；它也是一个面试索引，能引导面试官的提问。所以如果你特别擅长某个方面，一定要在简历上突出。这相当于给面试官“挖坑”，如果他进坑了，那问的问题一定要你早就烂熟于心的，因为那是你准备无数遍的精彩故事、优化案例。</p><p>这样，面试官整个过程都是受你的引导，在你的框框里，不知不觉，在你讲述你擅长内容的过程中，面试进程被你掌握了。面试官接下来的问题，也会是围绕你的回答、故事展开。</p><p>要知道，如果你让面试官自己想问题，那你多半是招架不住的，因为真正的高手可能不会看这篇文章，哈哈，开个玩笑。</p><p>这篇文章里的简历是用我真实的简历进行修改的，当然主要是修改的内容。而且，为了展示我的幽默，我还编了三个项目，非常精彩，值得一看。我也真的是够了，哈哈。</p><p>这份简历模板是我在学校的时候，从师兄师组那学习过来的，包括用表格排版的技巧。他们去的都是像微软、谷歌、FB、BAT 这些高大上的互联网公司。所以这绝对是一份久经考验的简历模板。而且，初看起来，似乎平淡无奇，但细细琢磨，真的是低调奢华有内涵，你值得拥有。</p><p>我把 word 版本放到网盘上了，公众号回复“简历模板”或者 “jlmb”，我会回复你下载地址。</p><p>仅仅是把你简历上的内容 copy 到这个模板上，你也会觉得“瞬间高大上起来了”。加油~~</p><p><img src="https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png" alt="QR"></p>]]></content>
      
      
      <categories>
          
          <category> 求职 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 简历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>曹大谈内存重排</title>
      <link href="/2019/06/17/cch-says-memory-reorder/"/>
      <url>/2019/06/17/cch-says-memory-reorder/</url>
      
        <content type="html"><![CDATA[<p>写这篇文章的原因很简单，公司内部的 Golang 社区组织了第一期分享，主讲嘉宾就是我们敬爱的曹大。这个必定是要去听的，只是曹大的讲题非常硬核，所以提前找他要了参考资料，花了 1 个小时提前预习，才不至于在正式分享的时候什么也不懂。当然了，这也是对自己和主讲者的尊重。所有的参考资料都在文章最后一部分，欢迎自行探索。</p><p>在我读曹大给我的中英文参考资料时，我发现英文的我能读懂，读中文却很费劲。经过对比，我发现，英文文章是由一个例子引入，循序渐进，逐步深入。跟着作者的脚步探索，非常有意思。而中文的博客上来就直奔主题，对于第一次接触的人非常不友好。</p><p>两者就像演绎法和归纳法区别。国内的教材通常是演绎法，也就是上来先讲各种概念、原理，再推出另一些定理，比较枯燥；国外的教材更喜欢由例子引入，步步深入，引人入胜。这里，不去评判孰孰劣。多看看一些英文原版材料，总是有益的。据我所知，曹大经常从亚马逊上购买英文书籍，这个侧面也可以反映曹大的水平高啊。据说英文书一般都很贵，可见曹大也是很有钱的。</p><p>所以啊，技术文章写好不容易，我也自省一下。</p><h1 id="什么是内存重排"><a href="#什么是内存重排" class="headerlink" title="什么是内存重排"></a>什么是内存重排</h1><p>分两种，硬件和软件层面的，包括 CPU 重排、编译器重排。</p><h2 id="CPU-重排"><a href="#CPU-重排" class="headerlink" title="CPU 重排"></a>CPU 重排</h2><p>引用参考资料 <code>【内存一致模型】</code> 里的例子：</p><p><img src="https://user-images.githubusercontent.com/7698088/59549609-c2efbf80-8f92-11e9-86c2-1e3cd8305db1.png" alt="2 thread"></p><p>在两个线程里同时执行上面的代码，A 和 B 初始化值都是 0，那最终的输出是什么？</p><p>先说几种显而易见的结果：</p><table><thead><tr><th>执行顺序</th><th>输出结果</th></tr></thead><tbody><tr><td>1-2-3-4</td><td>01</td></tr><tr><td>3-4-1-2</td><td>01</td></tr><tr><td>1-3-2-4</td><td>11</td></tr><tr><td>1-3-4-2</td><td>11</td></tr></tbody></table><p>当然，还有一些对称的情形，和上面表格中列出的输出是一样的。例如，执行为顺序为 3-1-4-2 的输出为 11。</p><p>从 01 的排列组合来看，总共有4种：00、01、10、11。表格中还差两种：10、00。我们来重点分析下这两种结果究竟会不会出现。</p><p>首先是 <code>10</code>，假设 (2) 输出 1，(4) 输出 0。那么首先给 2，3 排个序：(3) -&gt; (2)，因为先要将 B 赋值为 1，(2) 才能打印出 1；同理，(4) -&gt; (1)。另外，因为先打印 1，所以 (2) 要在 (4) 前面，合起来：(3) -&gt; (2) -&gt; (4) -&gt; (1)。(2) 竟然在 (1) 前面执行了，不可能的！</p><p>那我们再分析下 <code>00</code>，要想打印 00，打印语句必须在相应变量赋值前执行：</p><p><img src="https://user-images.githubusercontent.com/7698088/59549674-b455d800-8f93-11e9-83bb-074f2ab4c490.png" alt="00"></p><p>图中箭头表示先后顺序。这就尴尬了，形成了一个环。如果先从 (1) 开始，那顺序就是 (1) -&gt; (2) -&gt; (3) -&gt; (4) -&gt; (1)。(1) 要被执行了 2 次，怎么可能？所以 <code>00</code> 这种情形也是不可能出现的。</p><p>但是，上面说的两种情况在真实世界是有可能发生的。曹大的讲义里有验证的方法，感兴起的同学自己去尝试。总共测试了 100 百万次，测试结果如下：</p><p><img src="https://user-images.githubusercontent.com/7698088/59570902-5d561d00-90d1-11e9-842d-cf30babbc0a4.png" alt="test result"></p><p>非常反直觉，但是在多线程的世界，各种诡异的问题，只有你想不到，没有计算机做不到的。</p><p>我们知道，用户写下的代码，先要编译成汇编代码，也就是各种指令，包括读写内存的指令。CPU 的设计者们，为了榨干 CPU 的性能，无所不用其极，各种手段都用上了，你可能听过不少，像流水线、分支预测等等。</p><p>其中，为了提高读写内存的效率，会对读写指令进行重新排列，这就是所谓的 <code>内存重排</code>，英文为 <code>Memory Reordering</code>。</p><p>这一部分说的是 CPU 重排，其实还有编译器重排。</p><h2 id="编译器重排"><a href="#编译器重排" class="headerlink" title="编译器重排"></a>编译器重排</h2><p>来看一个代码片段：</p><pre class=" language-python"><code class="language-python">X <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    X <span class="token operator">=</span> <span class="token number">1</span>    <span class="token keyword">print</span> X</code></pre><p>这段代码执行的结果是打印 100 个 1。一个聪明的编译器会分析到循环里对 X 的赋值 <code>X = 1</code> 是多余的，每次都要给它赋上 1，完全没必要。因此会把代码优化一下：</p><pre class=" language-python"><code class="language-python">X <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span> X</code></pre><p>优化后的运行结果完全和之前的一样，完美！</p><p>但是，如果这时有另外一个线程同时干了这么一件事：</p><pre class=" language-python"><code class="language-python">X <span class="token operator">=</span> <span class="token number">0</span></code></pre><p>由于这两个线程并行执行，优化前的代码运行的结果可能是这样的：<code>11101111...</code>。出现了 1 个 0，但在下次循环中，又会被重新赋值为 1，而且之后一直都是 1。</p><p>但是优化后的代码呢：<code>11100000...</code>。由于把 <code>X = 1</code> 这一条赋值语句给优化掉了，某个时刻 X 变成 <code>0</code> 之后，再也没机会变回原来的 <code>1</code> 了。</p><blockquote><p>在多核心场景下,没有办法轻易地判断两段程序是“等价”的。</p></blockquote><p>可见编译器的重排也是基于运行效率考虑的，但以多线程运行时，就会出各种问题。</p><h1 id="为什么要内存重排"><a href="#为什么要内存重排" class="headerlink" title="为什么要内存重排"></a>为什么要内存重排</h1><p>引用曹大的一句话：</p><blockquote><p>软件或硬件系统可以根据其对代码的分析结果，一定程度上打乱代码的执行顺序，以达到其不可告人的目的。</p></blockquote><p>软件指的是编译器，硬件是 CPU。不可告人的目的就是：</p><blockquote><p>减少程序指令数<br>最大化提高 CPU 利用率</p></blockquote><p>曹大又皮了！</p><h1 id="内存重排的底层原理"><a href="#内存重排的底层原理" class="headerlink" title="内存重排的底层原理"></a>内存重排的底层原理</h1><p>CPU 重排的例子里提到的两种不可能出现的情况，并不是那么显而易见，甚至是难以理解。原因何在？</p><p>因为我们相信在多线程的程序里，虽然是并行执行，但是访问的是同一块内存，所以没有语句，准确说是指令，能“真正”同时执行的。对同一个内存地址的写，一定是有先有后，先写的结果一定会被后来的操作看到。</p><p>当我们写的代码以单线程运行的时候，语句会按我们的本来意图 <code>顺序</code> 地去执行。一旦单线程变成多线程，情况就变了。</p><p>想像一个场景，有两个线程在运行，操作系统会在它们之间进行调度。每个线程在运行的时候，都会顺序地执行它的代码。由于对同一个变量的读写，会访问内存的同一地址，所以同一时刻只能有一个线程在运行，即使 CPU 有多个核心：前一个指令操作的结果要让后一个指令看到。</p><p>这样带来的后果就是效率低下。两个线程没法做到并行，因为一个线程所做的修改会影响到另一个线程，那后者只能在前者的修改所造成的影响“可见”了之后，才能运行，变成了串行。</p><p>重新来思考前面的例子：</p><p><img src="https://user-images.githubusercontent.com/7698088/59549609-c2efbf80-8f92-11e9-86c2-1e3cd8305db1.png" alt="2 thread"></p><p>考虑一个问题，为什么 (2) 要等待 (1) 执行完之后才能执行呢？它们之间又没有什么联系，影响不到彼此，完全可以并行去做啊！</p><p>由于 (1) 是写语句，所以比 (2) 更耗时，从 <code>a single view of memory</code> 这个视角来看，(2) 应该等 (1) 的“效果”对其他所有线程可见了之后才可以执行。但是，在一个现代 CPU 里，这需要花费上百个 CPU 周期。</p><p>现代 CPU 为了“抚平” 内核、内存、硬盘之间的速度差异，搞出了各种策略，例如三级缓存等。</p><p><img src="https://user-images.githubusercontent.com/7698088/59557419-223de600-900c-11e9-8c08-a1ba4b0bbbff.png" alt="cpu cache"></p><p>为了让 (2) 不必等待 (1) 的执行“效果”可见之后才能执行，我们可以把 (1) 的效果保存到 <code>store buffer</code>：</p><p><img src="https://user-images.githubusercontent.com/7698088/59557443-e3f4f680-900c-11e9-975e-82d9b7da74c7.png" alt="store buffer"></p><p>当 (1) 的“效果”写到了 <code>store buffer</code> 后，(2) 就可以开始执行了，不必等到 <code>A = 1</code> 到达 L3 cache。因为 <code>store buffer</code> 是在内核里完成的，所以速度非常快。在这之后的某个时刻，<code>A = 1</code> 会被逐级写到 L3 cache，从而被其他所有线程看到。<code>store buffer</code> 相当于把写的耗时隐藏了起来。</p><p><code>store buffer</code> 对单线程是完美的，例如：</p><p><img src="https://user-images.githubusercontent.com/7698088/59557508-e99f0c00-900d-11e9-81d5-5c7a22faecfc.png" alt="store buffer 1 thread"></p><p>将 (1) 存入 <code>store buffer</code> 后，(2) 开始执行。注意，由于是同一个线程，所以语句的执行顺序还是要保持的。</p><p>(2) 直接从 <code>store buffer</code> 里读出了 <code>A = 1</code>，不必从 L3 Cache 或者内存读取，简直完美！</p><p>有了 <code>store buffer</code> 的概念，我们再来研究前面的那个例子：</p><p><img src="https://user-images.githubusercontent.com/7698088/59557535-bf9a1980-900e-11e9-9d19-f84a0f3196db.png" alt="store buffer 2 threads"></p><p>先执行 (1) 和 (3)，将他们直接写入 <code>store buffer</code>，接着执行 (2) 和 (4)。“奇迹”要发生了：(2) 看了下  <code>store buffer</code>，并没有发现有 B 的值，于是从 Memory 读出了 0，(4) 同样从 Memory 读出了 0。最后，打印出了 <code>00</code>。</p><p>所有的现代 CPU 都支持 <code>store buffer</code>，这导致了很多对程序员来说是难以理解的现象。从某种角度来说，不等 <code>A = 1</code> 扩散到 Memory，就去执行 <code>print(B)</code> 语句，可以看成<code>读写指令重排</code>。有些 CPU 甚至优化得更多，几乎所有的操作都可以重排，简直是噩梦。</p><p>因此，对于多线程的程序，所有的 CPU 都会提供“锁”支持，称之为 <code>barrier</code>，或者 <code>fence</code>。它要求：</p><pre class=" language-shell"><code class="language-shell">A barrier instruction forces all memory operations before it to complete before any memory operation after it can begin.</code></pre><p>barrier 指令要求所有对内存的操作都必须要“扩散”到 memory 之后才能继续执行其他对 memory 的操作。</p><p>barrier 指令要耗费几百个 CPU 周期，而且容易出错。因此，我们可以用高级点的 <code>atomic compare-and-swap</code>，或者直接用更高级的锁，通常是标准库提供。</p><blockquote><p>正是 CPU 提供的 barrier 指令，我们才能实现应用层的各种同步原语，如 atomic，而 atomic 又是各种更上层的 lock 的基础。</p></blockquote><p>以上说的是 CPU 重排的原理。编译器重排主要是依据语言自己的“内存模型”，不深入了。</p><p>出现前面描述的诡异现象的根源在于程序存在 <code>data race</code>，也就是说多个线程会同时访问内存的同一个地方，并且至少有一个是写，而且导致了内存重排。所以，最重要的是当我们在写并发程序的时候，要使用一些“同步”的标准库，简单理解就是各种锁，来避免由于内存重排而带来的一些不可预知的结果。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>内存重排是指程序在实际运行时对内存的访问顺序和代码编写时的顺序不一致，主要是为了提高运行效率。分别是硬件层面的 <code>CPU 重排</code> 和软件层面的 <code>编译器重排</code>。</p><p>单线程的程序一般不会有太大问题；多线程情况下，有时会出现诡异的现象，解决办法就是使用标准库里的锁。锁会带来性能问题，为了降低影响，锁应该尽量减小粒度，并且不要在互斥区（锁住的代码）放入耗时长的操作。</p><blockquote><p>lock contention 的本质问题是需要进入互斥区的 goroutine 需要等待独占 goroutine 退出后才能进入互斥区，并行 → 串行。</p></blockquote><p>本文讲的是曹大讲座的一部分，我没有深入研究其他内容，例如 MESI协议、cache contention 等，讲清这些又要牵扯到很多，我还是聚集到深度解密 Go 语言系列吧。有兴趣的话，去曹大博客，给我们提供了很多参考链接，可以自行探索。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【曹大 github】<a href="https://github.com/cch123/golang-notes/blob/master/memory_barrier.md">https://github.com/cch123/golang-notes/blob/master/memory_barrier.md</a></p><p>【曹大讲义】<a href="https://cch123.github.io/ooo/" target="_blank" rel="noopener">https://cch123.github.io/ooo/</a></p><p>【内存一致模型】<a href="https://homes.cs.washington.edu/~bornholt/post/memory-models.html" target="_blank" rel="noopener">https://homes.cs.washington.edu/~bornholt/post/memory-models.html</a></p><p>【掘金咔叽咔叽，译】<a href="https://juejin.im/post/5d0519e05188257a78764d5d#comment" target="_blank" rel="noopener">https://juejin.im/post/5d0519e05188257a78764d5d#comment</a></p><p><img src="https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png" alt="QR"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>dive-into-go-asm</title>
      <link href="/2019/03/20/dive-into-go-asm/"/>
      <url>/2019/03/20/dive-into-go-asm/</url>
      
        <content type="html"><![CDATA[<p>上周六晚上，我参加了“Go夜读”活动，这期主要讲Go汇编语言，由滴滴大佬曹春晖大神主讲。活动结束后，我感觉打通了任督二脉。活动从晚上9点到深夜11点多，全程深度参与，大呼过瘾，以至于活动结束之后，久久不能平静。</p><p>可以说理解了Go汇编语言，就可以让我们对Go的理解上一个台阶，很多以前模棱的东西，在汇编语言面前都无所遁形了。我在活动上收获了很多，今天我来作一个总结，希望给大家带来启发！</p><h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>几周前我写了一篇关于<code>defer</code>的文章：<a href="https://www.cnblogs.com/qcrao-2018/p/10367346.html" target="_blank" rel="noopener">《Golang之如何轻松化解defer的温柔陷阱》</a>。这篇文章发出后不久就被<code>GoCN</code>的每日新闻收录了，然后就被Go夜读群的大佬杨文看到了，之后被邀请去夜读活动分享。</p><p>正式分享前，我又主题阅读了很多文章，以求把defer讲清楚。阅读过程中，我发现但凡深入一点的文章，都会抛出Go汇编语言。于是就去搜索资料，无奈相关的资料太少，看得云里雾里，最后到了真正要分享的时候也没有完全弄清楚。</p><p>夜读活动结束之后，杨大发布了由春晖大神带来的夜读分享预告：<code>《plan9 汇编入门，带你打通应用和底层》</code>。我得知这个消息后，非常激动！终于有牛人可以讲讲Go汇编语言了，听完之后估计会有很大提升，也能搞懂defer的底层原理了！</p><p>接着，我发现，春晖大神竟然和我在同一个公司！我在公司内网上搜到了他写的plan9汇编相关文章，发布到Go夜读的github上。我提前花时间预习完了文章，整理出了遇到的问题。</p><p>周六晚上9点准时开讲，曹大的准备很充分！原来1个小时的时间被拉长到了2个多小时，而曹大精力和反应一直很迅速，问的问题很快就能得到回答。我全程和曹大直接对话，感觉简直不要太爽！</p><p>这篇文章既是对这次夜读的总结，也是为了宣传一下Go夜读活动。那里是一群有追求的人，他们每周都会聚在一起，通过网络，探讨Go语言的方方面面。我相信，参与的人都会有很多不同的收获。</p><p>我直接参与的Go夜读活动有三期，一期分享，两期听讲，每次都有很多的收获。</p><h1 id="自我介绍的技巧"><a href="#自我介绍的技巧" class="headerlink" title="自我介绍的技巧"></a>自我介绍的技巧</h1><p>很多人都不知道怎么做好一个自我介绍，要么含糊其辞，介绍完大家都不知道你讲了什么；要么说了半天无效的信息，大家并不关心的事情，搞得很尴尬。 其实自我介绍没那么难，掌握套路后，是可以做得很好的！</p><p>我在上上期Go夜读分享的时候，用一张PPT完成了自我介绍。包含了四个方面：<code>个人基本信息</code>、<code>出现在此时此地的原因</code>、<code>我能带来的帮助</code>、<code>我希望得到的帮助</code>。</p><p><code>个人基本信息</code>包括你叫什么名字，是哪里人，在什么地方工作，毕业于哪个学校，有什么兴趣爱好……这些基本的属性。这些信息可以让大家快速形成对你的直观认识。</p><p><code>出现在此时此地的原因</code>，可以讲解你的故事。你在什么地方通过什么人知道了这个活动，然后因为什么打动你来参加……通过故事可以迅速拉近与现场其他参与者的距离。</p><p><code>我能带来的帮助</code>，参加活动的人都是想获取一些东西的：知识、经验、见闻等等。但是，我们不能只索取，不付出。因此，可以讲讲你可以提供的帮助。比如我可以联系场地，我会写宣传文章等等，你可以讲出你独特的价值。</p><p><code>我希望得到的帮助</code>。每个参与的人都希望从活动中获得自己想要的东西，正是因为此，这个活动对于参与者才有意义，也才会持续下去的动力。</p><p>这四个方面，可以组成一个非常精彩的自我介绍。它最早是我在听罗胖的《罗辑思维》听到的，我把它写进了我的<code>人生算法</code>里，今天推荐给大家。希望大家以后在需要自我介绍的场合有话可说，而且能说的精彩。</p><p><img src="https://user-images.githubusercontent.com/7698088/54608061-e3d77000-4a8a-11e9-95a3-7484f94b959b.png" alt="自我介绍"></p><h1 id="硬核知识点"><a href="#硬核知识点" class="headerlink" title="硬核知识点"></a>硬核知识点</h1><h2 id="什么是plan9汇编"><a href="#什么是plan9汇编" class="headerlink" title="什么是plan9汇编"></a>什么是plan9汇编</h2><p>我们知道，CPU是只认二进制指令的，也就是一串的0101；人类无法记住这些二进制码，于是发明了汇编语言。汇编语言实际上是二进制指令的文本形式，它与指令可以一一对应。</p><p>每一种CPU指令都是不一样的，因此对应的汇编语言也就不一样。人类写完汇编语言后，把它转换成二进制码，就可以被机器执行了。转换的动作由编译器完成。</p><blockquote><p>Go语言的编译器和汇编器都带了一个-S参数，可以查看生成的最终目标代码。通过对比目标代码和原始的Go语言或Go汇编语言代码的差异可以加深对底层实现的理解。</p></blockquote><p>Go汇编语言实际上来源于plan9汇编语言，而plan9汇编语言最初来源于Go语言作者之一的Ken Thompson为plan9系统所写的C语言编译器输出的汇编伪代码。这里强烈推荐一下春晖大神的新书《Go语言高级编程》，即将上市，电子版的点击阅读原文可以看到地址，书中有一整个章节讲Go的汇编语言，非常精彩！</p><p>理解Go的汇编语言，哪怕只是一点点，都能对Go的运行机制有更深入的理解。比如我们以前讲的defer，如果从Go源码编译后的汇编代码来看，就能深刻地掌握它的底层原理。再比如，很多文章都会分析Go的函数参数传递都是值传递，如果把汇编代码秀出来，很容易就能得出结论。</p><h2 id="汇编角度看函数调用及返回过程"><a href="#汇编角度看函数调用及返回过程" class="headerlink" title="汇编角度看函数调用及返回过程"></a>汇编角度看函数调用及返回过程</h2><p>假设我们有一个这样年幼无知的例子，求两个int的和，Go源码如下：</p><pre class=" language-golang"><code class="language-golang">package mainfunc main() {    _ = add(3,5)}func add(a, b int) int {    return a+b}</code></pre><p>使用如下命令得到汇编代码：</p><pre class=" language-shell"><code class="language-shell">go tool compile -S main.go</code></pre><p><code>go tool compile</code>命令用于调用Go语言提供的底层命令工具，其中<code>-S</code>参数表示输出汇编格式。</p><p>我们现在只关心add函数的汇编代码：</p><pre class=" language-asm"><code class="language-asm">"".add STEXT nosplit size=19 args=0x18 locals=0x0        0x0000 00000 (main.go:7)        TEXT    "".add(SB), NOSPLIT, $0-24        0x0000 00000 (main.go:7)        FUNCDATA        $0, gclocals·54241e171da8af6ae173d69da0236748(SB)        0x0000 00000 (main.go:7)        FUNCDATA        $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)        0x0000 00000 (main.go:7)        MOVQ    "".b+16(SP), AX        0x0005 00005 (main.go:7)        MOVQ    "".a+8(SP), CX        0x000a 00010 (main.go:8)        ADDQ    CX, AX        0x000d 00013 (main.go:8)        MOVQ    AX, "".~r2+24(SP)        0x0012 00018 (main.go:8)        RET</code></pre><p>看不懂没关系，我目前也不是全部都懂，但是对于理解一个函数调用的整体过程而言，足够了。</p><pre class=" language-asm"><code class="language-asm">0x0000 00000 (main.go:7)        TEXT    "".add(SB), NOSPLIT, $0-24</code></pre><p>这一行表示定义<code>add</code>这个函数，最后的数字<code>$0-24</code>，其中<code>0</code>表示函数栈帧大小为0；<code>24</code>表示参数及返回值的大小：参数是2个int型变量，返回值是1个int型变量，共24字节。</p><p>再看中间这四行：</p><pre class=" language-asm"><code class="language-asm">        0x0000 00000 (main.go:7)        MOVQ    "".b+16(SP), AX        0x0005 00005 (main.go:7)        MOVQ    "".a+8(SP), CX        0x000a 00010 (main.go:8)        ADDQ    CX, AX        0x000d 00013 (main.go:8)        MOVQ    AX, "".~r2+24(SP)</code></pre><p>代码片段中的第1行，将第2个参数<code>b</code>搬到<code>AX</code>寄存器；第2行将1个参数<code>a</code>搬到寄存器<code>CX</code>；第3行将<code>a</code>和<code>b</code>相加，相加的结果搬到<code>AX</code>；最后一行，将结果搬到返回参数的地址，这段汇编代码非常简单，来看一下函数调用者和被调者的栈帧图：</p><p>(SP)指栈顶，b+16(SP)表示裸骑1的位置，从SP往上增加16个字节，注意，前面的b仅表示一个标号；同样，a+8(SP)表示实参0；~r2+24(SP)则表示返回值的位置。</p><p>具体可以看下面的图：</p><p><img src="https://user-images.githubusercontent.com/7698088/54614544-8c8bcc80-4a97-11e9-9e68-61be5e6f5085.png" alt="add函数栈帧"></p><p>上面add函数的栈帧大小为0，其实更一般的调用者与被调用者的栈帧示意图如下：</p><p><img src="https://user-images.githubusercontent.com/7698088/54598545-aca99480-4a73-11e9-8870-99ab8ee9fcb7.png" alt="栈帧"></p><p>最后，执行<code>RET</code>指令。这一步把被调用函数<code>add</code>栈帧清零,接着，弹出栈顶的<code>返回地址</code>，把它赋给指令寄存器<code>rip</code>，而<code>返回地址</code>就是<code>main</code>函数里调用<code>add</code>函数的下一行。</p><p>于是，又回到了<code>main</code>函数的执行环境，<code>add</code>函数的栈帧也被销毁了。但是注意，这块内存是没有被清零的，清零动作是之后再次申请这块内存的时候要做的事。比如，声明了一个int型变量，它的默认值是0，清零的动作是在这里完成的。</p><p>这样，main函数完成了函数调用，也拿到了返回值，完美。</p><h2 id="汇编角度看slice"><a href="#汇编角度看slice" class="headerlink" title="汇编角度看slice"></a>汇编角度看slice</h2><p>再来看一个例子，我们来看看<code>slice</code>的底层到底是什么。</p><pre class=" language-golang"><code class="language-golang">package mainfunc main() {    s := make([]int, 3, 10)    _ = f(s)}func f(s []int) int {    return s[1]}</code></pre><p>用上面同样的命令得到汇编代码，我们只关注<code>f</code>函数的汇编代码：</p><pre class=" language-asm"><code class="language-asm">"".f STEXT nosplit size=53 args=0x20 locals=0x8        // 栈帧大小为8字节，参数和返回值为32字节        0x0000 00000 (main.go:8)        TEXT    "".f(SB), NOSPLIT, $8-32        // SP栈顶指针下移8字节        0x0000 00000 (main.go:8)        SUBQ    $8, SP        // 将BP寄存器的值入栈        0x0004 00004 (main.go:8)        MOVQ    BP, (SP)        // 将新的栈顶地址保存到BP寄存器        0x0008 00008 (main.go:8)        LEAQ    (SP), BP        0x000c 00012 (main.go:8)        FUNCDATA        $0, gclocals·4032f753396f2012ad1784f398b170f4(SB)        0x000c 00012 (main.go:8)        FUNCDATA        $1, gclocals·69c1753bd5f81501d95132d08af04464(SB)        // 取出slice的长度len        0x000c 00012 (main.go:8)        MOVQ    "".s+24(SP), AX        // 比较索引1是否超过len        0x0011 00017 (main.go:9)        CMPQ    AX, $1        // 如果超过len，越界了。跳转到46        0x0015 00021 (main.go:9)        JLS     46        // 将slice的数据首地址加载到AX寄存器        0x0017 00023 (main.go:9)        MOVQ    "".s+16(SP), AX        // 将第8byte地址的元素保存到AX寄存器，也就是salaries[1]        0x001c 00028 (main.go:9)        MOVQ    8(AX), AX        // 将结果拷贝到返回参数的位置（y）        0x0020 00032 (main.go:9)        MOVQ    AX, "".~r1+40(SP)        // 恢复BP的值        0x0025 00037 (main.go:9)        MOVQ    (SP), BP        // SP向上移动8个字节        0x0029 00041 (main.go:9)        ADDQ    $8, SP        // 返回        0x002d 00045 (main.go:9)        RET        0x002e 00046 (main.go:9)        PCDATA  $0, $1        // 越界，panic        0x002e 00046 (main.go:9)        CALL    runtime.panicindex(SB)        0x0033 00051 (main.go:9)        UNDEF        0x0000 48 83 ec 08 48 89 2c 24 48 8d 2c 24 48 8b 44 24  H...H.,$H.,$H.D$        0x0010 18 48 83 f8 01 76 17 48 8b 44 24 10 48 8b 40 08  .H...v.H.D$.H.@.        0x0020 48 89 44 24 28 48 8b 2c 24 48 83 c4 08 c3 e8 00  H.D$(H.,$H......        0x0030 00 00 00 0f 0b                                   .....        rel 47+4 t=8 runtime.panicindex+0</code></pre><p>通过上面的汇编代码，我们画出函数调用的栈帧图：</p><p><img src="https://user-images.githubusercontent.com/7698088/54599149-fe065380-4a74-11e9-800b-9a12db0c730c.png" alt="f函数栈帧"></p><p>我们可以清晰地看到，一个slice本质上是用一个数据首地址，一个长度Len，一个容量Cap。所以在参数是slice的函数里，对slice的操作会影响到实参的slice。</p><h1 id="正确参与Go夜读活动的方式"><a href="#正确参与Go夜读活动的方式" class="headerlink" title="正确参与Go夜读活动的方式"></a>正确参与Go夜读活动的方式</h1><p>最后再说一下Go夜读活动的方式和目标。引自Go夜读的github说明文件：</p><blockquote><p>由一个主讲人带着大家一起去阅读 Go 源代码，一起去啃那些难啃的算法、学习代码里面的奇淫技巧，遇到问题或者有疑惑了，我们可以一起去检索，解答这些问题。我们可以一起学习，共同成长。</p></blockquote><blockquote><p>我们希望可以推进大家深入了解 Go ，快速成长为资深的 Gopher 。我们希望每次来了的人和没来的人都能够有收获，成长。</p></blockquote><p>前面我说Go夜读活动的小伙伴是一群有追求的人，这里我也指出一些问题吧。就我参与的三期来看，虽然zoom接入人数很多，高峰期50+人，但是全过程大家交流比较少，基本上是主讲人一个人在那自嗨。春晖大佬讲的那期，只有我全程提问。感觉像是我们两个人在对话，我的问题弄清楚了，只是不知道其他的参与同学如何？</p><p>我再给分享者和参与者提一些建议吧：</p><p>对于分享者，事先做好充足的准备，可以在文章里列出主要的点，放在github里，参考春晖大佬的plan9汇编讲义；最重要的一点，分享前给大家提供一份预习资料。</p><p>对于参与者，能获得最多收获的方式就是会前预习，会中积极提问，会后复习总结发散。另外，强烈建议参与者会前要准备至少一个问题，有针对性地听，才会有收获。会中也要积极提问，这也是对主讲者的反馈，不至于主讲者觉得只有自己在对着电脑讲。</p><p>最后，欢迎每一个学习Go语言的同学都能来Go夜读看看！点击阅读原文可以看到文章里提到的所有资料，包括上期曹大plan9汇编的视频回放，不容错过！</p><p><img src="https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png" alt="QR"></p><h1 id="阅读原文"><a href="#阅读原文" class="headerlink" title="阅读原文"></a>阅读原文</h1><p><a href="https://github.com/developer-learning/reading-go">夜读地址</a><br><a href="https://github.com/cch123/asmshare/blob/master/layout.md">《plan9 汇编入门，带你打通应用和底层》讲义</a><br><a href="https://www.bilibili.com/video/av46494102" target="_blank" rel="noopener">《plan9 汇编入门，带你打通应用和底层》视频地址</a><br><a href="https://chai2010.cn/advanced-go-programming-book/" target="_blank" rel="noopener">曹大的Go高级编程书，纸质书即将出版</a><br><a href="https://github.com/cch123/golang-notes">曹大go源码阅读</a><br><a href="http://xargin.com/" target="_blank" rel="noopener">曹大博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
