<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="日拱一卒，终有所成！"><title>新官上任 —— Go sheduler 开始调度循环（五） | qcrao</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-144930666-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '6d54b847f6c5fb175b1ed2d153159403';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">新官上任 —— Go sheduler 开始调度循环（五）</h1><a id="logo" href="/.">qcrao</a><p class="description">码农桃花源</p></div><div id="nav-menu"><a href="/"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">新官上任 —— Go sheduler 开始调度循环（五）</h1><div class="post-meta">Sep 4, 2019<span> | </span><span class="category"><a href="/categories/编程语言/">编程语言</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2.4k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 10</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料"><span class="toc-number">1.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="post-content"><p>上一讲新创建了一个 goroutine，设置好了 sched 成员的 sp 和 pc 字段，并且将其添加到了 p0 的本地可运行队列，坐等调度器的调度。</p>
<p>我们继续看代码。搞了半天，我们其实还在 <code>runtime·rt0_go</code> 函数里，执行完 <code>runtime·newproc(SB)</code> 后，两条 POP 指令将之前为调用它构建的参数弹出栈。好消息是，最后就只剩下一个函数了：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start this M</span></span><br><span class="line"><span class="comment">// 主线程进入调度循环，运行刚刚创建的 goroutine</span></span><br><span class="line">CALL	runtime·mstart(SB)</span><br></pre></td></tr></table></figure>

<p>这到达了本系列的核心区，前面铺垫了半天，调度器终于要开始运转了。</p>
<p><code>mstart</code> 函数设置了 stackguard0 和 stackguard1 字段后，就直接调用 mstart1() 函数：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mstart1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 启动过程时 _g_ = m0.g0</span></span><br><span class="line">    _g_ := getg()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _g_ != _g_.m.g0 &#123;</span><br><span class="line">        throw(<span class="string">"bad runtime·mstart"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Record top of stack for use by mcall.</span></span><br><span class="line">    <span class="comment">// Once we call schedule we're never coming back,</span></span><br><span class="line">    <span class="comment">// so other calls can reuse this stack space.</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 一旦调用 schedule() 函数，永不返回</span></span><br><span class="line">    <span class="comment">// 所以栈帧可以被复用</span></span><br><span class="line">    gosave(&amp;_g_.m.g0.sched)</span><br><span class="line">    _g_.m.g0.sched.pc = ^<span class="keyword">uintptr</span>(<span class="number">0</span>) <span class="comment">// make sure it is never used</span></span><br><span class="line">    asminit()</span><br><span class="line">    minit()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ……………………</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行启动函数。初始化过程中，fn == nil</span></span><br><span class="line">    <span class="keyword">if</span> fn := _g_.m.mstartfn; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">        fn()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _g_.m.helpgc != <span class="number">0</span> &#123;</span><br><span class="line">        _g_.m.helpgc = <span class="number">0</span></span><br><span class="line">        stopm()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> _g_.m != &amp;m0 &#123;</span><br><span class="line">        acquirep(_g_.m.nextp.ptr())</span><br><span class="line">        _g_.m.nextp = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进入调度循环。永不返回</span></span><br><span class="line">    schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 <code>gosave</code> 函数来保存调度信息到 <code>g0.sched</code> 结构体，来看源码：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void gosave(Gobuf*)</span></span><br><span class="line"><span class="comment">// save state in Gobuf; setjmp</span></span><br><span class="line">TEXT runtime·gosave(SB), NOSPLIT, $<span class="number">0</span><span class="number">-8</span></span><br><span class="line">    <span class="comment">// 将 gobuf 赋值给 AX</span></span><br><span class="line">    MOVQ    buf+<span class="number">0</span>(FP), AX       <span class="comment">// gobuf</span></span><br><span class="line">    <span class="comment">// 取参数地址，也就是 caller 的 SP</span></span><br><span class="line">    LEAQ    buf+<span class="number">0</span>(FP), BX       <span class="comment">// caller's SP</span></span><br><span class="line">    <span class="comment">// 保存 caller's SP，再次运行时的栈顶</span></span><br><span class="line">    MOVQ    BX, gobuf_sp(AX)</span><br><span class="line">    MOVQ    <span class="number">0</span>(SP), BX       <span class="comment">// caller's PC</span></span><br><span class="line">    <span class="comment">// 保存 caller's PC，再次运行时的指令地址</span></span><br><span class="line">    MOVQ    BX, gobuf_pc(AX)</span><br><span class="line">    MOVQ    $<span class="number">0</span>, gobuf_ret(AX)</span><br><span class="line">    MOVQ    BP, gobuf_bp(AX)</span><br><span class="line">    <span class="comment">// Assert ctxt is zero. See func save.</span></span><br><span class="line">    MOVQ    gobuf_ctxt(AX), BX</span><br><span class="line">    TESTQ   BX, BX</span><br><span class="line">    JZ  <span class="number">2</span>(PC)</span><br><span class="line">    CALL    runtime·badctxt(SB)</span><br><span class="line">    <span class="comment">// 获取 tls</span></span><br><span class="line">    get_tls(CX)</span><br><span class="line">    <span class="comment">// 将 g 的地址存入 BX</span></span><br><span class="line">    MOVQ    g(CX), BX</span><br><span class="line">    <span class="comment">// 保存 g 的地址</span></span><br><span class="line">    MOVQ    BX, gobuf_g(AX)</span><br><span class="line">    RET</span><br></pre></td></tr></table></figure>

<p>主要是设置了 g0.sched.sp 和 g0.sched.pc，前者指向 mstart1 函数栈上参数的位置，后者则指向 gosave 函数返回后的下一条指令。如下图：</p>
<p><img src="https://user-images.githubusercontent.com/7698088/64071341-cef24000-ccaa-11e9-896e-94c3511526b9.png" alt="调用 gosave 函数后"></p>
<p>图中 sched.pc 并不直接指向返回地址，所以图中的虚线并没有箭头。</p>
<p>接下来，进入 schedule 函数，永不返回。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行一轮调度器的工作：找到一个 runnable 的 goroutine，并且执行它</span></span><br><span class="line"><span class="comment">// 永不返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// _g_ = 每个工作线程 m 对应的 g0，初始化时是 m0 的 g0</span></span><br><span class="line">    _g_ := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ……………………</span></span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">    <span class="comment">// ……………………</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> gp *g</span><br><span class="line">    <span class="keyword">var</span> inheritTime <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ……………………</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// Check the global runnable queue once in a while to ensure fairness.</span></span><br><span class="line">        <span class="comment">// Otherwise two goroutines can completely occupy the local runqueue</span></span><br><span class="line">        <span class="comment">// by constantly respawning each other.</span></span><br><span class="line">        <span class="comment">// 为了公平，每调用 schedule 函数 61 次就要从全局可运行 goroutine 队列中获取</span></span><br><span class="line">        <span class="keyword">if</span> _g_.m.p.ptr().schedtick%<span class="number">61</span> == <span class="number">0</span> &amp;&amp; sched.runqsize &gt; <span class="number">0</span> &#123;</span><br><span class="line">            lock(&amp;sched.lock)</span><br><span class="line">            <span class="comment">// 从全局队列最大获取 1 个 gorutine</span></span><br><span class="line">            gp = globrunqget(_g_.m.p.ptr(), <span class="number">1</span>)</span><br><span class="line">            unlock(&amp;sched.lock)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 P 本地获取 G 任务</span></span><br><span class="line">    <span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">        gp, inheritTime = runqget(_g_.m.p.ptr())</span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &amp;&amp; _g_.m.spinning &#123;</span><br><span class="line">            throw(<span class="string">"schedule: spinning with local work"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 从本地运行队列和全局运行队列都没有找到需要运行的 goroutine，</span></span><br><span class="line">        <span class="comment">// 调用 findrunnable 函数从其它工作线程的运行队列中偷取，如果偷不到，则当前工作线程进入睡眠</span></span><br><span class="line">        <span class="comment">// 直到获取到 runnable goroutine 之后 findrunnable 函数才会返回。</span></span><br><span class="line">        gp, inheritTime = findrunnable() <span class="comment">// blocks until work is available</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This thread is going to run a goroutine and is not spinning anymore,</span></span><br><span class="line">    <span class="comment">// so if it was marked as spinning we need to reset it now and potentially</span></span><br><span class="line">    <span class="comment">// start a new spinning M.</span></span><br><span class="line">    <span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">        resetspinning()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> gp.lockedm != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// Hands off own p to the locked m,</span></span><br><span class="line">        <span class="comment">// then blocks waiting for a new p.</span></span><br><span class="line">        startlockedm(gp)</span><br><span class="line">        <span class="keyword">goto</span> top</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 goroutine 任务函数</span></span><br><span class="line">    <span class="comment">// 当前运行的是 runtime 的代码，函数调用栈使用的是 g0 的栈空间</span></span><br><span class="line">    <span class="comment">// 调用 execute 切换到 gp 的代码和栈空间去运行</span></span><br><span class="line">    execute(gp, inheritTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 <code>runqget</code>，从 P 本地可运行队列先选出一个可运行的 goroutine；为了公平，调度器每调度 61 次的时候，都会尝试从全局队列里取出待运行的 goroutine 来运行，调用 <code>globrunqget</code>；如果还没找到，就要去其他 P 里面去偷一些 goroutine 来执行，调用 <code>findrunnable</code> 函数。</p>
<p>经过千辛万苦，终于找到了可以运行的 goroutine，调用 <code>execute(gp, inheritTime)</code> 切换到选出的 goroutine 栈执行，调度器的调度次数会在这里更新，源码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调度 gp 在当前 M 上运行</span></span><br><span class="line"><span class="comment">// 如果 inheritTime 为真，gp 执行当前的时间片</span></span><br><span class="line"><span class="comment">// 否则，开启一个新的时间片</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//go:yeswritebarrierrec </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">(gp *g, inheritTime <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// g0</span></span><br><span class="line">    _g_ := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 gp 的状态改为 running</span></span><br><span class="line">    casgstatus(gp, _Grunnable, _Grunning)</span><br><span class="line">    gp.waitsince = <span class="number">0</span></span><br><span class="line">    gp.preempt = <span class="literal">false</span></span><br><span class="line">    gp.stackguard0 = gp.stack.lo + _StackGuard</span><br><span class="line">    <span class="keyword">if</span> !inheritTime &#123;</span><br><span class="line">        <span class="comment">// 调度器调度次数增加 1</span></span><br><span class="line">        _g_.m.p.ptr().schedtick++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 gp 和 m 关联起来</span></span><br><span class="line">    _g_.m.curg = gp</span><br><span class="line">    gp.m = _g_.m</span><br><span class="line"></span><br><span class="line">    <span class="comment">// …………………………</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// gogo 完成从 g0 到 gp 真正的切换</span></span><br><span class="line">    <span class="comment">// CPU 执行权的转让以及栈的切换</span></span><br><span class="line">    <span class="comment">// 执行流的切换从本质上来说就是 CPU 寄存器以及函数调用栈的切换，</span></span><br><span class="line">    <span class="comment">// 然而不管是 go 还是 c 这种高级语言都无法精确控制 CPU 寄存器的修改，</span></span><br><span class="line">    <span class="comment">// 因而高级语言在这里也就无能为力了，只能依靠汇编指令来达成目的</span></span><br><span class="line">    gogo(&amp;gp.sched)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 gp 的状态改为 <code>_Grunning</code>，将 m 和 gp 相互关联起来。最后，调用 <code>gogo</code> 完成从 g0 到 gp 的切换，CPU 的执行权将从 g0 转让到 gp。 <code>gogo</code> 函数用汇编语言写成，原因如下：</p>
<blockquote>
<p><code>gogo</code> 函数也是通过汇编语言编写的，这里之所以需要使用汇编，是因为 goroutine 的调度涉及不同执行流之间的切换。</p>
</blockquote>
<blockquote>
<p>前面我们在讨论操作系统切换线程时已经看到过，执行流的切换从本质上来说就是 CPU 寄存器以及函数调用栈的切换，然而不管是 go 还是 c 这种高级语言都无法精确控制 CPU 寄存器，因而高级语言在这里也就无能为力了，只能依靠汇编指令来达成目的。</p>
</blockquote>
<p>上面引用的是公众号“go 语言核心编程技术”调度器系列文章的一章，很赞。</p>
<p>继续看 <code>gogo</code> 函数的实现，传入 <code>&amp;gp.sched</code> 参数，源码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·gogo(SB), NOSPLIT, $<span class="number">16</span><span class="number">-8</span></span><br><span class="line">    <span class="comment">// 0(FP) 表示第一个参数，即 buf = &amp;gp.sched</span></span><br><span class="line">    MOVQ    buf+<span class="number">0</span>(FP), BX       <span class="comment">// gobuf</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ……………………</span></span><br><span class="line">    </span><br><span class="line">    MOVQ    buf+<span class="number">0</span>(FP), BX</span><br><span class="line"></span><br><span class="line">nilctxt:</span><br><span class="line">    <span class="comment">// DX = gp.sched.g</span></span><br><span class="line">    MOVQ    gobuf_g(BX), DX</span><br><span class="line">    MOVQ    <span class="number">0</span>(DX), CX       <span class="comment">// make sure g != nil</span></span><br><span class="line">    get_tls(CX)</span><br><span class="line">    <span class="comment">// 将 g 放入到 tls[0]</span></span><br><span class="line">    <span class="comment">// 把要运行的 g 的指针放入线程本地存储，这样后面的代码就可以通过线程本地存储</span></span><br><span class="line">    <span class="comment">// 获取到当前正在执行的 goroutine 的 g 结构体对象，从而找到与之关联的 m 和 p</span></span><br><span class="line">    <span class="comment">// 运行这条指令之前，线程本地存储存放的是 g0 的地址</span></span><br><span class="line">    MOVQ    DX, g(CX)</span><br><span class="line">    <span class="comment">// 把 CPU 的 SP 寄存器设置为 sched.sp，完成了栈的切换</span></span><br><span class="line">    MOVQ    gobuf_sp(BX), SP    <span class="comment">// restore SP</span></span><br><span class="line">    <span class="comment">// 恢复调度上下文到CPU相关寄存器</span></span><br><span class="line">    MOVQ    gobuf_ret(BX), AX</span><br><span class="line">    MOVQ    gobuf_ctxt(BX), DX</span><br><span class="line">    MOVQ    gobuf_bp(BX), BP</span><br><span class="line">    <span class="comment">// 清空 sched 的值，因为我们已把相关值放入 CPU 对应的寄存器了，不再需要，这样做可以少 GC 的工作量</span></span><br><span class="line">    MOVQ    $<span class="number">0</span>, gobuf_sp(BX)    <span class="comment">// clear to help garbage collector</span></span><br><span class="line">    MOVQ    $<span class="number">0</span>, gobuf_ret(BX)</span><br><span class="line">    MOVQ    $<span class="number">0</span>, gobuf_ctxt(BX)</span><br><span class="line">    MOVQ    $<span class="number">0</span>, gobuf_bp(BX)</span><br><span class="line">    <span class="comment">// 把 sched.pc 值放入 BX 寄存器</span></span><br><span class="line">    MOVQ    gobuf_pc(BX), BX</span><br><span class="line">    <span class="comment">// JMP 把 BX 寄存器的包含的地址值放入 CPU 的 IP 寄存器，于是，CPU 跳转到该地址继续执行指令</span></span><br><span class="line">    JMP BX</span><br></pre></td></tr></table></figure>

<p>注释地比较详细了。核心的地方是：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOVQ    gobuf_g(BX), DX</span><br><span class="line"><span class="comment">// ……</span></span><br><span class="line">get_tls(CX)</span><br><span class="line">MOVQ    DX, g(CX)</span><br></pre></td></tr></table></figure>

<p>第一行，将 gp.sched.g 保存到 DX 寄存器；第二行，我们见得已经比较多了，<code>get_tls</code> 将 tls 保存到 CX 寄存器，再将 gp.sched.g 放到 tls[0] 处。这样，当下次再调用 <code>get_tls</code> 时，取出的就是 gp，而不再是 g0，这一行完成从 g0 栈切换到 gp。</p>
<p>可能需要提一下的是，Go plan9 汇编中的一些奇怪的符号：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOVQ    buf+<span class="number">0</span>(FP), BX  # &amp;gp.sched --&gt; BX</span><br></pre></td></tr></table></figure>

<p><code>FP</code> 是个伪奇存器，前面加 0 表示是第一个寄存器，表示参数的位置，最前面的 buf 表示一个符号。关于 Go 汇编语言的一些知识，可以参考曹大在夜读上的分享和《Go 语言高级编程》的相关章节，地址见参考资料。</p>
<p>接下来，将 gp.sched 的相关成员恢复到 CPU 对应的寄存器。最重要的是 sched.sp 和 sched.pc，前者被恢复到了 SP 寄存器，后者被保存到 BX 寄存器，最后一条跳转指令跳转到新的地址开始执行。通过之前的文章，我们知道，这里保存的就是 <code>runtime.main</code> 函数的地址。</p>
<p>最终，调度器完成了这个值得铭记的时刻，从 g0 转到 gp，开始执行 <code>runtime.main</code> 函数。</p>
<p>用一张流程图总结一下从 g0 切换到 main goroutine 的过程：</p>
<p><img src="https://user-images.githubusercontent.com/7698088/63644111-b6ff4700-c713-11e9-8961-664ec101030a.png" alt="从 g0 到 gp"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【欧神 调度循环】<a href="https://github.com/changkun/go-under-the-hood/blob/master/book/zh-cn/part2runtime/ch06sched/exec.md" target="_blank" rel="noopener">https://github.com/changkun/go-under-the-hood/blob/master/book/zh-cn/part2runtime/ch06sched/exec.md</a></p>
<p>【go 语言核心编程技术 调度器系列】<a href="https://mp.weixin.qq.com/s/8eJm5hjwKXya85VnT4y8Cw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/8eJm5hjwKXya85VnT4y8Cw</a></p>
<p>【曹大 Go plan9 汇编】<a href="https://github.com/cch123/asmshare/blob/master/layout.md" target="_blank" rel="noopener">https://github.com/cch123/asmshare/blob/master/layout.md</a></p>
<p>【Go 语言高级编程】<a href="https://chai2010.cn/advanced-go-programming-book/ch3-asm/readme.html" target="_blank" rel="noopener">https://chai2010.cn/advanced-go-programming-book/ch3-asm/readme.html</a></p>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>饶全成</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/09/04/go-scheduler-start-schedule-cycle/">https://qcrao.com/2019/09/04/go-scheduler-start-schedule-cycle/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本文章著作权归作者所有，任何形式的转载都请注明出处。</li></ul></div><br><div class="tags"><a href="/tags/golang/">golang</a></div><div class="post-nav"><a class="pre" href="/2019/09/06/go-scheduler-life-of-goroutine/">千难万险 —— goroutine 从生到死（六）</a><a class="next" href="/2019/09/04/go-scheduler-stack-switch-between-g0-and-user-goroutine/">偷天换日 —— g0 栈和用户栈如何完成切换？（四）</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '7e91ec94cfb5913e3d6b',
  clientSecret: '902f91e26bc75c9f8d912557492476d0be254667',
  repo: 'qcrao.github.io',
  owner: 'qcrao',
  admin: ['qcrao'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://qcrao.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/求职/">求职</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程语言/">编程语言</a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a><span class="category-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/golang/" style="font-size: 15px;">golang</a> <a href="/tags/协议/" style="font-size: 15px;">协议</a> <a href="/tags/内存重排/" style="font-size: 15px;">内存重排</a> <a href="/tags/简历/" style="font-size: 15px;">简历</a> <a href="/tags/编译原理/" style="font-size: 15px;">编译原理</a> <a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/09/06/go-scheduler-state-diagram-of-gpm/">意犹未尽 —— GPM 的状态流转（十）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/06/go-scheduler-what-sysmon-does/">忠于职守 —— sysmon 线程到底做了什么？（九）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/06/go-scheduler-m-finds-work/">锲而不舍 —— M 是怎样找工作的？（八）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/06/go-scheduler-cycle-of-schedul/">生生死死 —— schedule 的轮回（七）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/06/go-scheduler-life-of-goroutine/">千难万险 —— goroutine 从生到死（六）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/04/go-scheduler-start-schedule-cycle/">新官上任 —— Go sheduler 开始调度循环（五）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/04/go-scheduler-stack-switch-between-g0-and-user-goroutine/">偷天换日 —— g0 栈和用户栈如何完成切换？（四）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/04/go-scheduler-the-birth-of-main-goroutine/">粉墨登场 —— main goroutine 的诞生（三）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/04/go-scheduler-init/">开天辟地 —— Go scheduler 初始化（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/04/go-scheduler-what-is-gpm/">三足鼎立 —— GPM 到底是什么？（一）</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/qcrao/Go-Questions" title="Go-Questions" target="_blank">Go-Questions</a><ul></ul><a href="http://xargin.com/" title="No HeadBack" target="_blank">No HeadBack</a><ul></ul><a href="https://draveness.me/" title="面向信仰编程" target="_blank">面向信仰编程</a><ul></ul><a href="https://eddycjy.gitbook.io/golang/" title="跟煎鱼学 Go" target="_blank">跟煎鱼学 Go</a><ul></ul><a href="http://lessisbetter.site/" title="大彬 - Less is better" target="_blank">大彬 - Less is better</a><ul></ul><a href="https://wujunze.com/" title="好未来大佬 Panda" target="_blank">好未来大佬 Panda</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async="async"></script><span> | </span><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span> | </span><i class="fa fa-keyboard-o"></i><span class="post-count">161.3k</span><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">qcrao.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>