<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="日拱一卒，终有所成！"><title>锲而不舍 —— M 是怎样找工作的？（八） | qcrao</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-144930666-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '6d54b847f6c5fb175b1ed2d153159403';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">锲而不舍 —— M 是怎样找工作的？（八）</h1><a id="logo" href="/.">qcrao</a><p class="description">码农桃花源</p></div><div id="nav-menu"><a href="/"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">锲而不舍 —— M 是怎样找工作的？（八）</h1><div class="post-meta">Sep 6, 2019<span> | </span><span class="category"><a href="/categories/编程语言/">编程语言</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 5.2k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 21</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料"><span class="toc-number">1.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="post-content"><p>在 schedule 函数中，我们简单提过找一个 runnable goroutine 的过程，这一讲我们来详细分析源码。</p>
<p>工作线程 M 费尽心机也要找到一个可运行的 goroutine，这是它的工作和职责，不达目的，绝不罢体，这种锲而不舍的精神值得每个人学习。</p>
<p>共经历三个过程：先从本地队列找，定期会从全局队列找，最后实在没办法，就去别的 P 偷。如下图所示：</p>
<p><img src="https://user-images.githubusercontent.com/7698088/63647181-f21f6b80-c74f-11e9-9c67-4267e8fb5c87.png" alt="M 找工作的过程"></p>
<p>先看第一个：从 P 本地队列找。源码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从本地可运行队列里找到一个 g</span></span><br><span class="line"><span class="comment">// 如果 inheritTime 为真，gp 应该继承这个时间片，否则，新开启一个时间片</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runqget</span><span class="params">(_p_ *p)</span> <span class="params">(gp *g, inheritTime <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// If there's a runnext, it's the next G to run.</span></span><br><span class="line">	<span class="comment">// 如果 runnext 不为空，则 runnext 是下一个待运行的 G</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		next := _p_.runnext</span><br><span class="line">		<span class="keyword">if</span> next == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// 为空，则直接跳出循环</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 再次比较 next 是否没有变化</span></span><br><span class="line">		<span class="keyword">if</span> _p_.runnext.cas(next, <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// 如果没有变化，则返回 next 所指向的 g。且需要继承时间片</span></span><br><span class="line">			<span class="keyword">return</span> next.ptr(), <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 获取队列头</span></span><br><span class="line">		h := atomic.Load(&amp;_p_.runqhead) <span class="comment">// load-acquire, synchronize with other consumers</span></span><br><span class="line">		<span class="comment">// 获取队列尾</span></span><br><span class="line">		t := _p_.runqtail</span><br><span class="line">		<span class="keyword">if</span> t == h &#123;</span><br><span class="line">			<span class="comment">// 头和尾相等，说明本地队列为空，找不到 g</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 获取队列头的 g</span></span><br><span class="line">		gp := _p_.runq[h%<span class="keyword">uint32</span>(<span class="built_in">len</span>(_p_.runq))].ptr()</span><br><span class="line">		<span class="comment">// 原子操作，防止这中间被其他线程因为偷工作而修改</span></span><br><span class="line">		<span class="keyword">if</span> atomic.Cas(&amp;_p_.runqhead, h, h+<span class="number">1</span>) &#123; <span class="comment">// cas-release, commits consume</span></span><br><span class="line">			<span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个源码结构比较简单，主要是两个 for 循环。</p>
<p>第一个 for 循环尝试返回 P 的 runnext 成员，因为 runnext 具有最高的运行优先级，因此要首先尝试获取 runnext。当发现 runnext 为空时，直接跳出循环，进入第二个。否则，用原子操作获取 runnext，并将其值修改为 0，也就是空。这里用到原子操作的原因是防止在这个过程中，有其他线程过来“偷工作”，导致并发修改 runnext 成员。</p>
<p>第二个 for 循环则是在尝试获取 runnext 成员失败后，尝试从本地队列中返回队列头的 goroutine。同样，先用原子操作获取队列头，使用原子操作的原因同样是防止其他线程“偷工作”时并发对队列头的并发写操作。之后，直接获取队列尾，因为不担心其他线程同时更改，所以直接获取。注意，“偷工作”时只会修改队列头。</p>
<p>比较队列头和队列尾，如果两者相等，说明 P 本地队列没有可运行的 goroutine，直接返回空。否则，算出队列头指向的 goroutine，再用一个 CAS 原子操作来尝试修改队列头，使用原子操作的原因同上。</p>
<p>从本地队列获取可运行 goroutine 的过程比较简单，我们再来看从全局队列获取 goroutine 的过程。在 schedule 函数中调用 <code>globrunqget</code> 的代码：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了公平，每调用 schedule 函数 61 次就要从全局可运行 goroutine 队列中获取</span></span><br><span class="line"><span class="keyword">if</span> _g_.m.p.ptr().schedtick%<span class="number">61</span> == <span class="number">0</span> &amp;&amp; sched.runqsize &gt; <span class="number">0</span> &#123;</span><br><span class="line">	lock(&amp;sched.lock)</span><br><span class="line">	<span class="comment">// 从全局队列最大获取 1 个 gorutine</span></span><br><span class="line">	gp = globrunqget(_g_.m.p.ptr(), <span class="number">1</span>)</span><br><span class="line">	unlock(&amp;sched.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这说明，并不是每次调度都会从全局队列获取可运行的 goroutine。实际情況是调度器每调度 61 次并且全局队列有可运行 goroutine 的情况下才会调用 <code>globrunqget</code> 函数尝试从全局获取可运行 goroutine。毕竟，从全局获取需要上锁，这个开销可就大了，能不做就不做。</p>
<p>我们来详细看下 <code>globrunqget</code> 的源码：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试从全局队列里获取可运行的 goroutine 队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">globrunqget</span><span class="params">(_p_ *p, max <span class="keyword">int32</span>)</span> *<span class="title">g</span></span> &#123;</span><br><span class="line">	<span class="comment">// 如果队列大小为 0</span></span><br><span class="line">	<span class="keyword">if</span> sched.runqsize == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据 p 的数量平分全局运行队列中的 goroutines</span></span><br><span class="line">	n := sched.runqsize/gomaxprocs + <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> n &gt; sched.runqsize &#123;</span><br><span class="line">		n = sched.runqsize <span class="comment">// 如果 gomaxprocs 为 1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 修正"偷"的数量</span></span><br><span class="line">	<span class="keyword">if</span> max &gt; <span class="number">0</span> &amp;&amp; n &gt; max &#123;</span><br><span class="line">		n = max</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 最多只能"偷"本地工作队列一半的数量</span></span><br><span class="line">	<span class="keyword">if</span> n &gt; <span class="keyword">int32</span>(<span class="built_in">len</span>(_p_.runq))/<span class="number">2</span> &#123;</span><br><span class="line">		n = <span class="keyword">int32</span>(<span class="built_in">len</span>(_p_.runq)) / <span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新全局可运行队列长度</span></span><br><span class="line">	sched.runqsize -= n</span><br><span class="line">	<span class="comment">// 如果都要被"偷"走，修改队列尾</span></span><br><span class="line">	<span class="keyword">if</span> sched.runqsize == <span class="number">0</span> &#123;</span><br><span class="line">		sched.runqtail = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取队列头指向的 goroutine</span></span><br><span class="line">	gp := sched.runqhead.ptr()</span><br><span class="line">	<span class="comment">// 移动队列头</span></span><br><span class="line">	sched.runqhead = gp.schedlink</span><br><span class="line">	n--</span><br><span class="line">	<span class="keyword">for</span> ; n &gt; <span class="number">0</span>; n-- &#123;</span><br><span class="line">		<span class="comment">// 获取当前队列头</span></span><br><span class="line">		gp1 := sched.runqhead.ptr()</span><br><span class="line">		<span class="comment">// 移动队列头</span></span><br><span class="line">		sched.runqhead = gp1.schedlink</span><br><span class="line">		<span class="comment">// 尝试将 gp1 放入 P 本地，使全局队列得到更多的执行机会</span></span><br><span class="line">		runqput(_p_, gp1, <span class="literal">false</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回最开始获取到的队列头所指向的 goroutine</span></span><br><span class="line">	<span class="keyword">return</span> gp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码比较简单。首先根据全局队列的可运行 goroutine 长度和 P 的总数，来计算一个数值，表示每个 P 可平均分到的 goroutine 数量。</p>
<p>然后根据函数参数中的 max 以及 P 本地队列的长度来决定把多少全局队列中的 goroutine 转移到 P 本地。</p>
<p>最后，for 循环挨个把全局队列中 n-1 个 goroutine 转移到本地，并且返回最开始获取到的队列头所指向的 goroutine，毕竟它最需要得到运行的机会。</p>
<p>把全局队列中的可运行 goroutine 转移到本地队列，给了全局队列中可运行 goroutine 运行的机会，不然全局队列中的 goroutine 一直得不到运行。</p>
<p>最后，我们继续看第三个过程，从其他 P “偷工作”：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从本地运行队列和全局运行队列都没有找到需要运行的 goroutine，</span></span><br><span class="line"><span class="comment">// 调用 findrunnable 函数从其它工作线程的运行队列中偷取，如果偷不到，则当前工作线程进入睡眠</span></span><br><span class="line"><span class="comment">// 直到获取到 runnable goroutine 之后 findrunnable 函数才会返回。</span></span><br><span class="line"><span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">	gp, inheritTime = findrunnable() <span class="comment">// blocks until work is available</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是整个找工作过程最复杂的部分：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从其他地方找 goroutine 来执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findrunnable</span><span class="params">()</span> <span class="params">(gp *g, inheritTime <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">    _p_ := _g_.m.p.ptr()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ……………………</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// local runq</span></span><br><span class="line">    <span class="comment">// 从本地队列获取</span></span><br><span class="line">    <span class="keyword">if</span> gp, inheritTime := runqget(_p_); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gp, inheritTime</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// global runq</span></span><br><span class="line">    <span class="comment">// 从全局队列获取</span></span><br><span class="line">    <span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        gp := globrunqget(_p_, <span class="number">0</span>)</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ……………………</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Steal work from other P's.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果其他的 P 都处于空闲状态，那肯定没有其他工作要做</span></span><br><span class="line">    procs := <span class="keyword">uint32</span>(gomaxprocs)</span><br><span class="line">    <span class="keyword">if</span> atomic.Load(&amp;sched.npidle) == procs<span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> stop</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有很多工作线程在找工作，那我就停下休息。避免消耗太多 CPU</span></span><br><span class="line">    <span class="keyword">if</span> !_g_.m.spinning &amp;&amp; <span class="number">2</span>*atomic.Load(&amp;sched.nmspinning) &gt;= procs-atomic.Load(&amp;sched.npidle) &#123;</span><br><span class="line">        <span class="keyword">goto</span> stop</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !_g_.m.spinning &#123;</span><br><span class="line">        <span class="comment">// 设置自旋状态为 true</span></span><br><span class="line">        _g_.m.spinning = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 自旋状态数加 1</span></span><br><span class="line">        atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从其它 p 的本地运行队列盗取 goroutine</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> enum := stealOrder.start(fastrand()); !enum.done(); enum.next() &#123;</span><br><span class="line">            <span class="comment">// ……………………</span></span><br><span class="line">            stealRunNextG := i &gt; <span class="number">2</span> <span class="comment">// first look for ready queues with more than 1 g</span></span><br><span class="line">            <span class="keyword">if</span> gp := runqsteal(_p_, allp[enum.position()], stealRunNextG); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">stop:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ……………………</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// return P and block</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> || _p_.runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">goto</span> top</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">        gp := globrunqget(_p_, <span class="number">0</span>)</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前工作线程解除与 p 之间的绑定，准备去休眠</span></span><br><span class="line">    <span class="keyword">if</span> releasep() != _p_ &#123;</span><br><span class="line">        throw(<span class="string">"findrunnable: wrong p"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把 p 放入空闲队列</span></span><br><span class="line">    pidleput(_p_)</span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    wasSpinning := _g_.m.spinning</span><br><span class="line">    <span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">        <span class="comment">// m 即将睡眠，不再处于自旋</span></span><br><span class="line">        _g_.m.spinning = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">int32</span>(atomic.Xadd(&amp;sched.nmspinning, <span class="number">-1</span>)) &lt; <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">"findrunnable: negative nmspinning"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check all runqueues once again</span></span><br><span class="line">    <span class="comment">// 休眠之前再检查一下所有的 p，看一下是否有工作要做</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(gomaxprocs); i++ &#123;</span><br><span class="line">        _p_ := allp[i]</span><br><span class="line">        <span class="keyword">if</span> _p_ != <span class="literal">nil</span> &amp;&amp; !runqempty(_p_) &#123;</span><br><span class="line">            lock(&amp;sched.lock)</span><br><span class="line">            _p_ = pidleget()</span><br><span class="line">            unlock(&amp;sched.lock)</span><br><span class="line">            <span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span><br><span class="line">                acquirep(_p_)</span><br><span class="line">                <span class="keyword">if</span> wasSpinning &#123;</span><br><span class="line">                    _g_.m.spinning = <span class="literal">true</span></span><br><span class="line">                    atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">goto</span> top</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ……………………</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 休眠</span></span><br><span class="line">    stopm()</span><br><span class="line">    <span class="keyword">goto</span> top</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这部分也是最能说明 M 找工作的锲而不舍精神：尽力去各个运行队列中寻找 goroutine，如果实在找不到则进入睡眠状态，等待有工作时，被其他 M 唤醒。</p>
<p>先获取当前指向的 g，也就是 g0，然后拿到其绑定的 p，即 <code>_p_</code>。</p>
<p>首先再次尝试从 <code>_p_</code> 本地队列获取 goroutine，如果没有获取到，则尝试从全局队列获取。如果还没有获取到就会尝试去“偷”了，这也是没有办法的事。</p>
<p>不过，在偷之前，先看大的局势。如果其他所有的 P 都处于空闲状态，就说明其他 P 肯定没有工作可做，就没必要再去偷了，毕竟“地主家也没有余粮了”，跳到 stop 部分。接着再看下当前正在“偷工作”的线程数量“太多了”，就没必要扎堆了，这么多人，竞争肯定大，工作肯定不好找，也不好偷。</p>
<p>在真正的“偷”工作之前，把自己的自旋状态设置为 true，全局自旋数量加 1。</p>
<p>终于到了“偷工作”的部分了，好紧张！整个过程由两层 for 循环组成，外层控制尝试偷的次数，内层控制“偷”的顺序，并真正的去“偷”。实际上，内层会遍历所有的 P，因此，整体看来，会尝试 4 次扫遍所有的 P，并去“偷工作”，是不是非常有毅力！</p>
<p>第二层的循环并不是每次都按一个固定的顺序去遍历所有的 P，这样不太科学，而是使用了一些方法，“随机”地遍历。具体是使用了下面这个变量：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stealOrder randomOrder</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> randomOrder <span class="keyword">struct</span> &#123;</span><br><span class="line">	count    <span class="keyword">uint32</span></span><br><span class="line">	coprimes []<span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化的时候会给 count 赋一个值，例如 8，根据 count 计算出 coprimes，里面的元素是小于 count 的值，且和 8 互质，算出来是：[1, 3, 5, 7]。</p>
<p>第二层循环，开始随机给一个值，例如 2，则第一个访问的 P 就是 P2；从 coprimes 里取出索引为 2 的值为 5，那么，第二个访问的 P 索引就是 2+5=7；依此类推，第三个就是 7+5=12，和 count 做一个取余操作，即 12%8=4……</p>
<p>在最后一次遍历所有的 P 的过程中，连人家的 runnext 也要尝试偷过来，毕竟前三次的失败经验证明，工作太不好“偷”了，民不聊生啊，只能做得绝一点了，<code>stealRunNextG</code> 控制是否要打 runnext 的主意：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stealRunNextG := i &gt; <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>确定好准备偷的对象 <code>allp[enum.position()</code> 之后，调用 <code>runqsteal(_p_, allp[enum.position()], stealRunNextG)</code> 函数执行。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 p2 偷走一半的工作放到 _p_ 的本地</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runqsteal</span><span class="params">(_p_, p2 *p, stealRunNextG <span class="keyword">bool</span>)</span> *<span class="title">g</span></span> &#123;</span><br><span class="line">    <span class="comment">// 队尾</span></span><br><span class="line">    t := _p_.runqtail</span><br><span class="line">    <span class="comment">// 从 p2 偷取工作，放到 _p_.runq 的队尾</span></span><br><span class="line">    n := runqgrab(p2, &amp;_p_.runq, t, stealRunNextG)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    n--</span><br><span class="line">    <span class="comment">// 找到最后一个 g，准备返回</span></span><br><span class="line">    gp := _p_.runq[(t+n)%<span class="keyword">uint32</span>(<span class="built_in">len</span>(_p_.runq))].ptr()</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 说明只偷了一个 g</span></span><br><span class="line">        <span class="keyword">return</span> gp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 队列头</span></span><br><span class="line">    h := atomic.Load(&amp;_p_.runqhead) <span class="comment">// load-acquire, synchronize with consumers</span></span><br><span class="line">    <span class="comment">// 判断是否偷太多了</span></span><br><span class="line">    <span class="keyword">if</span> t-h+n &gt;= <span class="keyword">uint32</span>(<span class="built_in">len</span>(_p_.runq)) &#123;</span><br><span class="line">        throw(<span class="string">"runqsteal: runq overflow"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新队尾，将偷来的工作加入队列</span></span><br><span class="line">    atomic.Store(&amp;_p_.runqtail, t+n) <span class="comment">// store-release, makes the item available for consumption</span></span><br><span class="line">    <span class="keyword">return</span> gp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 <code>runqgrab</code> 从 p2 偷走它一半的工作放到 <code>_p_</code> 本地：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n := runqgrab(p2, &amp;_p_.runq, t, stealRunNextG)</span><br></pre></td></tr></table></figure>

<p><code>runqgrab</code> 函数将从 p2 偷来的工作放到以 t 为地址的数组里，数组就是 <code>_p_.runq</code>。 我们知道，<code>t</code> 是 <code>_p_.runq</code> 的队尾，因此这行代码表达的真正意思是将从 p2 偷来的工作，神不知，鬼不觉地放到 <code>_p_.runq</code> 的队尾，之后，再悄悄改一下 ``<em>p</em>.runqtail` 就把这些偷来的工作据为己有了。</p>
<p>接着往下看，返回的 n 表示偷到的工作数量。先将 n 自减 1，目的是把第 n 个工作（也就是 g）直接返回，如果这时候 n 变成 0 了，说明就只偷到了一个 g，那就直接返回。否则，将队尾往后移动 n，把偷来的工作合法化，简直完美！</p>
<p>我们接着往下看 <code>runqgrab</code> 函数的实现：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 _p_ 批量获取可运行 goroutine，放到 batch 数组里</span></span><br><span class="line"><span class="comment">// batch 是一个环，起始于 batchHead</span></span><br><span class="line"><span class="comment">// 返回偷的数量，返回的 goroutine 可被任何 P 执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runqgrab</span><span class="params">(_p_ *p, batch *[256]guintptr, batchHead <span class="keyword">uint32</span>, stealRunNextG <span class="keyword">bool</span>)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 队列头</span></span><br><span class="line">        h := atomic.Load(&amp;_p_.runqhead) <span class="comment">// load-acquire, synchronize with other consumers</span></span><br><span class="line">        <span class="comment">// 队列尾</span></span><br><span class="line">        t := atomic.Load(&amp;_p_.runqtail) <span class="comment">// load-acquire, synchronize with the producer</span></span><br><span class="line">        <span class="comment">// g 的数量</span></span><br><span class="line">        n := t - h</span><br><span class="line">        <span class="comment">// 取一半</span></span><br><span class="line">        n = n - n/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> stealRunNextG &#123;</span><br><span class="line">                <span class="comment">// 连 runnext 都要偷，没有人性</span></span><br><span class="line">                <span class="comment">// Try to steal from _p_.runnext.</span></span><br><span class="line">                <span class="keyword">if</span> next := _p_.runnext; next != <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// 这里是为了防止 _p_ 执行当前 g，并且马上就要阻塞，所以会马上执行 runnext，</span></span><br><span class="line">                    <span class="comment">// 这个时候偷就没必要了，因为让 g 在 P 之间"游走"不太划算，</span></span><br><span class="line">                    <span class="comment">// 就不偷了，给他们一个机会。</span></span><br><span class="line">                    <span class="comment">// channel 一次同步的的接收发送需要 50ns 左右，因此 3us 差不多给了他们 50 次机会了，做得还是不错的</span></span><br><span class="line">                    <span class="keyword">if</span> GOOS != <span class="string">"windows"</span> &#123;</span><br><span class="line">                        usleep(<span class="number">3</span>)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        osyield()</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> !_p_.runnext.cas(next, <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 真的偷走了 next</span></span><br><span class="line">                    batch[batchHead%<span class="keyword">uint32</span>(<span class="built_in">len</span>(batch))] = next</span><br><span class="line">                    <span class="comment">// 返回偷的数量，只有 1 个</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没偷到</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 n 这时变得太大了，重新来一遍了，不能偷的太多，做得太过分了</span></span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="keyword">uint32</span>(<span class="built_in">len</span>(_p_.runq)/<span class="number">2</span>) &#123; <span class="comment">// read inconsistent h and t</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 g 放置到 bacth 中</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">uint32</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">            g := _p_.runq[(h+i)%<span class="keyword">uint32</span>(<span class="built_in">len</span>(_p_.runq))]</span><br><span class="line">            batch[(batchHead+i)%<span class="keyword">uint32</span>(<span class="built_in">len</span>(batch))] = g</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 工作被偷走了，更新一下队列头指针</span></span><br><span class="line">        <span class="keyword">if</span> atomic.Cas(&amp;_p_.runqhead, h, h+n) &#123; <span class="comment">// cas-release, commits consume</span></span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外层直接就是一个无限循环，先用原子操作取出 p 的队列头和队列尾，算出一半的 g 的数量，如果 n == 0，说明地主家也没有余粮，这时看 <code>stealRunNextG</code> 的值。如果为假，说明不偷 runnext，那就直接返回 0，啥也没偷到；如果为真，则要尝试偷一下 runnext。</p>
<p>先判断 runnext 不为空，那就真的准备偷了。不过在这之前，要先休眠 3 us。这是为了防止 p 正在执行当前的 g，马上就要阻塞（可能是向一个非缓冲的 channel 发送数据，没有接收者），之后会马上执行 runnext。这个时候偷就没必要了，因为 runnext 马上就要执行了，偷走它还不是要去执行，那何必要偷呢？大家的愿望就是提高效率，这样让 g 在 P 之间”游走”不太划算，索性先不偷了，给他们一个机会。<code>channel</code> 一次同步的的接收或发送需要 50ns 左右，因此休眠 3us 差不多给了他们 50 次机会了，做得还是挺厚道的。</p>
<p>继续看，再次判断 n 是否小于等于 p.runq 长度的一半，因为这个时候很可能 p 也被其他线程偷了，它的 p.runq 就没那么多工作了，这个时候就不能偷这么多了，要重新再走一次循环。</p>
<p>最后一个 for 循环，将 p.runq 里的 g 放到 batch 数组里。使用原子操作更新 p 的队列头指针，往后移动 n 个位置，这些都是被偷走的，伤心！</p>
<p>回到 <code>findrunnable</code> 函数，经过上述三个层面的“偷窃”过程，我们仍然没有找到工作，真惨！于是就走到了 <code>stop</code> 这个代码块。</p>
<p>先上锁，因为要将 P 放到全局空闲 P 链表里去。在这之前还不死心，再瞧一下全局队列里是否有工作，如果有，再去尝试偷全局。</p>
<p>如果没有，就先解除当前工作线程和当前 P 的绑定关系：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解除 p 与 m 的关联</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">releasep</span><span class="params">()</span> *<span class="title">p</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ……………………</span></span><br><span class="line"></span><br><span class="line">	_p_ := _g_.m.p.ptr()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ……………………</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 清空一些字段</span></span><br><span class="line">	_g_.m.p = <span class="number">0</span></span><br><span class="line">	_g_.m.mcache = <span class="literal">nil</span></span><br><span class="line">	_p_.m = <span class="number">0</span></span><br><span class="line">	_p_.status = _Pidle</span><br><span class="line">	<span class="keyword">return</span> _p_</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要的工作就是将 p 的 m 字段清空，并将 p 的状态修改为 <code>_Pidle</code>。</p>
<p>这之后，将其放入全局空闲 P 列表：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 p 放到 _Pidle 列表里</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pidleput</span><span class="params">(_p_ *p)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !runqempty(_p_) &#123;</span><br><span class="line">		throw(<span class="string">"pidleput: P has non-empty run queue"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	_p_.link = sched.pidle</span><br><span class="line">	sched.pidle.set(_p_)</span><br><span class="line">	<span class="comment">// 增加全局空闲 P 的数量</span></span><br><span class="line">	atomic.Xadd(&amp;sched.npidle, <span class="number">1</span>) <span class="comment">// <span class="doctag">TODO:</span> fast atomic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造链表的过程其实比较简单，先将 p.link 指向原来的 sched.pidle 所指向的 p，也就是原空闲链表的最后一个 P，最后，再更新 sched.pidle，使其指向当前 p，这样，新的链表就构造完成。</p>
<p>接下来就要真正地准备休眠了，但是仍然不死心！还要再查看一次所有的 P 是否有工作，如果发现任何一个 P 有工作的话（判断 P 的本地队列不空），就先从全局空闲 P 链表里先拿到一个 P：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 试图从 _Pidle 列表里获取 p</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pidleget</span><span class="params">()</span> *<span class="title">p</span></span> &#123;</span><br><span class="line">	_p_ := sched.pidle.ptr()</span><br><span class="line">	<span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span><br><span class="line">		sched.pidle = _p_.link</span><br><span class="line">		atomic.Xadd(&amp;sched.npidle, <span class="number">-1</span>) <span class="comment">// <span class="doctag">TODO:</span> fast atomic</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _p_</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较简单，获取链表最后一个，再更新 sched.pidle，使其指向前一个 P。调用 <code>acquirep(_p_)</code> 绑定获取到的 p 和 m，主要的动作就是设置 p 的 m 字段，更改 p 的工作状态为 <code>_Prunning</code>，并且设置 m 的 p 字段。做完这些之后，再次进入 top 代码段，再走一遍之前找工作的过程。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 休眠，停止执行工作，直到有新的工作需要做为止</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stopm</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 当前 goroutine，g0</span></span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ……………………</span></span><br><span class="line">retry:</span><br><span class="line">	lock(&amp;sched.lock)</span><br><span class="line">	<span class="comment">// 将 m 放到全局空闲链表里去</span></span><br><span class="line">	mput(_g_.m)</span><br><span class="line">	unlock(&amp;sched.lock)</span><br><span class="line">	<span class="comment">// 进入睡眠状态</span></span><br><span class="line">	notesleep(&amp;_g_.m.park)</span><br><span class="line">	<span class="comment">// 这里被其他工作线程唤醒</span></span><br><span class="line">	noteclear(&amp;_g_.m.park)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ……………………</span></span><br><span class="line"></span><br><span class="line">	acquirep(_g_.m.nextp.ptr())</span><br><span class="line">	_g_.m.nextp = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先将 m 放入全局空闲链表里，注意涉及到全局变量的修改，要上锁。接着，调用 <code>notesleep(&amp;_g_.m.park)</code> 使得当前工作线程进入休眠状态。其他工作线程在检测到“当前有很多工作要做”，会调用 <code>noteclear(&amp;_g_.m.park)</code> 将其唤醒。注意，这两个函数传入的参数都是一样的：<code>&amp;_g_.m.park</code>，它的类型是：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> note <span class="keyword">struct</span> &#123;</span><br><span class="line">	key <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单，只有一个 key 字段。</p>
<blockquote>
<p>note 的底层实现机制跟操作系统相关，不同系统使用不同的机制，比如 linux 下使用的 futex 系统调用，而 mac 下则是使用的 pthread_cond_t 条件变量，note 对这些底层机制做了一个抽象和封装。</p>
</blockquote>
<blockquote>
<p>这种封装给扩展性带来了很大的好处，比如当睡眠和唤醒功能需要支持新平台时，只需要在 note 层增加对特定平台的支持即可，不需要修改上层的任何代码。</p>
</blockquote>
<p>上面这一段来自阿波张的系列教程。我们接着来看下 notesleep 的实现：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/lock_futex.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notesleep</span><span class="params">(n *note)</span></span> &#123;</span><br><span class="line">	<span class="comment">// g0</span></span><br><span class="line">	gp := getg()</span><br><span class="line">	<span class="keyword">if</span> gp != gp.m.g0 &#123;</span><br><span class="line">		throw(<span class="string">"notesleep not on g0"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// -1 表示无限期休眠</span></span><br><span class="line">	ns := <span class="keyword">int64</span>(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ……………………</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 这里之所以需要用一个循环，是因为 futexsleep 有可能意外从睡眠中返回，</span></span><br><span class="line">	<span class="comment">// 所以 futexsleep 函数返回后还需要检查 note.key 是否还是 0，</span></span><br><span class="line">	<span class="comment">// 如果是 0 则表示并不是其它工作线程唤醒了我们，</span></span><br><span class="line">	<span class="comment">// 只是 futexsleep 意外返回了，需要再次调用 futexsleep 进入睡眠</span></span><br><span class="line">	<span class="keyword">for</span> atomic.Load(key32(&amp;n.key)) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 表示 m 被阻塞</span></span><br><span class="line">		gp.m.blocked = <span class="literal">true</span></span><br><span class="line">		futexsleep(key32(&amp;n.key), <span class="number">0</span>, ns)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// ……………………</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 被唤醒，更新标志</span></span><br><span class="line">		gp.m.blocked = <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续往下追：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/os_linux.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">futexsleep</span><span class="params">(addr *<span class="keyword">uint32</span>, val <span class="keyword">uint32</span>, ns <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ts timespec</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ns &lt; <span class="number">0</span> &#123;</span><br><span class="line">		futex(unsafe.Pointer(addr), _FUTEX_WAIT, val, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ……………………</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 *addr 和 val 相等的时候，休眠。<code>futex</code> 由汇编语言实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·futex(SB),NOSPLIT,$0</span><br><span class="line">    // 为系统调用准备参数</span><br><span class="line">	MOVQ	addr+0(FP), DI</span><br><span class="line">	MOVL	op+8(FP), SI</span><br><span class="line">	MOVL	val+12(FP), DX</span><br><span class="line">	MOVQ	ts+16(FP), R10</span><br><span class="line">	MOVQ	addr2+24(FP), R8</span><br><span class="line">	MOVL	val3+32(FP), R9</span><br><span class="line">	// 系统调用编号</span><br><span class="line">	MOVL	$202, AX</span><br><span class="line">	// 执行 futex 系统调用进入休眠，被唤醒后接着执行下一条 MOVL 指令</span><br><span class="line">	SYSCALL</span><br><span class="line">	// 保存系统调用的返回值</span><br><span class="line">	MOVL	AX, ret+40(FP)</span><br><span class="line">	RET</span><br></pre></td></tr></table></figure>

<p>这样，找不到工作的 m 就休眠了。当其他线程发现有工作要做时，就会先找到空闲的 m，再通过 m.park 字段来唤醒本线程。唤醒之后，回到 <code>findrunnable</code> 函数，继续寻找 goroutine，找到后返回 schedule 函数，然后就会去运行找到的 goroutine。</p>
<p>这就是 m 找工作的整个过程，历尽千辛万苦，终于修成正果。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【阿波张 Goroutine 调度策略】<a href="https://mp.weixin.qq.com/s/2objs5JrlnKnwFbF4a2z2g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/2objs5JrlnKnwFbF4a2z2g</a></p>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>饶全成</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/09/06/go-scheduler-m-finds-work/">https://qcrao.com/2019/09/06/go-scheduler-m-finds-work/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本文章著作权归作者所有，任何形式的转载都请注明出处。</li></ul></div><br><div class="tags"><a href="/tags/golang/">golang</a></div><div class="post-nav"><a class="pre" href="/2019/09/06/go-scheduler-what-sysmon-does/">忠于职守 —— sysmon 线程到底做了什么？（九）</a><a class="next" href="/2019/09/06/go-scheduler-cycle-of-schedul/">生生死死 —— schedule 的轮回（七）</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '7e91ec94cfb5913e3d6b',
  clientSecret: '902f91e26bc75c9f8d912557492476d0be254667',
  repo: 'qcrao.github.io',
  owner: 'qcrao',
  admin: ['qcrao'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://qcrao.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/求职/">求职</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程语言/">编程语言</a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a><span class="category-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/golang/" style="font-size: 15px;">golang</a> <a href="/tags/协议/" style="font-size: 15px;">协议</a> <a href="/tags/内存重排/" style="font-size: 15px;">内存重排</a> <a href="/tags/简历/" style="font-size: 15px;">简历</a> <a href="/tags/编译原理/" style="font-size: 15px;">编译原理</a> <a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/09/06/go-scheduler-state-diagram-of-gpm/">意犹未尽 —— GPM 的状态流转（十）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/06/go-scheduler-what-sysmon-does/">忠于职守 —— sysmon 线程到底做了什么？（九）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/06/go-scheduler-m-finds-work/">锲而不舍 —— M 是怎样找工作的？（八）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/06/go-scheduler-cycle-of-schedul/">生生死死 —— schedule 的轮回（七）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/06/go-scheduler-life-of-goroutine/">千难万险 —— goroutine 从生到死（六）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/04/go-scheduler-start-schedule-cycle/">新官上任 —— Go sheduler 开始调度循环（五）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/04/go-scheduler-stack-switch-between-g0-and-user-goroutine/">偷天换日 —— g0 栈和用户栈如何完成切换？（四）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/04/go-scheduler-the-birth-of-main-goroutine/">粉墨登场 —— main goroutine 的诞生（三）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/04/go-scheduler-init/">开天辟地 —— Go scheduler 初始化（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/04/go-scheduler-what-is-gpm/">三足鼎立 —— GPM 到底是什么？（一）</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/qcrao/Go-Questions" title="Go-Questions" target="_blank">Go-Questions</a><ul></ul><a href="http://xargin.com/" title="No HeadBack" target="_blank">No HeadBack</a><ul></ul><a href="https://draveness.me/" title="面向信仰编程" target="_blank">面向信仰编程</a><ul></ul><a href="https://eddycjy.gitbook.io/golang/" title="跟煎鱼学 Go" target="_blank">跟煎鱼学 Go</a><ul></ul><a href="http://lessisbetter.site/" title="大彬 - Less is better" target="_blank">大彬 - Less is better</a><ul></ul><a href="https://wujunze.com/" title="好未来大佬 Panda" target="_blank">好未来大佬 Panda</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async="async"></script><span> | </span><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span> | </span><i class="fa fa-keyboard-o"></i><span class="post-count">161.3k</span><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">qcrao.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>