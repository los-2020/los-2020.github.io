<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Stefno</title>
  
  <subtitle>码农桃花源</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/qcrao/qcrao.github.io/"/>
  <updated>2019-07-24T11:34:44.000Z</updated>
  <id>https://github.com/qcrao/qcrao.github.io/</id>
  
  <author>
    <name>Stefno</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go 程序是怎样跑起来的</title>
    <link href="https://github.com/qcrao/qcrao.github.io/2019/07/24/how-go-runs/"/>
    <id>https://github.com/qcrao/qcrao.github.io/2019/07/24/how-go-runs/</id>
    <published>2019-07-24T04:05:16.000Z</published>
    <updated>2019-07-24T11:34:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>刚开始写这篇文章的时候，目标非常大，想要探索 Go 程序的一生：编码、编译、汇编、链接、运行、退出。它的每一步具体如何进行，力图弄清 Go 程序的这一生。</p><p>在这个过程中，我又复习了一遍《程序员的自我修养》。这是一本讲编译、链接的书，非常详细，值得一看！数年前，我第一次看到这本书的书名，就非常喜欢。因为它模仿了周星驰喜剧之王里出现的一本书 ——《演员的自我修养》。心向往之！</p><p>在开始本文之前，先推荐一位头条大佬的博客——《面向信仰编程》，他的 Go 编译系列文章，非常有深度，直接深入编译器源代码，我是看了很多遍了。博客链接可以从参考资料里获取。</p><p>理想很大，实现的难度也是非常大。为了避免砸了“深度解密”这个牌子，这次起了个更温和的名字，嘿嘿。</p><h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>我们从一个 <code>Hello World</code> 的例子开始：</p><pre class=" language-golang"><code class="language-golang">package mainimport "fmt"func main() {    fmt.Println("hello world")}</code></pre><p>当我用我那价值 1800 元的 cherry 键盘潇洒地敲完上面的 hello world 代码时，保存在硬盘上的 <code>hello.go</code> 文件就是一个字节序列了，每个字节代表一个字符。</p><p>用 vim 打开 hello.go 文件，在命令行模式下，输入命令：</p><pre class=" language-shell"><code class="language-shell">:%!xxd</code></pre><p>就能在 vim 里以十六进制查看文件内容：</p><p><img src="https://user-images.githubusercontent.com/7698088/59696461-9d76e600-921e-11e9-9253-533d55e2c8f5.png" alt="hex .go"></p><p>最左边的一列代表地址值，中间一列代表文本对应的 ASCII 字符，最右边的列就是我们的代码。再在终端里执行 <code>man ascii</code>：</p><p><img src="https://user-images.githubusercontent.com/7698088/59696702-15dda700-921f-11e9-838f-897a5d3f21fb.png" alt="ASCII"></p><p>和 ASCII 字符表一对比，就能发现，中间的列和最右边的列是一一对应的。也就是说，刚刚写完的 hello.go 文件都是由 ASCII 字符表示的，它被称为<code>文本文件</code>，其他文件被称为<code>二进制文件</code>。</p><p>当然，更深入地看，计算机中的所有数据，像磁盘文件、网络中的数据其实都是一串比特位组成，取决于如何看待它。在不同的情景下，一个相同的字节序列可能表示成一个整数、浮点数、字符串或者是机器指令。</p><p>而像 hello.go 这个文件，8 个 bit，也就是一个字节看成一个单位（假定源程序的字符都是 ASCII 码），最终解释成人类能读懂的 Go 源码。</p><p>Go 程序并不能直接运行，每条 Go 语句必须转化为一系列的低级机器语言指令，将这些指令打包到一起，并以二进制磁盘文件的形式存储起来，也就是可执行目标文件。</p><p>从源文件到可执行目标文件的转化过程：</p><p><img src="https://user-images.githubusercontent.com/7698088/60523966-44c74300-9d1e-11e9-9ba9-d1f594607edc.png" alt="compile"></p><p>完成以上各个阶段的就是 Go 编译系统。你肯定知道大名鼎鼎的 GCC（GNU Compile Collection），中文名为 GNU 编译器套装，它支持像 C，C++，Java，Python，Objective-C，Ada，Fortran，Pascal，能够为很多不同的机器生成机器码。</p><p>可执行目标文件可以直接在机器上执行。一般而言，先执行一些初始化的工作；找到 main 函数的入口，执行用户写的代码；执行完成后，main 函数退出；再执行一些收尾的工作，整个过程完毕。</p><p>在接下来的文章里，我们将探索<code>编译</code>和<code>运行</code>的过程。</p><h1 id="编译链接概述"><a href="#编译链接概述" class="headerlink" title="编译链接概述"></a>编译链接概述</h1><p>Go 源码里的编译器源码位于 <code>src/cmd/compile</code> 路径下，链接器源码位于 <code>src/cmd/link</code> 路径下。</p><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>我比较喜欢用 IDE（集成开发环境）来写代码， Go 源码用的 Goland，有时候直接点击 IDE 菜单栏里的“运行”按钮，程序就跑起来了。这实际上隐含了编译和链接的过程，我们通常将编译和链接合并到一起的过程称为构建（Build）。</p><p>编译过程就是对源文件进行词法分析、语法分析、语义分析、优化，最后生成汇编代码文件，以 <code>.s</code> 作为文件后缀。</p><p>之后，汇编器会将汇编代码转变成机器可以执行的指令。由于每一条汇编语句几乎都与一条机器指令相对应，所以只是一个简单的一一对应，比较简单，没有语法、语义分析，也没有优化这些步骤。</p><p>编译器是将高级语言翻译成机器语言的一个工具，编译过程一般分为 6 步：扫描、语法分析、语义分析、源代码优化、代码生成、目标代码优化。下图来自《程序员的自我修养》：</p><p><img src="https://user-images.githubusercontent.com/7698088/59910602-d4c6dc00-9444-11e9-8155-fbe59eec4e89.png" alt="编译过程总览"></p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>通过前面的例子，我们知道，Go 程序文件在机器看来不过是一堆二进制位。我们能读懂，是因为 Goland 按照 ASCII 码（实际上是 UTF-8）把这堆二进制位进行了编码。例如，把 8个 bit 位分成一组，对应一个字符，通过对照 ASCII 码表就可以查出来。</p><p>当把所有的二进制位都对应成了 ASCII 码字符后，我们就能看到有意义的字符串。它可能是关键字，例如：package；可能是字符串，例如：“Hello World”。</p><p>词法分析其实干的就是这个。输入是原始的 Go 程序文件，在词法分析器看来，就是一堆二进制位，根本不知道是什么东西，经过它的分析后，变成有意义的记号。简单来说，词法分析是计算机科学中将字符序列转换为标记（token）序列的过程。</p><p>我们来看一下维基百科上给出的定义：</p><blockquote><p>词法分析（lexical analysis）是计算机科学中将字符序列转换为标记（token）序列的过程。进行词法分析的程序或者函数叫作词法分析器（lexical analyzer，简称lexer），也叫扫描器（scanner）。词法分析器一般以函数的形式存在，供语法分析器调用。</p></blockquote><p><code>.go</code> 文件被输入到扫描器（Scanner），它使用一种类似于<code>有限状态机</code>的算法，将源代码的字符系列分割成一系列的记号（Token）。</p><p>记号一般分为这几类：关键字、标识符、字面量（包含数字、字符串）、特殊符号（如加号、等号）。</p><p>例如，对于如下的代码：</p><pre class=" language-golang"><code class="language-golang">slice[i] = i * (2 + 6)</code></pre><p>总共包含 16 个非空字符，经过扫描后，</p><table><thead><tr><th>记号</th><th>类型</th></tr></thead><tbody><tr><td>slice</td><td>标识符</td></tr><tr><td>[</td><td>左方括号</td></tr><tr><td>i</td><td>标识符</td></tr><tr><td>]</td><td>右方括号</td></tr><tr><td>=</td><td>赋值</td></tr><tr><td>i</td><td>标识符</td></tr><tr><td>*</td><td>乘号</td></tr><tr><td>(</td><td>左圆括号</td></tr><tr><td>2</td><td>数字</td></tr><tr><td>+</td><td>加号</td></tr><tr><td>6</td><td>数字</td></tr><tr><td>)</td><td>右圆括号</td></tr></tbody></table><p>上面的例子源自《程序员的自我修养》，主要讲解编译、链接相关的内容，很精彩，推荐研读。</p><p>Go 语言（本文的 Go 版本是 1.9.2）扫描器支持的 Token 在源码中的路径：</p><pre class=" language-shell"><code class="language-shell">src/cmd/compile/internal/syntax/token.go</code></pre><p>感受一下：</p><pre class=" language-golang"><code class="language-golang">var tokstrings = [...]string{    // source control    _EOF: "EOF",    // names and literals    _Name:    "name",    _Literal: "literal",    // operators and operations    _Operator: "op",    _AssignOp: "op=",    _IncOp:    "opop",    _Assign:   "=",    _Define:   ":=",    _Arrow:    "<-",    _Star:     "*",    // delimitors    _Lparen:    "(",    _Lbrack:    "[",    _Lbrace:    "{",    _Rparen:    ")",    _Rbrack:    "]",    _Rbrace:    "}",    _Comma:     ",",    _Semi:      ";",    _Colon:     ":",    _Dot:       ".",    _DotDotDot: "...",    // keywords    _Break:       "break",    _Case:        "case",    _Chan:        "chan",    _Const:       "const",    _Continue:    "continue",    _Default:     "default",    _Defer:       "defer",    _Else:        "else",    _Fallthrough: "fallthrough",    _For:         "for",    _Func:        "func",    _Go:          "go",    _Goto:        "goto",    _If:          "if",    _Import:      "import",    _Interface:   "interface",    _Map:         "map",    _Package:     "package",    _Range:       "range",    _Return:      "return",    _Select:      "select",    _Struct:      "struct",    _Switch:      "switch",    _Type:        "type",    _Var:         "var",}</code></pre><p>还是比较熟悉的，包括名称和字面量、操作符、分隔符和关键字。</p><p>而扫描器的路径是：</p><pre class=" language-shell"><code class="language-shell">src/cmd/compile/internal/syntax/scanner.go</code></pre><p>其中最关键的函数就是 next 函数，它不断地读取下一个字符（不是下一个字节，因为 Go 语言支持 Unicode 编码，并不是像我们前面举得 ASCII 码的例子，一个字符只有一个字节），直到这些字符可以构成一个 Token。</p><pre class=" language-golang"><code class="language-golang">func (s *scanner) next() {// ……redo:    // skip white space    c := s.getr()    for c == ' ' || c == '\t' || c == '\n' && !nlsemi || c == '\r' {        c = s.getr()    }    // token start    s.line, s.col = s.source.line0, s.source.col0    if isLetter(c) || c >= utf8.RuneSelf && s.isIdentRune(c, true) {        s.ident()        return    }    switch c {    // ……    case '\n':        s.lit = "newline"        s.tok = _Semi    case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':        s.number(c)    // ……   default:        s.tok = 0        s.error(fmt.Sprintf("invalid character %#U", c))        goto redo    returnassignop:    if c == '=' {        s.tok = _AssignOp        return    }    s.ungetr()    s.tok = _Operator}</code></pre><p>代码的主要逻辑就是通过 <code>c := s.getr()</code>  获取下一个未被解析的字符，并且会跳过之后的空格、回车、换行、tab 字符，然后进入一个大的 <code>switch-case</code> 语句，匹配各种不同的情形，最终可以解析出一个 Token，并且把相关的行、列数字记录下来，这样就完成一次解析过程。</p><blockquote><p>当前包中的词法分析器 scanner 也只是为上层提供了 next 方法，词法解析的过程都是惰性的，只有在上层的解析器需要时才会调用 next 获取最新的 Token。</p></blockquote><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>上一步生成的 Token 序列，需要经过进一步处理，生成一棵以<code>表达式</code>为结点的<code>语法树</code>。</p><p>比如最开始的那个例子，<code>slice[i] = i * (2 + 6)</code>，得到的一棵语法树如下：</p><p><img src="https://user-images.githubusercontent.com/7698088/59962830-3490b600-951d-11e9-8ae6-53d6375f0246.png" alt="语法树"></p><p>整个语句被看作是一个赋值表达式，左子树是一个数组表达式，右子树是一个乘法表达式；数组表达式由 2 个符号表达式组成；乘号表达式则是由一个符号表达式和一个加号表达式组成；加号表达式则是由两个数字组成。符号和数字是最小的表达式，它们不能再被分解，通常作为树的叶子节点。</p><p>语法分析的过程可以检测一些形式上的错误，例如：括号是否缺少一半，<code>+</code> 号表达式缺少一个操作数等。</p><blockquote><p>语法分析是根据某种特定的形式文法（Grammar）对 Token 序列构成的输入文本进行分析并确定其语法结构的一种过程。</p></blockquote><h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>语法分析完成后，我们并不知道语句的具体意义是什么。像上面的 <code>*</code> 号的两棵子树如果是两个指针，这是不合法的，但语法分析检测不出来，语义分析就是干这个事。</p><p>编译期所能检查的是静态语义，可以认为这是在“代码”阶段，包括变量类型的匹配、转换等。例如，将一个浮点值赋给一个指针变量的时候，明显的类型不匹配，就会报编译错误。而对于运行期间才会出现的错误：不小心除了一个 0 ，语义分析是没办法检测的。</p><p>语义分析阶段完成之后，会在每个节点上标注上类型：</p><p><img src="https://user-images.githubusercontent.com/7698088/59962838-512cee00-951d-11e9-8581-18e12ffde230.png" alt="语义分析完成"></p><p>Go 语言编译器在这一阶段检查常量、类型、函数声明以及变量赋值语句的类型，然后检查哈希中键的类型。实现类型检查的函数通常都是几千行的巨型 switch/case 语句。</p><blockquote><p>类型检查是 Go 语言编译的第二个阶段，在词法和语法分析之后我们得到了每个文件对应的抽象语法树，随后的类型检查会遍历抽象语法树中的节点，对每个节点的类型进行检验，找出其中存在的语法错误。</p></blockquote><blockquote><p>在这个过程中也可能会对抽象语法树进行改写，这不仅能够去除一些不会被执行的代码对编译进行优化提高执行效率，而且也会修改 make、new 等关键字对应节点的操作类型。</p></blockquote><p>例如比较常用的 make 关键字，用它可以创建各种类型，如 slice，map，channel 等等。到这一步的时候，对于 make 关键字，也就是 OMAKE 节点，会先检查它的参数类型，根据类型的不同，进入相应的分支。如果参数类型是 slice，就会进入 TSLICE case 分支，检查 len 和 cap 是否满足要求，如 len &lt;= cap。最后节点类型会从 OMAKE 改成 OMAKESLICE。</p><h3 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h3><p>我们知道，编译过程一般可以分为前端和后端，前端生成和平台无关的中间代码，后端会针对不同的平台，生成不同的机器码。</p><p>前面词法分析、语法分析、语义分析等都属于编译器前端，之后的阶段属于编译器后端。</p><p>编译过程有很多优化的环节，在这个环节是指源代码级别的优化。它将语法树转换成中间代码，它是语法树的顺序表示。</p><p>中间代码一般和目标机器以及运行时环境无关，它有几种常见的形式：三地址码、P-代码。例如，最基本的<code>三地址码</code>是这样的：</p><pre class=" language-shell"><code class="language-shell">x = y op z</code></pre><p>表示变量 y 和 变量 z 进行 op 操作后，赋值给 x。op 可以是数学运算，例如加减乘除。</p><p>前面我们举的例子可以写成如下的形式：</p><pre class=" language-shell"><code class="language-shell">t1 = 2 + 6t2 = i * t1slice[i] = t2</code></pre><p>这里 2 + 6 是可以直接计算出来的，这样就把 t1 这个临时变量“优化”掉了，而且 t1 变量可以重复利用，因此 t2 也可以“优化”掉。优化之后：</p><pre class=" language-shell"><code class="language-shell">t1 = i * 8slice[i] = t1</code></pre><p>Go 语言的中间代码表示形式为 SSA（Static Single-Assignment，静态单赋值），之所以称之为单赋值，是因为每个名字在 SSA 中仅被赋值一次。。</p><p>这一阶段会根据 CPU 的架构设置相应的用于生成中间代码的变量，例如编译器使用的指针和寄存器的大小、可用寄存器列表等。中间代码生成和机器码生成这两部分会共享相同的设置。</p><p>在生成中间代码之前，会对抽象语法树中节点的一些元素进行替换。这里引用《面向信仰编程》编译原理相关博客里的一张图：</p><p><img src="https://user-images.githubusercontent.com/7698088/60553849-a364df00-9d67-11e9-832a-450f4d8ee6ba.png" alt="builtin mapping"></p><p>例如对于 map 的操作 m[i]，在这里会被转换成 mapacess 或 mapassign。</p><blockquote><p>Go 语言的主程序在执行时会调用 runtime 中的函数，也就是说关键字和内置函数的功能其实是由语言的编译器和运行时共同完成的。</p></blockquote><blockquote><p>中间代码的生成过程其实就是从 AST 抽象语法树到 SSA 中间代码的转换过程，在这期间会对语法树中的关键字在进行一次更新，更新后的语法树会经过多轮处理转变最后的 SSA 中间代码。</p></blockquote><h3 id="目标代码生成与优化"><a href="#目标代码生成与优化" class="headerlink" title="目标代码生成与优化"></a>目标代码生成与优化</h3><p>不同机器的机器字长、寄存器等等都不一样，意味着在不同机器上跑的机器码是不一样的。最后一步的目的就是要生成能在不同 CPU 架构上运行的代码。</p><p>为了榨干机器的每一滴油水，目标代码优化器会对一些指令进行优化，例如使用移位指令代替乘法指令等。</p><p>这块实在没能力深入，幸好也不需要深入。对于应用层的软件开发工程师来说，了解一下就可以了。</p><h2 id="链接过程"><a href="#链接过程" class="headerlink" title="链接过程"></a>链接过程</h2><p>编译过程是针对单个文件进行的，文件与文件之间不可避免地要引用定义在其他模块的全局变量或者函数，这些变量或函数的地址只有在此阶段才能确定。</p><p>链接过程就是要把编译器生成的一个个目标文件链接成可执行文件。最终得到的文件是分成各种段的，比如数据段、代码段、BSS段等等，运行时会被装载到内存中。各个段具有不同的读写、执行属性，保护了程序的安全运行。</p><p>这部分内容，推荐看《程序员的自我修养》和《深入理解计算机系统》。</p><h1 id="Go-程序启动"><a href="#Go-程序启动" class="headerlink" title="Go 程序启动"></a>Go 程序启动</h1><p>仍然使用 hello-world 项目的例子。在项目根目录下执行：</p><pre class=" language-shell"><code class="language-shell">go build -gcflags "-N -l" -o hello src/main.go</code></pre><p><code>-gcflags &quot;-N -l&quot;</code> 是为了关闭编译器优化和函数内联，防止后面在设置断点的时候找不到相对应的代码位置。</p><p>得到了可执行文件 hello，执行：</p><pre class=" language-shell"><code class="language-shell">[qcrao@qcrao hello-world]$ gdb hello</code></pre><p>进入 gdb 调试模式，执行 <code>info files</code>，得到可执行文件的文件头，列出了各种段：</p><p><img src="https://user-images.githubusercontent.com/7698088/60392813-db88d980-9b3d-11e9-8b0f-7c1d845a8191.png" alt="gdb info"></p><p>同时，我们也得到了入口地址：0x450e20。</p><pre class=" language-shell"><code class="language-shell">(gdb) b *0x450e20Breakpoint 1 at 0x450e20: file /usr/local/go/src/runtime/rt0_linux_amd64.s, line 8.</code></pre><p>这就是 Go 程序的入口地址，我是在 linux 上运行的，所以入口文件为 <code>src/runtime/rt0_linux_amd64.s</code>，runtime 目录下有各种不同名称的程序入口文件，支持各种操作系统和架构，代码为：</p><pre class=" language-asm"><code class="language-asm">TEXT _rt0_amd64_linux(SB),NOSPLIT,$-8    LEAQ    8(SP), SI // argv    MOVQ    0(SP), DI // argc    MOVQ    $main(SB), AX    JMP    AX</code></pre><p>主要是把 argc，argv 从内存拉到了寄存器。这里 LEAQ 是计算内存地址，然后把内存地址本身放进寄存器里，也就是把 argv 的地址放到了 SI 寄存器中。最后跳转到：</p><pre class=" language-golang"><code class="language-golang">TEXT main(SB),NOSPLIT,$-8    MOVQ    $runtime·rt0_go(SB), AX    JMP    AX</code></pre><p>继续跳转到 <code>runtime·rt0_go(SB)</code>，位置：<code>/usr/local/go/src/runtime/asm_amd64.s</code>，代码：</p><pre class=" language-ams"><code class="language-ams">TEXT runtime·rt0_go(SB),NOSPLIT,$0    // 省略很多 CPU 相关的特性标志位检查的代码    // 主要是看不懂，^_^    // ………………………………    // 下面是最后调用的一些函数，比较重要    // 初始化执行文件的绝对路径    CALL    runtime·args(SB)    // 初始化 CPU 个数和内存页大小    CALL    runtime·osinit(SB)    // 初始化命令行参数、环境变量、gc、栈空间、内存管理、所有 P 实例、HASH算法等    CALL    runtime·schedinit(SB)    // 要在 main goroutine 上运行的函数    MOVQ    $runtime·mainPC(SB), AX        // entry    PUSHQ    AX    PUSHQ    $0            // arg size    // 新建一个 goroutine，该 goroutine 绑定 runtime.main，放在 P 的本地队列，等待调度    CALL    runtime·newproc(SB)    POPQ    AX    POPQ    AX    // 启动M，开始调度goroutine    CALL    runtime·mstart(SB)    MOVL    $0xf1, 0xf1  // crash    RETDATA    runtime·mainPC+0(SB)/8,$runtime·main(SB)GLOBL    runtime·mainPC(SB),RODATA,$8    </code></pre><p>参考文献里的一篇文章【探索 golang 程序启动过程】研究得比较深入，总结下：</p><blockquote><ol><li>检查运行平台的CPU，设置好程序运行需要相关标志。</li><li>TLS的初始化。</li><li>runtime.args、runtime.osinit、runtime.schedinit 三个方法做好程序运行需要的各种变量与调度器。</li><li>runtime.newproc创建新的goroutine用于绑定用户写的main方法。</li><li>runtime.mstart开始goroutine的调度。</li></ol></blockquote><p>最后用一张图来总结 go bootstrap 过程吧：</p><p><img src="https://user-images.githubusercontent.com/7698088/60493589-b2a04a00-9cdf-11e9-9c9e-a4b275973f60.png" alt="golang bootstrap"></p><p>main 函数里执行的一些重要的操作包括：新建一个线程执行 sysmon 函数，定期垃圾回收和调度抢占；启动 gc；执行所有的 init 函数等等。</p><p>上面是启动过程，看一下退出过程：</p><blockquote><p>当 main 函数执行结束之后，会执行 exit(0) 来退出进程。若执行 exit(0) 后，进程没有退出，main 函数最后的代码会一直访问非法地址：</p></blockquote><pre class=" language-golang"><code class="language-golang">exit(0)for {    var x *int32    *x = 0}</code></pre><blockquote><p>正常情况下，一旦出现非法地址访问，系统会把进程杀死，用这样的方法确保进程退出。</p></blockquote><p>关于程序退出这一段的阐述来自群聊《golang runtime 阅读》，又是一个高阶的读源码的组织，github 主页见参考资料。</p><p>当然 Go 程序启动这一部分其实还会涉及到 fork 一个新进程、装载可执行文件，控制权转移等问题。还是推荐看前面的两本书，我觉得我不会写得更好，就不叙述了。</p><h1 id="GoRoot-和-GoPath"><a href="#GoRoot-和-GoPath" class="headerlink" title="GoRoot 和 GoPath"></a>GoRoot 和 GoPath</h1><p>GoRoot 是  Go 的安装路径。mac 或 unix 是在 <code>/usr/local/go</code> 路径上，来看下这里都装了些什么：</p><p><img src="https://user-images.githubusercontent.com/7698088/60344492-41178180-99e9-11e9-98b0-b1f8d64ce97d.png" alt="/usr/local/go"></p><p>bin 目录下面：</p><p><img src="https://user-images.githubusercontent.com/7698088/60344698-b5522500-99e9-11e9-8883-a5bf2460fba0.png" alt="bin"></p><p>pkg 目录下面：</p><p><img src="https://user-images.githubusercontent.com/7698088/60344731-c7cc5e80-99e9-11e9-8002-83f3debc09a6.png" alt="pkg"></p><p>Go 工具目录如下，其中比较重要的有编译器 <code>compile</code>，链接器 <code>link</code>：</p><p><img src="https://user-images.githubusercontent.com/7698088/60379164-888d2480-9a60-11e9-9322-920c0e1b2b3d.png" alt="pkg/tool"></p><p>GoPath 的作用在于提供一个可以寻找 <code>.go</code> 源码的路径，它是一个工作空间的概念，可以设置多个目录。Go 官方要求，GoPath 下面需要包含三个文件夹：</p><pre class=" language-shell"><code class="language-shell">srcpkgbin</code></pre><p>src 存放源文件，pkg 存放源文件编译后的库文件，后缀为 <code>.a</code>；bin 则存放可执行文件。</p><h1 id="Go-命令详解"><a href="#Go-命令详解" class="headerlink" title="Go 命令详解"></a>Go 命令详解</h1><p>直接在终端执行：</p><pre class=" language-shell"><code class="language-shell">go</code></pre><p>就能得到和 go 相关的命令简介：</p><p><img src="https://user-images.githubusercontent.com/7698088/60248752-e2bda680-98f5-11e9-8b3b-7deaf70a919c.png" alt="go commands"></p><p>和编译相关的命令主要是：</p><pre class=" language-shell"><code class="language-shell">go buildgo installgo run</code></pre><h2 id="go-build"><a href="#go-build" class="headerlink" title="go build"></a>go build</h2><p><code>go build</code> 用来编译指定 packages 里的源码文件以及它们的依赖包，编译的时候会到 <code>$GoPath/src/package</code> 路径下寻找源码文件。<code>go build</code> 还可以直接编译指定的源码文件，并且可以同时指定多个。</p><p>通过执行 <code>go help build</code> 命令得到 <code>go build</code> 的使用方法：</p><pre class=" language-shell"><code class="language-shell">usage: go build [-o output] [-i] [build flags] [packages]</code></pre><p><code>-o</code> 只能在编译单个包的时候出现，它指定输出的可执行文件的名字。</p><p><code>-i</code> 会安装编译目标所依赖的包，安装是指生成与代码包相对应的 <code>.a</code> 文件，即静态库文件（后面要参与链接），并且放置到当前工作区的 pkg 目录下，且库文件的目录层级和源码层级一致。</p><p>至于 build flags 参数，<code>build, clean, get, install, list, run, test</code> 这些命令会共用一套：</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>强制重新编译所有涉及到的包，包括标准库中的代码包，这会重写 /usr/local/go 目录下的 <code>.a</code> 文件</td></tr><tr><td>-n</td><td>打印命令执行过程，不真正执行</td></tr><tr><td>-p n</td><td>指定编译过程中命令执行的并行数，n 默认为 CPU 核数</td></tr><tr><td>-race</td><td>检测并报告程序中的数据竞争问题</td></tr><tr><td>-v</td><td>打印命令执行过程中所涉及到的代码包名称</td></tr><tr><td>-x</td><td>打印命令执行过程中所涉及到的命令，并执行</td></tr><tr><td>-work</td><td>打印编译过程中的临时文件夹。通常情况下，编译完成后会被删除</td></tr></tbody></table><p>我们知道，Go 语言的源码文件分为三类：命令源码、库源码、测试源码。</p><blockquote><p>命令源码文件：是 Go 程序的入口，包含 <code>func main()</code> 函数，且第一行用 <code>package main</code> 声明属于 main 包。</p></blockquote><blockquote><p>库源码文件：主要是各种函数、接口等，例如工具类的函数。</p></blockquote><blockquote><p>测试源码文件：以 <code>_test.go</code> 为后缀的文件，用于测试程序的功能和性能。</p></blockquote><p>注意，<code>go build</code> 会忽略 <code>*_test.go</code> 文件。</p><p>我们通过一个很简单的例子来演示 <code>go build</code> 命令。我用 Goland 新建了一个 <code>hello-world</code> 项目（为了展示引用自定义的包，和之前的 hello-world 程序不同），项目的结构如下：</p><p><img src="https://user-images.githubusercontent.com/7698088/60383032-5b5f6700-9a9e-11e9-9613-03d9ba13b889.png" alt="example structure"></p><p>最左边可以看到项目的结构，包含三个文件夹：bin，pkg，src。其中 src 目录下有一个 main.go，里面定义了 main 函数，是整个项目的入口，也就是前面提过的所谓的命令源码文件；src 目录下还有一个 util 目录，里面有 util.go 文件，定义了一个可以获取本机 IP 地址的函数，也就是所谓的库源码文件。</p><p>中间是 main.go 的源码，引用了两个包，一个是标准库的 fmt；一个是 util 包，util 的导入路径是 <code>util</code>。所谓的导入路径是指相对于 Go 的源码目录 <code>$GoRoot/src</code> 或者 <code>$GoPath/src</code> 的下的子路径。例如 main 包里引用的 fmt 的源码路径是 <code>/usr/local/go/src/fmt</code>，而 util 的源码路径是 <code>/Users/qcrao/hello-world/src/util</code>，正好我们设置的 GoPath = /Users/qcrao/hello-world。</p><p>最右边是库函数的源码，实现了获取本机 IP 的函数。</p><p>在 src 目录下，直接执行 <code>go build</code> 命令，在同级目录生成了一个可执行文件，文件名为 <code>src</code>，使用 <code>./src</code> 命令直接执行，输出：</p><pre class=" language-shell"><code class="language-shell">hello world!Local IP: 192.168.1.3</code></pre><p>我们也可以指定生成的可执行文件的名称：</p><pre class=" language-shell"><code class="language-shell">go build -o bin/hello</code></pre><p>这样，在 bin 目录下会生成一个可执行文件，运行结果和上面的 <code>src</code> 一样。</p><p>其实，util 包可以单独被编译。我们可以在项目根目录下执行：</p><pre class=" language-shell"><code class="language-shell">go build util</code></pre><p>编译程序会去 $GoPath/src 路径找 util 包（其实是找文件夹）。还可以在 <code>./src/util</code> 目录下直接执行 <code>go build</code> 编译。</p><p>当然，直接编译库源码文件不会生成 .a 文件，因为：</p><blockquote><p>go build 命令在编译只包含库源码文件的代码包（或者同时编译多个代码包）时，只会做检查性的编译，而不会输出任何结果文件。</p></blockquote><p>为了展示整个编译链接的运行过程，我们在项目根目录执行如下的命令：</p><pre class=" language-shell"><code class="language-shell">go build -v -x -work -o bin/hello src/main.go</code></pre><p><code>-v</code> 会打印所编译过的包名字，<code>-x</code> 打印编译期间所执行的命令，<code>-work</code> 打印编译期间生成的临时文件路径，并且编译完成之后不会被删除。</p><p>执行结果：</p><p><img src="https://user-images.githubusercontent.com/7698088/60386219-e3586780-9ac4-11e9-871f-5acfa83372d0.png" alt="编译过程"></p><p>从结果来看，图中用箭头标注了本次编译过程涉及 2 个包：util，command-line-arguments。第二个包比较诡异，源码里根本就没有这个名字好吗？其实这是 <code>go build</code> 命令检测到 [packages] 处填的是一个 <code>.go</code> 文件，因此创建了一个虚拟的包：command-line-arguments。</p><p>同时，用红框圈出了 compile, link，也就是先编译了 util 包和 <code>main.go</code> 文件，分别得到 <code>.a</code> 文件，之后将两者进行链接，最终生成可执行文件，并且移动到 bin 目录下，改名为 hello。</p><p>另外，第一行显示了编译过程中的工作目录，此目录的文件结构是：</p><p><img src="https://user-images.githubusercontent.com/7698088/60386682-06861580-9acb-11e9-8367-d37ce03a46cc.png" alt="临时工作目录"></p><p>可以看到，和 hello-world 目录的层级基本一致。command-line-arguments 就是虚拟的 main.go 文件所处的包。exe 目录下的可执行文件在最后一步被移动到了 bin 目录下，所以这里是空的。</p><p>整体来看，<code>go build</code> 在执行时，会先递归寻找 main.go 所依赖的包，以及依赖的依赖，直至最底层的包。这里可以是深度优先遍历也可以是宽度优先遍历。如果发现有循环依赖，就会直接退出，这也是经常会发生的循环引用编译错误。</p><p>正常情况下，这些依赖关系会形成一棵倒着生长的树，树根在最上面，就是 main.go 文件，最下面是没有任何其他依赖的包。编译器会从最左的节点所代表的包开始挨个编译，完成之后，再去编译上一层的包。</p><p>这里，引用郝林老师几年前在 github 上发表的 go 命令教程，可以从参考资料找到原文地址。</p><blockquote><p>从代码包编译的角度来说，如果代码包 A 依赖代码包 B，则称代码包 B 是代码包 A 的依赖代码包（以下简称依赖包），代码包 A 是代码包 B 的触发代码包（以下简称触发包）。</p></blockquote><blockquote><p>执行 <code>go build</code> 命令的计算机如果拥有多个逻辑 CPU 核心，那么编译代码包的顺序可能会存在一些不确定性。但是，它一定会满足这样的约束条件：依赖代码包 -&gt; 当前代码包 -&gt; 触发代码包。</p></blockquote><p>顺便推荐一个浏览器插件 Octotree，在看 github 项目的时候，此插件可以在浏览器里直接展示整个项目的文件结构，非常方便：</p><p><img src="https://user-images.githubusercontent.com/7698088/60390988-d9f7eb00-9b16-11e9-83ec-64c3c0beb6ad.png" alt="github 插件"></p><p>到这里，你一定会发现，对于 hello-wrold 文件夹下的 pkg 目录好像一直没有涉及到。</p><p>其实，pkg 目录下面应该存放的是涉及到的库文件编译后的包，也就是一些 <code>.a</code> 文件。但是 go build 执行过程中，这些 <code>.a</code> 文件放在临时文件夹中，编译完成后会被直接删掉，因此一般不会用到。</p><p>前面我们提到过，在 go build 命令里加上 <code>-i</code> 参数会安装这些库文件编译的包，也就是这些 <code>.a</code> 文件会放到 pkg 目录下。</p><p>在项目根目录执行 <code>go build -i src/main.go</code> 后，pkg 目录里增加了 util.a 文件：</p><p><img src="https://user-images.githubusercontent.com/7698088/60386864-84e3b700-9acd-11e9-9513-68a52ff460bb.png" alt="pkg"></p><p><code>darwin_amd64</code> 表示的是：</p><blockquote><p>GOOS 和 GOARCH。这两个环境变量不用我们设置，系统默认的。</p></blockquote><blockquote><p>GOOS 是 Go 所在的操作系统类型，GOARCH 是 Go 所在的计算架构。</p></blockquote><blockquote><p>Mac 平台上这个目录名就是 darwin_amd64。</p></blockquote><p>生成了 util.a 文件后，再次编译的时候，就不会再重新编译 util.go 文件，加快了编译速度。</p><p>同时，在根目录下生成了名称为 main 的可执行文件，这是以 main.go 的文件名命令的。</p><p>hello-world 这个项目的代码已经上传到了 github 项目 <code>Go-Questions</code>，这个项目由问题导入，企图串连 Go 的所有知识点，正在完善，期待你的 star。 地址见参考资料【Go-Questions hello-world项目】。</p><h2 id="go-install"><a href="#go-install" class="headerlink" title="go install"></a>go install</h2><p><code>go install</code> 用于编译并安装指定的代码包及它们的依赖包。相比 <code>go build</code>，它只是多了一个“安装编译后的结果文件到指定目录”的步骤。</p><p>还是使用之前 hello-world 项目的例子，我们先将 pkg 目录删掉，在项目根目录执行：</p><pre class=" language-shell"><code class="language-shell">go install src/main.go或者go install util</code></pre><p>两者都会在根目录下新建一个 <code>pkg</code> 目录，并且生成一个 <code>util.a</code> 文件。</p><p>并且，在执行前者的时候，会在 GOBIN 目录下生成名为 main 的可执行文件。</p><p>所以，运行 <code>go install</code> 命令，库源码包对应的 <code>.a</code> 文件会被放置到 <code>pkg</code> 目录下，命令源码包生成的可执行文件会被放到 GOBIN 目录。</p><p><code>go install</code> 在 GoPath 有多个目录的时候，会产生一些问题，具体可以去看郝林老师的 <code>Go 命令教程</code>，这里不展开了。</p><h2 id="go-run"><a href="#go-run" class="headerlink" title="go run"></a>go run</h2><p><code>go run</code> 用于编译并运行命令源码文件。</p><p>在 hello-world 项目的根目录，执行 go run 命令：</p><pre class=" language-shell"><code class="language-shell">go run -x -work src/main.go</code></pre><p>-x 可以打印整个过程涉及到的命令，-work 可以看到临时的工作目录：</p><p><img src="https://user-images.githubusercontent.com/7698088/60391387-ae2d3300-9b1f-11e9-9355-a8f59c2eac9b.png" alt="go run 过程"></p><p>从上图中可以看到，仍然是先编译，再连接，最后直接执行，并打印出了执行结果。</p><p>第一行打印的就是工作目录，最终生成的可执行文件就是放置于此：</p><p><img src="https://user-images.githubusercontent.com/7698088/60391357-30692780-9b1f-11e9-8be4-48041779e293.png" alt="go run 结果"></p><p>main 就是最终生成的可执行文件。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次的话题太大了，困难重重。从编译原理到 go 启动时的流程，到 go 命令原理，每个话题单独抽出来都可以写很多。</p><p>幸好有一些很不错的书和博客文章可以去参考。这篇文章就作为一个引子，你可以跟随参考资料里推荐的一些内容去发散。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【《程序员的自我修养》全书】<a href="https://book.douban.com/subject/3652388/" target="_blank" rel="noopener">https://book.douban.com/subject/3652388/</a></p><p>【面向信仰编程 编译过程概述】<a href="https://draveness.me/golang-compile-intro" target="_blank" rel="noopener">https://draveness.me/golang-compile-intro</a></p><p>【golang runtime 阅读】<a href="https://github.com/zboya/golang_runtime_reading">https://github.com/zboya/golang_runtime_reading</a></p><p>【Go-Questions hello-world项目】<a href="https://github.com/qcrao/Go-Questions/tree/master/examples/hello-world">https://github.com/qcrao/Go-Questions/tree/master/examples/hello-world</a></p><p>【雨痕大佬的 Go 语言学习笔记】<a href="https://github.com/qyuhen/book">https://github.com/qyuhen/book</a></p><p>【vim 以 16 进制文本】<a href="https://www.cnblogs.com/meibenjin/archive/2012/12/06/2806396.html" target="_blank" rel="noopener">https://www.cnblogs.com/meibenjin/archive/2012/12/06/2806396.html</a></p><p>【Go 编译命令执行过程】<a href="https://halfrost.com/go_command/" target="_blank" rel="noopener">https://halfrost.com/go_command/</a></p><p>【Go 命令执行过程】<a href="https://github.com/hyper0x/go_command_tutorial">https://github.com/hyper0x/go_command_tutorial</a></p><p>【Go 词法分析】<a href="https://ggaaooppeenngg.github.io/zh-CN/2016/04/01/go-lexer-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">https://ggaaooppeenngg.github.io/zh-CN/2016/04/01/go-lexer-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/</a></p><p>【曹大博客 golang 与 ast】<a href="http://xargin.com/ast/" target="_blank" rel="noopener">http://xargin.com/ast/</a></p><p>【Golang 词法解析器，scanner 源码分析】<a href="https://blog.csdn.net/zhaoruixiang1111/article/details/89892435" target="_blank" rel="noopener">https://blog.csdn.net/zhaoruixiang1111/article/details/89892435</a></p><p>【Gopath Explained】<a href="https://flaviocopes.com/go-gopath/" target="_blank" rel="noopener">https://flaviocopes.com/go-gopath/</a></p><p>【Understanding the GOPATH】<a href="https://www.digitalocean.com/community/tutorials/understanding-the-gopath" target="_blank" rel="noopener">https://www.digitalocean.com/community/tutorials/understanding-the-gopath</a></p><p>【讨论】<a href="https://stackoverflow.com/questions/7970390/what-should-be-the-values-of-gopath-and-goroot" target="_blank" rel="noopener">https://stackoverflow.com/questions/7970390/what-should-be-the-values-of-gopath-and-goroot</a></p><p>【Go 官方 Gopath】<a href="https://golang.org/cmd/go/#hdr-GOPATH_environment_variable" target="_blank" rel="noopener">https://golang.org/cmd/go/#hdr-GOPATH_environment_variable</a></p><p>【Go package 的探索】<a href="https://mp.weixin.qq.com/s/OizVLXfZ6EC1jI-NL7HqeA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/OizVLXfZ6EC1jI-NL7HqeA</a></p><p>【Go 官方 关于 Go 项目的组织结构】<a href="https://golang.org/doc/code.html" target="_blank" rel="noopener">https://golang.org/doc/code.html</a></p><p>【Go modules】<a href="https://www.melvinvivas.com/go-version-1-11-modules/" target="_blank" rel="noopener">https://www.melvinvivas.com/go-version-1-11-modules/</a></p><p>【Golang Installation, Setup, GOPATH, and Go Workspace】<a href="https://www.callicoder.com/golang-installation-setup-gopath-workspace/" target="_blank" rel="noopener">https://www.callicoder.com/golang-installation-setup-gopath-workspace/</a></p><p>【编译、链接过程链接】<a href="https://mikespook.com/2013/11/%E7%BF%BB%E8%AF%91-go-build-%E5%91%BD%E4%BB%A4%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F/" target="_blank" rel="noopener">https://mikespook.com/2013/11/%E7%BF%BB%E8%AF%91-go-build-%E5%91%BD%E4%BB%A4%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F/</a></p><p>【1.5 编译器由 go 语言完成】<a href="https://www.infoq.cn/article/2015/08/go-1-5" target="_blank" rel="noopener">https://www.infoq.cn/article/2015/08/go-1-5</a></p><p>【Go 编译过程系列文章】<a href="https://www.ctolib.com/topics-3724.html" target="_blank" rel="noopener">https://www.ctolib.com/topics-3724.html</a></p><p>【曹大 go bootstrap】<a href="https://github.com/cch123/golang-notes/blob/master/bootstrap.md">https://github.com/cch123/golang-notes/blob/master/bootstrap.md</a></p><p>【golang 启动流程】<a href="https://blog.iceinto.com/posts/go/start/" target="_blank" rel="noopener">https://blog.iceinto.com/posts/go/start/</a></p><p>【探索 golang 程序启动过程】<a href="http://cbsheng.github.io/posts/%E6%8E%A2%E7%B4%A2golang%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/" target="_blank" rel="noopener">http://cbsheng.github.io/posts/%E6%8E%A2%E7%B4%A2golang%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</a></p><p>【探索 goroutine 的创建】<a href="http://cbsheng.github.io/posts/%E6%8E%A2%E7%B4%A2goroutine%E7%9A%84%E5%88%9B%E5%BB%BA/" target="_blank" rel="noopener">http://cbsheng.github.io/posts/%E6%8E%A2%E7%B4%A2goroutine%E7%9A%84%E5%88%9B%E5%BB%BA/</a></p><p><img src="https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png" alt="QR"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;刚开始写这篇文章的时候，目标非常大，想要探索 Go 程序的一生：编码、编译、汇编、链接、运行、退出。它的每一步具体如何进行，力图弄清 Go 程序的这一生。&lt;/p&gt;
&lt;p&gt;在这个过程中，我又复习了一遍《程序员的自我修养》。这是一本讲编译、链接的书，非常详细，值得一看！数年前，
      
    
    </summary>
    
      <category term="编程语言" scheme="https://github.com/qcrao/qcrao.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="golang" scheme="https://github.com/qcrao/qcrao.github.io/tags/golang/"/>
    
      <category term="编译原理" scheme="https://github.com/qcrao/qcrao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>深度解密Go语言之channel</title>
    <link href="https://github.com/qcrao/qcrao.github.io/2019/07/22/dive-into-go-channel/"/>
    <id>https://github.com/qcrao/qcrao.github.io/2019/07/22/dive-into-go-channel/</id>
    <published>2019-07-22T00:40:00.000Z</published>
    <updated>2019-07-24T14:05:17.711Z</updated>
    
    <content type="html"><![CDATA[<p>大家好！“深度解密 Go 语言”系列好久未见，我们今天讲 channel，预祝阅读愉快！在开始正文之前，我们先说些题外话。</p><p>上一篇关于 Go 语言的文章讲 Go 程序的整个编码、编译、运行、退出的全过程。文章发出后，反响强烈，在各大平台的阅读量都不错。例如博客园登上了 48 小时阅读排行榜，并且受到了编辑推荐，占据首页头条位置整整一天；在开发者头条首页精选的位置霸榜一周时间……</p><p><img src="https://user-images.githubusercontent.com/7698088/61573877-801c8c80-aae8-11e9-9f3c-c364ec4d2726.png" alt="博客园头条推荐"></p><p><img src="https://user-images.githubusercontent.com/7698088/61576219-ce8e5300-ab09-11e9-9c9d-1cb244475812.png" alt="开发者头条精选"></p><p>熟悉码农桃花源的朋友们都知道，这里每篇文章都很长，要花很长时间才能读完。但长并不是目的，把每个问题都讲深、讲透才是最重要的。首先我自己得完全理解才行，所以写每篇文章时我都会看很多参考资料，看源码，请教大牛，自己还要去写样例代码跑结果……从创建文稿到真正完成写作需要很长时间。</p><p><img src="https://user-images.githubusercontent.com/7698088/61576233-05fcff80-ab0a-11e9-92a9-eef8fbd2f812.png" alt="写作时间"></p><p>做这些事情，无非是想力求我写出来的文字，都是我目前所能理解的最深层次。如果我暂时理解不了，我会说出来，或者不写进文章里面去，留到以后有能力的时候再来写。</p><p>我自己平时有这种体会：看微信公众号的文章都是想快速地看完，快速地拉到最后，目的快点开始看下一篇，新鲜感才能不断刺激大脑。有时候碰到长文很花时间，可能就没耐心看下去了，里面说的东西也觉得很难理解，可能直接就放弃了。但是，如果我知道一篇文章价值很高，就会选一个精力比较充沛的时间段，花整块时间看完，这时候反倒很容易看进去。这种情况下，潜意识里就会知道我今天是一定要读完这篇文章的，并且要把里面有价值的东西都吸收进来。</p><p>所以，对于码农桃花源的文章，我建议你收藏之后，找个空闲时间再好好看。</p><p>上周，我把 GitHub 项目 Go-Question 的内容整合成了开源电子书，阅读体验提升 N 倍，建议关注项目，现在已经 400 star 了，年底目标是 1k star。项目地址列在了参考资料里。</p><p><img src="https://user-images.githubusercontent.com/7698088/61576338-9ab42d00-ab0b-11e9-9ea1-9efc3c661ae1.png" alt="GitBook"></p><p>另外，公众号的文章也可以使用微信读书看，体验也非常赞，并且可以放到书架上，每个公众号就是一本书，简直酷炫。</p><p><img src="https://user-images.githubusercontent.com/7698088/61576313-2bd6d400-ab0b-11e9-8585-35b51d0493d8.png" alt="微信读书"></p><p>闲话最后，一直“吹”了很久的曹大，新书《Go 语言高级编程》出版了！书的另一位作者是柴树杉老师，这是给 Go 语言提交 pull 的人，他在 Go 语言上面的研究不用我多说了吧。我第一时间下了单，并且到曹大工位要了签名。</p> <img src="https://user-images.githubusercontent.com/7698088/61576352-cb946200-ab0b-11e9-9324-7cee1d74cf4a.png" width="600" height="400" alt="Go 语言高级编程" align="center"><p>这本书的推荐人有很多大佬，像许世伟，郝林，雨痕等，评价非常高。重点给大家看下雨痕老师对这本书的评价（上图第二排左侧图）：</p><blockquote><p>本书阐明了官方文档某些语焉不详的部分，有助于 Gopher 了解更多内在实现，以及日常工作中需要用到的 RPC、Web、分布式应用等内容。我认识本书作者之一曹春晖，对他的学习态度和能力颇为钦佩，因此推荐大家阅读本书。</p></blockquote><p>大家可能不知道，出书一点都不赚钱，但投入的精力却很大。但是像曹大在给读者的书签名时所说的：书籍是时代的生命。多少知识都是通过书本一代代传承！</p><p>搬过几次家就知道，纸质书太多，过程会比较痛苦。所以，我现在买纸书都会考虑再三。但是，这次我还是在第一时间下单了《Go 语言高级编程》。我也强烈推荐你买一本，支持原创者。</p><p>柴老师在武汉，我接触不多。但和曹大却是经常能见面（在同一个公司工作）。他本人经常活跃在各种微信群，社区，也非常乐于解答各种疑难杂症。上周还和曹大一起吃了个饭，请教了很多问题，我总结了一些对家都有用的东西，放在我的朋友圈：</p><p><img src="https://user-images.githubusercontent.com/7698088/61576424-815fb080-ab0c-11e9-8864-a7c32889487a.png" alt="曹大交流总结"></p><p>如果你想围观我的朋友圈，想和我交流，可以长按下面的二维码加我好友，备注下来自公众号。</p><p><img src="https://user-images.githubusercontent.com/7698088/61592413-7f2d4d00-ac05-11e9-9d8a-47f575862060.png" alt="wechat-QR"></p><p>好了，下面开始我们的正文。</p><h1 id="并发模型"><a href="#并发模型" class="headerlink" title="并发模型"></a>并发模型</h1><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>大家都知道著名的摩尔定律。1965 年，时任仙童公司的 Gordon Moore 发表文章，预测在未来十年，半导体芯片上的晶体管和电阻数量将每年增加一倍；1975 年，Moore 再次发表论文，将“每年”修改为“每两年”。这个预测在 2012 年左右基本是正确的。</p><p>但随着晶体管电路逐渐接近性能极限，摩尔定律终将走到尽头。靠增加晶体管数量来提高计算机的性能不灵了。于是，人们开始转换思路，用其他方法来提升计算机的性能，这就是多核计算机产生的原因。</p><p>这一招看起来还不错，但是人们又遇到了一个另一个定律的限制，那就是 Amdahl’s Law，它提出了一个模型用来衡量在并行模式下程序运行效率的提升。这个定律是说，一个程序能从并行上获得性能提升的上限取决于有多少代码必须写成串行的。</p><p>举个例子，对于一个和用户打交道的界面程序，它必须和用户打交道。用户点一个按钮，然后才能继续运行下一步，这必须是串行执行的。这种程序的运行效率就取决于和用户交互的速度，你有多少核都白瞎。用户就是不按下一步，你怎么办？</p><p>2000 年左右云计算兴起，人们可以方便地获取计算云上的资源，方便地水平扩展自己的服务，可以轻而易举地就调动多台机器资源甚至将计算任务分发到分布在全球范围的机器。但是也因此带来了很多问题和挑战。例如怎样在机器间进行通信、聚合结果等。最难的一个挑战是如何找到一个模型能用来描述 concurrent。</p><p>我们都知道，要想一段并发的代码没有任何 bug，是非常困难的。有些并发 bug 是在系统上线数年后才发现的，原因常常是很诡异的，比如用户数增加到了某个界限。</p><p>并发问题一般有下面这几种：</p><p>数据竞争。简单来说就是两个或多个线程同时读写某个变量，造成了预料之外的结果。</p><p>原子性。在一个定义好的上下文里，原子性操作不可分割。上下文的定义非常重要。有些代码，你在程序里看起来是原子的，如最简单的 i++，但在机器层面看来，这条语句通常需要几条指令来完成（Load，Incr，Store），不是不可分割的，也就不是原子性的。原子性可以让我们放心地构造并发安全的程序。</p><p>内存访问同步。代码中需要控制同时只有一个线程访问的区域称为临界区。Go 语言中一般使用 sync 包里的 Mutex 来完成同步访问控制。锁一般会带来比较大的性能开销，因此一般要考虑加锁的区域是否会频繁进入、锁的粒度如何控制等问题。</p><p>死锁。在一个死锁的程序里，每个线程都在等待其他线程，形成了一个首尾相连的尴尬局面，程序无法继续运行下去。</p><p>活锁。想象一下，你走在一条小路上，一个人迎面走来。你往左边走，想避开他；他做了相反的事情，他往右边走，结果两个都过不了。之后，两个人又都想从原来自己相反的方向走，还是同样的结果。这就是活锁，看起来都像在工作，但工作进度就是无法前进。</p><p>饥饿。并发的线程不能获取它所需要的资源以进行下一步的工作。通常是有一个非常贪婪的线程，长时间占据资源不释放，导致其他线程无法获得资源。</p><p>关于并发和并行的区别，引用一个经典的描述：</p><blockquote><p>并发是同一时间应对（dealing with）多件事情的能力。<br>并行是同一时间动手（doing）做多件事情的能力。</p></blockquote><p>雨痕老师《Go 语言学习笔记》上的解释：</p><blockquote><p>并发是指逻辑上具备同时处理多个任务的能力；并行则是物理上同时执行多个任务。</p></blockquote><p>而根据《Concurrency in Go》这本书，计算机的概念都是抽象的结果，并发和并行也不例外。它这样描述并发和并行的区别：</p><blockquote><p>Concurrency is a property of the code; parallelism is a property of the running program.</p></blockquote><p>并发是代码的特性，并行是正在运行的程序的特性。先忽略我拙劣的翻译。很新奇，不是吗？我也是第一次见到这样的说法，细想一下，还是很有道理的。</p><p>我们一直说写的代码是并发的或者是并行的，但是我们能提供什么保证吗？如果在只有一个核的机器上跑并行的代码，它还能并行吗？你就是再天才，也无法写出并行的程序。充其量也就是代码上看起来“并发”的，如此而已。</p><p>当然，表面上看起来还是并行的，但那不过 CPU 的障眼法，多个线程在分时共享 CPU 的资源，在一个粗糙的时间隔里看起来就是“并行”。</p><p>所以，我们实际上只能编写“并发”的代码，而不能编写“并行”的代码，而且只是希望并发的代码能够并行地执行。并发的代码能否并行，取决于抽象的层级：代码里的并发原语、runtime，操作系统（虚拟机、容器）。层级越来越底层，要求也越来越高。因此，我们谈并发或并行实际上要指定上下文，也就是抽象的层级。</p><p>《Concurrency in Go》书里举了一个例子：假如两个人同时打开电脑上的计算器程序，这两个程序肯定不会影响彼此，这就是并行。在这个例子中，上下文就是两个人的机器，而两个计算器进程就是并行的元素。</p><p>随着抽象层次的降低，并发模型实际上变得更难也更重要，而越低层次的并发模型对我们也越重要。要想并发程序正确地执行，就要深入研究并发模型。</p><p>在 Go 语言发布前，我们写并发代码时，考虑到的最底层抽象是：系统线程。Go 发布之后，在这条抽象链上，又加一个 goroutine。而且 Go 从著名的计算机科学家 Tony Hoare 那借来一个概念：channel。Tony Hoare 就是那篇著名文章《Communicating Sequential Processes》的作者。</p><p>看起来事情变得更加复杂，因为 Go 又引入了一个更底层的抽象，但事实并不是这样。因为 goroutine 并不是看起来的那样又抽象了一层，它其实是替代了系统线程。Gopher 在写代码的时候，并不会去关心系统线程，大部分时候只需要考虑到 goroutine 和 channel。当然有时候会用到一些共享内存的概念，一般就是指 sync 包里的东西，比如 sync.Mutex。</p><h2 id="什么是-CSP"><a href="#什么是-CSP" class="headerlink" title="什么是 CSP"></a>什么是 CSP</h2><p>CSP 经常被认为是 Go 在并发编程上成功的关键因素。CSP 全称是 “Communicating Sequential Processes”，这也是 Tony Hoare 在 1978 年发表在 ACM 的一篇论文。论文里指出一门编程语言应该重视 input 和 output 的原语，尤其是并发编程的代码。</p><p>在那篇文章发表的时代，人们正在研究模块化编程的思想，该不该用 goto 语句在当时是最激烈的议题。彼时，面向对象编程的思想正在崛起，几乎没什么人关心并发编程。</p><p>在文章中，CSP 也是一门自定义的编程语言，作者定义了输入输出语句，用于 processes 间的通信（communicatiton）。processes 被认为是需要输入驱动，并且产生输出，供其他 processes 消费，processes 可以是进程、线程、甚至是代码块。输入命令是：!，用来向 processes 写入；输出是：?，用来从 processes 读出。这篇文章要讲的 channel 正是借鉴了这一设计。</p><p>Hoare 还提出了一个 -&gt; 命令，如果 -&gt; 左边的语句返回 false，那它右边的语句就不会执行。</p><p>通过这些输入输出命令，Hoare 证明了如果一门编程语言中把 processes 间的通信看得第一等重要，那么并发编程的问题就会变得简单。</p><p>Go 是第一个将 CSP 的这些思想引入，并且发扬光大的语言。仅管内存同步访问控制（原文是 memory access synchronization）在某些情况下大有用处，Go 里也有相应的 sync 包支持，但是这在大型程序很容易出错。</p><p>Go 一开始就把 CSP 的思想融入到语言的核心里，所以并发编程成为 Go 的一个独特的优势，而且很容易理解。</p><p>大多数的编程语言的并发编程模型是基于线程和内存同步访问控制，Go 的并发编程的模型则用 goroutine 和 channel 来替代。Goroutine 和线程类似，channel 和 mutex (用于内存同步访问控制)类似。</p><p>Goroutine 解放了程序员，让我们更能贴近业务去思考问题。而不用考虑各种像线程库、线程开销、线程调度等等这些繁琐的底层问题，goroutine 天生替你解决好了。</p><p>Channel 则天生就可以和其他 channel 组合。我们可以把收集各种子系统结果的 channel 输入到同一个 channel。Channel 还可以和 select, cancel, timeout 结合起来。而 mutex 就没有这些功能。</p><p>Go 的并发原则非常优秀，目标就是简单：尽量使用 channel；把 goroutine 当作免费的资源，随便用。</p><p>说明一下，前面这两部分的内容来自英文开源书《Concurrency In Go》，强烈推荐阅读。</p><p>引入结束，我们正式开始今天的主角：channel。</p><h1 id="什么是-channel"><a href="#什么是-channel" class="headerlink" title="什么是 channel"></a>什么是 channel</h1><p>Goroutine 和 channel 是 Go 语言并发编程的 两大基石。Goroutine 用于执行并发任务，channel 用于 goroutine 之间的同步、通信。</p><p>Channel 在 gouroutine 间架起了一条管道，在管道里传输数据，实现 gouroutine 间的通信；由于它是线程安全的，所以用起来非常方便；channel 还提供“先进先出”的特性；它还能影响 goroutine 的阻塞和唤醒。</p><p>相信大家一定见过一句话：</p><blockquote><p>Do not communicate by sharing memory; instead, share memory by communicating.</p></blockquote><p>不要通过共享内存来通信，而要通过通信来实现内存共享。</p><p>这就是 Go 的并发哲学，它依赖 CSP 模型，基于 channel 实现。</p><p>简直是一头雾水，这两句话难道不是同一个意思？</p><p>通过前面两节的内容，我个人这样理解这句话：前面半句说的是通过 sync 包里的一些组件进行并发编程；而后面半句则是说 Go 推荐使用 channel 进行并发编程。两者其实都是必要且有效的。实际上看完本文后面对 channel 的源码分析，你会发现，channel 的底层就是通过 mutex 来控制并发的。只是 channel 是更高一层次的并发编程原语，封装了更多的功能。</p><p>关于是选择 sync 包里的底层并发编程原语还是 channel，《Concurrency In Go》这本书的第 2 章 “Go’s Philosophy on Concurrency” 里有一张决策树和详细的论述，再次推荐你去阅读。我把图贴出来：</p><p><img src="https://user-images.githubusercontent.com/7698088/61507065-e0db9480-aa16-11e9-9fab-2ba43ee90c95.png" alt="concurrency code decision tree"></p><h2 id="channel-实现-CSP"><a href="#channel-实现-CSP" class="headerlink" title="channel 实现 CSP"></a>channel 实现 CSP</h2><p>Channel 是 Go 语言中一个非常重要的类型，是 Go 里的第一对象。通过 channel，Go 实现了通过通信来实现内存共享。Channel 是在多个 goroutine 之间传递数据和同步的重要手段。</p><p>使用原子函数、读写锁可以保证资源的共享访问安全，但使用 channel 更优雅。</p><p>channel 字面意义是“通道”，类似于 Linux 中的管道。声明 channel 的语法如下：</p><pre class=" language-golang"><code class="language-golang">chan T // 声明一个双向通道chan<- T // 声明一个只能用于发送的通道<-chan T // 声明一个只能用于接收的通道</code></pre><p>单向通道的声明，用 <code>&lt;-</code> 来表示，它指明通道的方向。你只要明白，代码的书写顺序是从左到右就马上能掌握通道的方向是怎样的。</p><p>因为 channel 是一个引用类型，所以在它被初始化之前，它的值是 nil，channel 使用 make 函数进行初始化。可以向它传递一个 int 值，代表 channel 缓冲区的大小（容量），构造出来的是一个缓冲型的 channel；不传或传 0 的，构造的就是一个非缓冲型的 channel。</p><p>两者有一些差别：非缓冲型 channel 无法缓冲元素，对它的操作一定顺序是“发送-&gt; 接收 -&gt; 发送 -&gt; 接收 -&gt; ……”，如果连续向一个非缓冲 chan 发送 2 个元素，并且没有接收的话，第二次一定会被阻塞；对于缓冲型 channel 的操作，则要“宽松”一些，毕竟是带了“缓冲”光环。</p><h1 id="为什么要-channel"><a href="#为什么要-channel" class="headerlink" title="为什么要 channel"></a>为什么要 channel</h1><p>Go 通过 channel 实现 CSP 通信模型，主要用于 goroutine 之间的消息传递和事件通知。</p><p>有了 channel 和 goroutine 之后，Go 的并发编程变得异常容易和安全，得以让程序员把注意力留到业务上去，实现开发效率的提升。</p><p>要知道，技术并不是最重要的，它只是实现业务的工具。一门高效的开发语言让你把节省下来的时间，留着去做更有意义的事情，比如写写文章。</p><h1 id="channel-实现原理"><a href="#channel-实现原理" class="headerlink" title="channel 实现原理"></a>channel 实现原理</h1><p>对 chan 的发送和接收操作都会在编译期间转换成为底层的发送接收函数。</p><p>Channel 分为两种：带缓冲、不带缓冲。对不带缓冲的 channel 进行的操作实际上可以看作“同步模式”，带缓冲的则称为“异步模式”。</p><p>同步模式下，发送方和接收方要同步就绪，只有在两者都 ready 的情况下，数据才能在两者间传输（后面会看到，实际上就是内存拷贝）。否则，任意一方先行进行发送或接收操作，都会被挂起，等待另一方的出现才能被唤醒。</p><p>异步模式下，在缓冲槽可用的情况下（有剩余容量），发送和接收操作都可以顺利进行。否则，操作的一方（如写入）同样会被挂起，直到出现相反操作（如接收）才会被唤醒。</p><p>小结一下：同步模式下，必须要使发送方和接收方配对，操作才会成功，否则会被阻塞；异步模式下，缓冲槽要有剩余容量，操作才会成功，否则也会被阻塞。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>直接上源码（版本是 1.9.2）：</p><pre class=" language-golang"><code class="language-golang">type hchan struct {    // chan 里元素数量    qcount   uint    // chan 底层循环数组的长度    dataqsiz uint    // 指向底层循环数组的指针    // 只针对有缓冲的 channel    buf      unsafe.Pointer    // chan 中元素大小    elemsize uint16    // chan 是否被关闭的标志    closed   uint32    // chan 中元素类型    elemtype *_type // element type    // 已发送元素在循环数组中的索引    sendx    uint   // send index    // 已接收元素在循环数组中的索引    recvx    uint   // receive index    // 等待接收的 goroutine 队列    recvq    waitq  // list of recv waiters    // 等待发送的 goroutine 队列    sendq    waitq  // list of send waiters    // 保护 hchan 中所有字段    lock mutex}</code></pre><p>关于字段的含义都写在注释里了，再来重点说几个字段：</p><p><code>buf</code> 指向底层循环数组，只有缓冲型的 channel 才有。</p><p><code>sendx</code>，<code>recvx</code> 均指向底层循环数组，表示当前可以发送和接收的元素位置索引值（相对于底层数组）。</p><p><code>sendq</code>，<code>recvq</code> 分别表示被阻塞的 goroutine，这些 goroutine 由于尝试读取 channel 或向 channel 发送数据而被阻塞。</p><p><code>waitq</code> 是 <code>sudog</code> 的一个双向链表，而 <code>sudog</code> 实际上是对 goroutine 的一个封装：</p><pre class=" language-golang"><code class="language-golang">type waitq struct {    first *sudog    last  *sudog}</code></pre><p><code>lock</code> 用来保证每个读 channel 或写 channel 的操作都是原子的。</p><p>例如，创建一个容量为 6 的，元素为 int 型的 channel 数据结构如下 ：</p><p><img src="https://user-images.githubusercontent.com/7698088/61179068-806ee080-a62d-11e9-818c-16af42025b1b.png" alt="chan data structure"></p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>我们知道，通道有两个方向，发送和接收。理论上来说，我们可以创建一个只发送或只接收的通道，但是这种通道创建出来后，怎么使用呢？一个只能发的通道，怎么接收呢？同样，一个只能收的通道，如何向其发送数据呢？</p><p>一般而言，使用 <code>make</code> 创建一个能收能发的通道：</p><pre class=" language-golang"><code class="language-golang">// 无缓冲通道ch1 := make(chan int)// 有缓冲通道ch2 := make(chan int, 10)</code></pre><p>通过<a href="https://mp.weixin.qq.com/s/obnnVkO2EiFnuXk_AIDHWw" target="_blank" rel="noopener">汇编</a>分析，我们知道，最终创建 chan 的函数是 <code>makechan</code>：</p><pre class=" language-golang"><code class="language-golang">func makechan(t *chantype, size int64) *hchan</code></pre><p>从函数原型来看，创建的 chan 是一个指针。所以我们能在函数间直接传递 channel，而不用传递 channel 的指针。</p><p>具体来看下代码：</p><pre class=" language-golang"><code class="language-golang">const hchanSize = unsafe.Sizeof(hchan{}) + uintptr(-int(unsafe.Sizeof(hchan{}))&(maxAlign-1))func makechan(t *chantype, size int64) *hchan {    elem := t.elem    // 省略了检查 channel size，align 的代码    // ……    var c *hchan    // 如果元素类型不含指针 或者 size 大小为 0（无缓冲类型）    // 只进行一次内存分配    if elem.kind&kindNoPointers != 0 || size == 0 {        // 如果 hchan 结构体中不含指针，GC 就不会扫描 chan 中的元素        // 只分配 "hchan 结构体大小 + 元素大小*个数" 的内存        c = (*hchan)(mallocgc(hchanSize+uintptr(size)*elem.size, nil, true))        // 如果是缓冲型 channel 且元素大小不等于 0（大小等于 0的元素类型：struct{}）        if size > 0 && elem.size != 0 {            c.buf = add(unsafe.Pointer(c), hchanSize)        } else {            // race detector uses this location for synchronization            // Also prevents us from pointing beyond the allocation (see issue 9401).            // 1. 非缓冲型的，buf 没用，直接指向 chan 起始地址处            // 2. 缓冲型的，能进入到这里，说明元素无指针且元素类型为 struct{}，也无影响            // 因为只会用到接收和发送游标，不会真正拷贝东西到 c.buf 处（这会覆盖 chan的内容）            c.buf = unsafe.Pointer(c)        }    } else {        // 进行两次内存分配操作        c = new(hchan)        c.buf = newarray(elem, int(size))    }    c.elemsize = uint16(elem.size)    c.elemtype = elem    // 循环数组长度    c.dataqsiz = uint(size)    // 返回 hchan 指针    return c}</code></pre><p>新建一个 chan 后，内存在堆上分配，大概长这样：</p><p><img src="https://user-images.githubusercontent.com/7698088/61337268-4d179600-a867-11e9-98ac-f979e3da00a6.png" alt="make chan"></p><p>说明一下，这张图来源于 Gopher Con 上的一份 PPT，地址见参考资料。这份材料非常清晰易懂，推荐你去读。</p><p>接下来，我们用一个来自参考资料【深入 channel 底层】的例子来理解创建、发送、接收的整个过程。</p><pre class=" language-golang"><code class="language-golang">func goroutineA(a <-chan int) {    val := <- a    fmt.Println("G1 received data: ", val)    return}func goroutineB(b <-chan int) {    val := <- b    fmt.Println("G2 received data: ", val)    return}func main() {    ch := make(chan int)    go goroutineA(ch)    go goroutineB(ch)    ch <- 3    time.Sleep(time.Second)}</code></pre><p>首先创建了一个无缓冲的 channel，接着启动两个 goroutine，并将前面创建的 channel 传递进去。然后，向这个 channel 中发送数据 3，最后 sleep 1 秒后程序退出。</p><p>程序第 14 行创建了一个非缓冲型的 channel，我们只看 chan 结构体中的一些重要字段，来从整体层面看一下 chan 的状态，一开始什么都没有：</p><p><img src="https://user-images.githubusercontent.com/7698088/61338760-91a63000-a86d-11e9-9c7e-edee8a594f66.png" alt="unbuffered chan"></p><h2 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h2><p>在继续分析前面小节的例子前，我们先来看一下接收相关的源码。在清楚了接收的具体过程之后，也就能轻松理解具体的例子了。</p><p>接收操作有两种写法，一种带 “ok”，反应 channel 是否关闭；一种不带  “ok”，这种写法，当接收到相应类型的零值时无法知道是真实的发送者发送过来的值，还是 channel 被关闭后，返回给接收者的默认类型的零值。两种写法，都有各自的应用场景。</p><p>经过编译器的处理后，这两种写法最后对应源码里的这两个函数：</p><pre class=" language-golang"><code class="language-golang">// entry points for <- c from compiled codefunc chanrecv1(c *hchan, elem unsafe.Pointer) {    chanrecv(c, elem, true)}func chanrecv2(c *hchan, elem unsafe.Pointer) (received bool) {    _, received = chanrecv(c, elem, true)    return}</code></pre><p><code>chanrecv1</code> 函数处理不带 “ok” 的情形，<code>chanrecv2</code> 则通过返回 “received” 这个字段来反应 channel 是否被关闭。接收值则比较特殊，会“放到”参数 <code>elem</code> 所指向的地址了，这很像 C/C++ 里的写法。如果代码里忽略了接收值，这里的 elem 为 nil。</p><p>无论如何，最终转向了 <code>chanrecv</code> 函数：</p><pre class=" language-golang"><code class="language-golang">// 位于 src/runtime/chan.go// chanrecv 函数接收 channel c 的元素并将其写入 ep 所指向的内存地址。// 如果 ep 是 nil，说明忽略了接收值。// 如果 block == false，即非阻塞型接收，在没有数据可接收的情况下，返回 (false, false)// 否则，如果 c 处于关闭状态，将 ep 指向的地址清零，返回 (true, false)// 否则，用返回值填充 ep 指向的内存地址。返回 (true, true)// 如果 ep 非空，则应该指向堆或者函数调用者的栈func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {    // 省略 debug 内容 …………    // 如果是一个 nil 的 channel    if c == nil {        // 如果不阻塞，直接返回 (false, false)        if !block {            return        }        // 否则，接收一个 nil 的 channel，goroutine 挂起        gopark(nil, nil, "chan receive (nil chan)", traceEvGoStop, 2)        // 不会执行到这里        throw("unreachable")    }    // 在非阻塞模式下，快速检测到失败，不用获取锁，快速返回    // 当我们观察到 channel 没准备好接收：    // 1. 非缓冲型，等待发送列队 sendq 里没有 goroutine 在等待    // 2. 缓冲型，但 buf 里没有元素    // 之后，又观察到 closed == 0，即 channel 未关闭。    // 因为 channel 不可能被重复打开，所以前一个观测的时候 channel 也是未关闭的，    // 因此在这种情况下可以直接宣布接收失败，返回 (false, false)    if !block && (c.dataqsiz == 0 && c.sendq.first == nil ||        c.dataqsiz > 0 && atomic.Loaduint(&c.qcount) == 0) &&        atomic.Load(&c.closed) == 0 {        return    }    var t0 int64    if blockprofilerate > 0 {        t0 = cputicks()    }    // 加锁    lock(&c.lock)    // channel 已关闭，并且循环数组 buf 里没有元素    // 这里可以处理非缓冲型关闭 和 缓冲型关闭但 buf 无元素的情况    // 也就是说即使是关闭状态，但在缓冲型的 channel，    // buf 里有元素的情况下还能接收到元素    if c.closed != 0 && c.qcount == 0 {        if raceenabled {            raceacquire(unsafe.Pointer(c))        }        // 解锁        unlock(&c.lock)        if ep != nil {            // 从一个已关闭的 channel 执行接收操作，且未忽略返回值            // 那么接收的值将是一个该类型的零值            // typedmemclr 根据类型清理相应地址的内存            typedmemclr(c.elemtype, ep)        }        // 从一个已关闭的 channel 接收，selected 会返回true        return true, false    }    // 等待发送队列里有 goroutine 存在，说明 buf 是满的    // 这有可能是：    // 1. 非缓冲型的 channel    // 2. 缓冲型的 channel，但 buf 满了    // 针对 1，直接进行内存拷贝（从 sender goroutine -> receiver goroutine）    // 针对 2，接收到循环数组头部的元素，并将发送者的元素放到循环数组尾部    if sg := c.sendq.dequeue(); sg != nil {        // Found a waiting sender. If buffer is size 0, receive value        // directly from sender. Otherwise, receive from head of queue        // and add sender's value to the tail of the queue (both map to        // the same buffer slot because the queue is full).        recv(c, sg, ep, func() { unlock(&c.lock) }, 3)        return true, true    }    // 缓冲型，buf 里有元素，可以正常接收    if c.qcount > 0 {        // 直接从循环数组里找到要接收的元素        qp := chanbuf(c, c.recvx)        // …………        // 代码里，没有忽略要接收的值，不是 "<- ch"，而是 "val <- ch"，ep 指向 val        if ep != nil {            typedmemmove(c.elemtype, ep, qp)        }        // 清理掉循环数组里相应位置的值        typedmemclr(c.elemtype, qp)        // 接收游标向前移动        c.recvx++        // 接收游标归零        if c.recvx == c.dataqsiz {            c.recvx = 0        }        // buf 数组里的元素个数减 1        c.qcount--        // 解锁        unlock(&c.lock)        return true, true    }    if !block {        // 非阻塞接收，解锁。selected 返回 false，因为没有接收到值        unlock(&c.lock)        return false, false    }    // 接下来就是要被阻塞的情况了    // 构造一个 sudog    gp := getg()    mysg := acquireSudog()    mysg.releasetime = 0    if t0 != 0 {        mysg.releasetime = -1    }    // 待接收数据的地址保存下来    mysg.elem = ep    mysg.waitlink = nil    gp.waiting = mysg    mysg.g = gp    mysg.selectdone = nil    mysg.c = c    gp.param = nil    // 进入channel 的等待接收队列    c.recvq.enqueue(mysg)    // 将当前 goroutine 挂起    goparkunlock(&c.lock, "chan receive", traceEvGoBlockRecv, 3)    // 被唤醒了，接着从这里继续执行一些扫尾工作    if mysg != gp.waiting {        throw("G waiting list is corrupted")    }    gp.waiting = nil    if mysg.releasetime > 0 {        blockevent(mysg.releasetime-t0, 2)    }    closed := gp.param == nil    gp.param = nil    mysg.c = nil    releaseSudog(mysg)    return true, !closed}</code></pre><p>上面的代码注释地比较详细了，你可以对着源码一行行地去看，我们再来详细看一下。</p><ul><li><p>如果 channel 是一个空值（nil），在非阻塞模式下，会直接返回。在阻塞模式下，会调用 gopark 函数挂起 goroutine，这个会一直阻塞下去。因为在 channel 是 nil 的情况下，要想不阻塞，只有关闭它，但关闭一个 nil 的 channel 又会发生 panic，所以没有机会被唤醒了。更详细地可以在 closechan 函数的时候再看。</p></li><li><p>和发送函数一样，接下来搞了一个在非阻塞模式下，不用获取锁，快速检测到失败并且返回的操作。顺带插一句，我们平时在写代码的时候，找到一些边界条件，快速返回，能让代码逻辑更清晰，因为接下来的正常情况就比较少，更聚焦了，看代码的人也更能专注地看核心代码逻辑了。</p></li></ul><pre class=" language-golang"><code class="language-golang">    // 在非阻塞模式下，快速检测到失败，不用获取锁，快速返回 (false, false)    if !block && (c.dataqsiz == 0 && c.sendq.first == nil ||        c.dataqsiz > 0 && atomic.Loaduint(&c.qcount) == 0) &&        atomic.Load(&c.closed) == 0 {        return    }</code></pre><p>当我们观察到 channel 没准备好接收：</p><ol><li>非缓冲型，等待发送列队里没有 goroutine 在等待</li><li>缓冲型，但 buf 里没有元素</li></ol><p>之后，又观察到 closed == 0，即 channel 未关闭。</p><p>因为 channel 不可能被重复打开，所以前一个观测的时候， channel 也是未关闭的，因此在这种情况下可以直接宣布接收失败，快速返回。因为没被选中，也没接收到数据，所以返回值为 (false, false)。</p><ul><li><p>接下来的操作，首先会上一把锁，粒度比较大。如果 channel 已关闭，并且循环数组 buf 里没有元素。对应非缓冲型关闭和缓冲型关闭但 buf 无元素的情况，返回对应类型的零值，但 received 标识是 false，告诉调用者此 channel 已关闭，你取出来的值并不是正常由发送者发送过来的数据。但是如果处于 select 语境下，这种情况是被选中了的。很多将 channel 用作通知信号的场景就是命中了这里。</p></li><li><p>接下来，如果有等待发送的队列，说明 channel 已经满了，要么是非缓冲型的 channel，要么是缓冲型的 channel，但 buf 满了。这两种情况下都可以正常接收数据。</p></li></ul><p>于是，调用 recv 函数：</p><pre class=" language-golang"><code class="language-golang">func recv(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {    // 如果是非缓冲型的 channel    if c.dataqsiz == 0 {        if raceenabled {            racesync(c, sg)        }        // 未忽略接收的数据        if ep != nil {            // 直接拷贝数据，从 sender goroutine -> receiver goroutine            recvDirect(c.elemtype, sg, ep)        }    } else {        // 缓冲型的 channel，但 buf 已满。        // 将循环数组 buf 队首的元素拷贝到接收数据的地址        // 将发送者的数据入队。实际上这时 revx 和 sendx 值相等        // 找到接收游标        qp := chanbuf(c, c.recvx)        // …………        // 将接收游标处的数据拷贝给接收者        if ep != nil {            typedmemmove(c.elemtype, ep, qp)        }        // 将发送者数据拷贝到 buf        typedmemmove(c.elemtype, qp, sg.elem)        // 更新游标值        c.recvx++        if c.recvx == c.dataqsiz {            c.recvx = 0        }        c.sendx = c.recvx    }    sg.elem = nil    gp := sg.g    // 解锁    unlockf()    gp.param = unsafe.Pointer(sg)    if sg.releasetime != 0 {        sg.releasetime = cputicks()    }    // 唤醒发送的 goroutine。需要等到调度器的光临    goready(gp, skip+1)}</code></pre><p>如果是非缓冲型的，就直接从发送者的栈拷贝到接收者的栈。</p><pre class=" language-golang"><code class="language-golang">func recvDirect(t *_type, sg *sudog, dst unsafe.Pointer) {    // dst is on our stack or the heap, src is on another stack.    src := sg.elem    typeBitsBulkBarrier(t, uintptr(dst), uintptr(src), t.size)    memmove(dst, src, t.size)}</code></pre><p>否则，就是缓冲型 channel，而 buf 又满了的情形。说明发送游标和接收游标重合了，因此需要先找到接收游标：</p><pre class=" language-golang"><code class="language-golang">// chanbuf(c, i) is pointer to the i'th slot in the buffer.func chanbuf(c *hchan, i uint) unsafe.Pointer {    return add(c.buf, uintptr(i)*uintptr(c.elemsize))}</code></pre><p>将该处的元素拷贝到接收地址。然后将发送者待发送的数据拷贝到接收游标处。这样就完成了接收数据和发送数据的操作。接着，分别将发送游标和接收游标向前进一，如果发生“环绕”，再从 0 开始。</p><p>最后，取出 sudog 里的 goroutine，调用 goready 将其状态改成 “runnable”，待发送者被唤醒，等待调度器的调度。</p><ul><li><p>然后，如果 channel 的 buf 里还有数据，说明可以比较正常地接收。注意，这里，即使是在 channel 已经关闭的情况下，也是可以走到这里的。这一步比较简单，正常地将 buf 里接收游标处的数据拷贝到接收数据的地址。</p></li><li><p>到了最后一步，走到这里来的情形是要阻塞的。当然，如果 block 传进来的值是 false，那就不阻塞，直接返回就好了。</p></li></ul><p>先构造一个 sudog，接着就是保存各种值了。注意，这里会将接收数据的地址存储到了 <code>elem</code> 字段，当被唤醒时，接收到的数据就会保存到这个字段指向的地址。然后将 sudog 添加到 channel 的 recvq 队列里。调用 goparkunlock 函数将 goroutine 挂起。</p><p>接下来的代码就是 goroutine 被唤醒后的各种收尾工作了。</p><p>我们继续之前的例子。前面说到第 14 行，创建了一个非缓冲型的 channel，接着，第 15、16 行分别创建了一个 goroutine，各自执行了一个接收操作。通过前面的源码分析，我们知道，这两个 goroutine （后面称为 G1 和 G2 好了）都会被阻塞在接收操作。G1 和 G2 会挂在 channel 的 recq 队列中，形成一个双向循环链表。</p><p>在程序的 17 行之前，chan 的整体数据结构如下：</p><p><img src="https://user-images.githubusercontent.com/7698088/61179141-19eac200-a62f-11e9-836d-b6b95d52f6fb.png" alt="chan struct at the runtime"></p><p><code>buf</code> 指向一个长度为 0 的数组，qcount 为 0，表示 channel 中没有元素。重点关注 <code>recvq</code> 和 <code>sendq</code>，它们是 waitq 结构体，而 waitq 实际上就是一个双向链表，链表的元素是 sudog，里面包含 <code>g</code> 字段，<code>g</code> 表示一个 goroutine，所以 sudog 可以看成一个 goroutine。recvq 存储那些尝试读取 channel 但被阻塞的 goroutine，sendq 则存储那些尝试写入 channel，但被阻塞的 goroutine。</p><p>此时，我们可以看到，recvq 里挂了两个 goroutine，也就是前面启动的 G1 和 G2。因为没有 goroutine 接收，而 channel 又是无缓冲类型，所以 G1 和 G2 被阻塞。sendq 没有被阻塞的 goroutine。</p><p><code>recvq</code> 的数据结构如下。这里直接引用文章中的一幅图，用了三维元素，画得很好：</p><p><img src="https://user-images.githubusercontent.com/7698088/61179210-d3966280-a630-11e9-8c73-5a22340910a6.png" alt="recvq structure"></p><p>再从整体上来看一下 chan 此时的状态：</p><p><img src="https://user-images.githubusercontent.com/7698088/61340165-bbfaec00-a873-11e9-83de-66bc63e603f1.png" alt="chan state"></p><p>G1 和 G2 被挂起了，状态是 <code>WAITING</code>。关于 goroutine 调度器这块不是今天的重点，当然后面肯定会写相关的文章。这里先简单说下，goroutine 是用户态的协程，由 Go runtime 进行管理，作为对比，内核线程由 OS 进行管理。Goroutine 更轻量，因此我们可以轻松创建数万 goroutine。</p><p>一个内核线程可以管理多个 goroutine，当其中一个 goroutine 阻塞时，内核线程可以调度其他的 goroutine 来运行，内核线程本身不会阻塞。这就是通常我们说的 <code>M:N</code> 模型：</p><p><img src="https://user-images.githubusercontent.com/7698088/61340362-8c001880-a874-11e9-9237-d97e6105cd62.png" alt="M:N scheduling"></p><p><code>M:N</code> 模型通常由三部分构成：M、P、G。M 是内核线程，负责运行 goroutine；P 是 context，保存 goroutine 运行所需要的上下文，它还维护了可运行（runnable）的 goroutine 列表；G 则是待运行的 goroutine。M 和 P 是 G 运行的基础。</p><p><img src="https://user-images.githubusercontent.com/7698088/61340473-1183c880-a875-11e9-9b3e-86f376d3ae55.png" alt="MGP"></p><p>继续回到例子。假设我们只有一个 M，当 G1（<code>go goroutineA(ch)</code>） 运行到 <code>val := &lt;- a</code> 时，它由本来的 running 状态变成了 waiting 状态（调用了 gopark 之后的结果）：</p><p><img src="https://user-images.githubusercontent.com/7698088/61340756-45abb900-a876-11e9-8ac7-4c40b4c23253.png" alt="G1 running"></p><p>G1 脱离与 M 的关系，但调度器可不会让 M 闲着，所以会接着调度另一个 goroutine 来运行：</p><p><img src="https://user-images.githubusercontent.com/7698088/61340787-67a53b80-a876-11e9-94a4-a6c3698eb8ed.png" alt="G1 waiting"></p><p>G2 也是同样的遭遇。现在 G1 和 G2 都被挂起了，等待着一个 sender 往 channel 里发送数据，才能得到解救。</p><h2 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h2><p>接着上面的例子，G1 和 G2 现在都在 recvq 队列里了。</p><pre class=" language-golang"><code class="language-golang">ch <- 3</code></pre><p>第 17 行向 channel 发送了一个元素 3。</p><p>发送操作最终转化为 <code>chansend</code> 函数，直接上源码，同样大部分都注释了，可以看懂主流程：</p><pre class=" language-golang"><code class="language-golang">// 位于 src/runtime/chan.gofunc chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {    // 如果 channel 是 nil    if c == nil {        // 不能阻塞，直接返回 false，表示未发送成功        if !block {            return false        }        // 当前 goroutine 被挂起        gopark(nil, nil, "chan send (nil chan)", traceEvGoStop, 2)        throw("unreachable")    }    // 省略 debug 相关……    // 对于不阻塞的 send，快速检测失败场景    //    // 如果 channel 未关闭且 channel 没有多余的缓冲空间。这可能是：    // 1. channel 是非缓冲型的，且等待接收队列里没有 goroutine    // 2. channel 是缓冲型的，但循环数组已经装满了元素    if !block && c.closed == 0 && ((c.dataqsiz == 0 && c.recvq.first == nil) ||        (c.dataqsiz > 0 && c.qcount == c.dataqsiz)) {        return false    }    var t0 int64    if blockprofilerate > 0 {        t0 = cputicks()    }    // 锁住 channel，并发安全    lock(&c.lock)    // 如果 channel 关闭了    if c.closed != 0 {        // 解锁        unlock(&c.lock)        // 直接 panic        panic(plainError("send on closed channel"))    }    // 如果接收队列里有 goroutine，直接将要发送的数据拷贝到接收 goroutine    if sg := c.recvq.dequeue(); sg != nil {        send(c, sg, ep, func() { unlock(&c.lock) }, 3)        return true    }    // 对于缓冲型的 channel，如果还有缓冲空间    if c.qcount < c.dataqsiz {        // qp 指向 buf 的 sendx 位置        qp := chanbuf(c, c.sendx)        // ……        // 将数据从 ep 处拷贝到 qp        typedmemmove(c.elemtype, qp, ep)        // 发送游标值加 1        c.sendx++        // 如果发送游标值等于容量值，游标值归 0        if c.sendx == c.dataqsiz {            c.sendx = 0        }        // 缓冲区的元素数量加一        c.qcount++        // 解锁        unlock(&c.lock)        return true    }    // 如果不需要阻塞，则直接返回错误    if !block {        unlock(&c.lock)        return false    }    // channel 满了，发送方会被阻塞。接下来会构造一个 sudog    // 获取当前 goroutine 的指针    gp := getg()    mysg := acquireSudog()    mysg.releasetime = 0    if t0 != 0 {        mysg.releasetime = -1    }    mysg.elem = ep    mysg.waitlink = nil    mysg.g = gp    mysg.selectdone = nil    mysg.c = c    gp.waiting = mysg    gp.param = nil    // 当前 goroutine 进入发送等待队列    c.sendq.enqueue(mysg)    // 当前 goroutine 被挂起    goparkunlock(&c.lock, "chan send", traceEvGoBlockSend, 3)    // 从这里开始被唤醒了（channel 有机会可以发送了）    if mysg != gp.waiting {        throw("G waiting list is corrupted")    }    gp.waiting = nil    if gp.param == nil {        if c.closed == 0 {            throw("chansend: spurious wakeup")        }        // 被唤醒后，channel 关闭了。坑爹啊，panic        panic(plainError("send on closed channel"))    }    gp.param = nil    if mysg.releasetime > 0 {        blockevent(mysg.releasetime-t0, 2)    }    // 去掉 mysg 上绑定的 channel    mysg.c = nil    releaseSudog(mysg)    return true}</code></pre><p>上面的代码注释地比较详细了，我们来详细看看。</p><ul><li><p>如果检测到 channel 是空的，当前 goroutine 会被挂起。</p></li><li><p>对于不阻塞的发送操作，如果 channel 未关闭并且没有多余的缓冲空间（说明：a. channel 是非缓冲型的，且等待接收队列里没有 goroutine；b. channel 是缓冲型的，但循环数组已经装满了元素）</p></li></ul><p>对于这一点，runtime 源码里注释了很多。这一条判断语句是为了在不阻塞发送的场景下快速检测到发送失败，好快速返回。</p><pre class=" language-golang"><code class="language-golang">if !block && c.closed == 0 && ((c.dataqsiz == 0 && c.recvq.first == nil) || (c.dataqsiz > 0 && c.qcount == c.dataqsiz)) {    return false}</code></pre><p>注释里主要讲为什么这一块可以不加锁，我详细解释一下。<code>if</code> 条件里先读了两个变量：block 和 c.closed。block 是函数的参数，不会变；c.closed 可能被其他 goroutine 改变，因为没加锁嘛，这是“与”条件前面两个表达式。</p><p>最后一项，涉及到三个变量：c.dataqsiz，c.recvq.first，c.qcount。<code>c.dataqsiz == 0 &amp;&amp; c.recvq.first == nil</code> 指的是非缓冲型的 channel，并且 recvq 里没有等待接收的 goroutine；<code>c.dataqsiz &gt; 0 &amp;&amp; c.qcount == c.dataqsiz</code> 指的是缓冲型的 channel，但循环数组已经满了。这里 <code>c.dataqsiz</code> 实际上也是不会被修改的，在创建的时候就已经确定了。不加锁真正影响地是 <code>c.qcount</code> 和 <code>c.recvq.first</code>。</p><p>这一部分的条件就是两个 <code>word-sized read</code>，就是读两个 word 操作：<code>c.closed</code> 和 <code>c.recvq.first</code>（非缓冲型） 或者 <code>c.qcount</code>（缓冲型）。</p><p>当我们发现 <code>c.closed == 0</code> 为真，也就是 channel 未被关闭，再去检测第三部分的条件时，观测到 <code>c.recvq.first == nil</code> 或者 <code>c.qcount == c.dataqsiz</code> 时（这里忽略 <code>c.dataqsiz</code>），就断定要将这次发送操作作失败处理，快速返回 false。</p><p>这里涉及到两个观测项：channel 未关闭、channel not ready for sending。这两项都会因为没加锁而出现观测前后不一致的情况。例如我先观测到 channel 未被关闭，再观察到 channel not ready for sending，这时我以为能满足这个 if 条件了，但是如果这时 c.closed 变成 1，这时其实就不满足条件了，谁让你不加锁呢！</p><p>但是，因为一个 closed channel 不能将 channel 状态从 ‘ready for sending’ 变成 ‘not ready for sending’，所以当我观测到 ‘not ready for sending’ 时，channel 不是 closed。即使 <code>c.closed == 1</code>，即 channel 是在这两个观测中间被关闭的，那也说明在这两个观测中间，channel 满足两个条件：<code>not closed</code> 和 <code>not ready for sending</code>，这时，我直接返回 false 也是没有问题的。</p><p>这部分解释地比较绕，其实这样做的目的就是少获取一次锁，提升性能。</p><ul><li><p>如果检测到 channel 已经关闭，直接 panic。</p></li><li><p>如果能从等待接收队列 recvq 里出队一个 sudog（代表一个 goroutine），说明此时 channel 是空的，没有元素，所以才会有等待接收者。这时会调用 send 函数将元素直接从发送者的栈拷贝到接收者的栈，关键操作由 <code>sendDirect</code> 函数完成。</p></li></ul><pre class=" language-golang"><code class="language-golang">// send 函数处理向一个空的 channel 发送操作// ep 指向被发送的元素，会被直接拷贝到接收的 goroutine// 之后，接收的 goroutine 会被唤醒// c 必须是空的（因为等待队列里有 goroutine，肯定是空的）// c 必须被上锁，发送操作执行完后，会使用 unlockf 函数解锁// sg 必须已经从等待队列里取出来了// ep 必须是非空，并且它指向堆或调用者的栈func send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {    // 省略一些用不到的    // ……    // sg.elem 指向接收到的值存放的位置，如 val <- ch，指的就是 &val    if sg.elem != nil {        // 直接拷贝内存（从发送者到接收者）        sendDirect(c.elemtype, sg, ep)        sg.elem = nil    }    // sudog 上绑定的 goroutine    gp := sg.g    // 解锁    unlockf()    gp.param = unsafe.Pointer(sg)    if sg.releasetime != 0 {        sg.releasetime = cputicks()    }    // 唤醒接收的 goroutine. skip 和打印栈相关，暂时不理会    goready(gp, skip+1)}</code></pre><p>继续看 <code>sendDirect</code> 函数：</p><pre class=" language-golang"><code class="language-golang">// 向一个非缓冲型的 channel 发送数据、从一个无元素的（非缓冲型或缓冲型但空）的 channel// 接收数据，都会导致一个 goroutine 直接操作另一个 goroutine 的栈// 由于 GC 假设对栈的写操作只能发生在 goroutine 正在运行中并且由当前 goroutine 来写// 所以这里实际上违反了这个假设。可能会造成一些问题，所以需要用到写屏障来规避func sendDirect(t *_type, sg *sudog, src unsafe.Pointer) {    // src 在当前 goroutine 的栈上，dst 是另一个 goroutine 的栈    // 直接进行内存"搬迁"    // 如果目标地址的栈发生了栈收缩，当我们读出了 sg.elem 后    // 就不能修改真正的 dst 位置的值了    // 因此需要在读和写之前加上一个屏障    dst := sg.elem    typeBitsBulkBarrier(t, uintptr(dst), uintptr(src), t.size)    memmove(dst, src, t.size)}</code></pre><p>这里涉及到一个 goroutine 直接写另一个 goroutine 栈的操作，一般而言，不同 goroutine 的栈是各自独有的。而这也违反了 GC 的一些假设。为了不出问题，写的过程中增加了写屏障，保证正确地完成写操作。这样做的好处是减少了一次内存 copy：不用先拷贝到 channel 的 buf，直接由发送者到接收者，没有中间商赚差价，效率得以提高，完美。</p><p>然后，解锁、唤醒接收者，等待调度器的光临，接收者也得以重见天日，可以继续执行接收操作之后的代码了。</p><ul><li>如果 <code>c.qcount &lt; c.dataqsiz</code>，说明缓冲区可用（肯定是缓冲型的 channel）。先通过函数取出待发送元素应该去到的位置：</li></ul><pre class=" language-golang"><code class="language-golang">qp := chanbuf(c, c.sendx)// 返回循环队列里第 i 个元素的地址处func chanbuf(c *hchan, i uint) unsafe.Pointer {    return add(c.buf, uintptr(i)*uintptr(c.elemsize))}</code></pre><p><code>c.sendx</code> 指向下一个待发送元素在循环数组中的位置，然后调用 <code>typedmemmove</code> 函数将其拷贝到循环数组中。之后 <code>c.sendx</code> 加 1，元素总量加 1 ：<code>c.qcount++</code>，最后，解锁并返回。</p><ul><li><p>如果没有命中以上条件的，说明 channel 已经满了。不管这个 channel 是缓冲型的还是非缓冲型的，都要将这个 sender “关起来”（goroutine 被阻塞）。如果 block 为 false，直接解锁，返回 false。</p></li><li><p>最后就是真的需要被阻塞的情况。先构造一个 sudog，将其入队（channel 的 sendq 字段）。然后调用 <code>goparkunlock</code> 将当前 goroutine 挂起，并解锁，等待合适的时机再唤醒。</p></li></ul><p>唤醒之后，从 <code>goparkunlock</code> 下一行代码开始继续往下执行。</p><p>这里有一些绑定操作，sudog 通过 g 字段绑定 goroutine，而 goroutine 通过 waiting 绑定 sudog，sudog 还通过 <code>elem</code> 字段绑定待发送元素的地址，以及 <code>c</code> 字段绑定被“坑”在此处的 channel。</p><p>所以，待发送的元素地址其实是存储在 sudog 结构体里，也就是当前 goroutine 里。</p><p>好了，看完源码。我们接着来分析例子，相信大家已经把例子忘得差不多了，我再贴一下代码：</p><pre class=" language-golang"><code class="language-golang">func goroutineA(a <-chan int) {    val := <- a    fmt.Println("goroutine A received data: ", val)    return}func goroutineB(b <-chan int) {    val := <- b    fmt.Println("goroutine B received data: ", val)    return}func main() {    ch := make(chan int)    go goroutineA(ch)    go goroutineB(ch)    ch <- 3    time.Sleep(time.Second)    ch1 := make(chan struct{})}</code></pre><p>在发送小节里我们说到 G1 和 G2 现在被挂起来了，等待 sender 的解救。在第 17 行，主协程向 ch 发送了一个元素 3，来看下接下来会发生什么。</p><p>根据前面源码分析的结果，我们知道，sender 发现 ch 的 recvq 里有 receiver 在等待着接收，就会出队一个 sudog，把 recvq 里 first 指针的 sudo “推举”出来了，并将其加入到 P 的可运行 goroutine 队列中。</p><p>然后，sender 把发送元素拷贝到 sudog 的 elem 地址处，最后会调用 goready 将 G1 唤醒，状态变为 runnable。</p><p><img src="https://user-images.githubusercontent.com/7698088/61342598-4bf16380-a87d-11e9-8667-c22b02030d6b.png" alt="G1 runnable"></p><p>当调度器光顾 G1 时，将 G1 变成 running 状态，执行 goroutineA 接下来的代码。G 表示其他可能有的 goroutine。</p><p>这里其实涉及到一个协程写另一个协程栈的操作。有两个 receiver 在 channel 的一边虎视眈眈地等着，这时 channel 另一边来了一个 sender 准备向 channel 发送数据，为了高效，用不着通过 channel 的 buf “中转”一次，直接从源地址把数据 copy 到目的地址就可以了，效率高啊！</p><p><img src="https://user-images.githubusercontent.com/7698088/61342620-64fa1480-a87d-11e9-8cac-eacd2f4892f8.png" alt="send direct"></p><p>上图是一个示意图，<code>3</code> 会被拷贝到 G1 栈上的某个位置，也就是 val 的地址处，保存在 elem 字段。</p><h2 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h2><p>关闭某个 channel，会执行函数 <code>closechan</code>：</p><pre class=" language-golang"><code class="language-golang">func closechan(c *hchan) {    // 关闭一个 nil channel，panic    if c == nil {        panic(plainError("close of nil channel"))    }    // 上锁    lock(&c.lock)    // 如果 channel 已经关闭    if c.closed != 0 {        unlock(&c.lock)        // panic        panic(plainError("close of closed channel"))    }    // …………    // 修改关闭状态    c.closed = 1    var glist *g    // 将 channel 所有等待接收队列的里 sudog 释放    for {        // 从接收队列里出队一个 sudog        sg := c.recvq.dequeue()        // 出队完毕，跳出循环        if sg == nil {            break        }        // 如果 elem 不为空，说明此 receiver 未忽略接收数据        // 给它赋一个相应类型的零值        if sg.elem != nil {            typedmemclr(c.elemtype, sg.elem)            sg.elem = nil        }        if sg.releasetime != 0 {            sg.releasetime = cputicks()        }        // 取出 goroutine        gp := sg.g        gp.param = nil        if raceenabled {            raceacquireg(gp, unsafe.Pointer(c))        }        // 相连，形成链表        gp.schedlink.set(glist)        glist = gp    }    // 将 channel 等待发送队列里的 sudog 释放    // 如果存在，这些 goroutine 将会 panic    for {        // 从发送队列里出队一个 sudog        sg := c.sendq.dequeue()        if sg == nil {            break        }        // 发送者会 panic        sg.elem = nil        if sg.releasetime != 0 {            sg.releasetime = cputicks()        }        gp := sg.g        gp.param = nil        if raceenabled {            raceacquireg(gp, unsafe.Pointer(c))        }        // 形成链表        gp.schedlink.set(glist)        glist = gp    }    // 解锁    unlock(&c.lock)    // Ready all Gs now that we've dropped the channel lock.    // 遍历链表    for glist != nil {        // 取最后一个        gp := glist        // 向前走一步，下一个唤醒的 g        glist = glist.schedlink.ptr()        gp.schedlink = 0        // 唤醒相应 goroutine        goready(gp, 3)    }}</code></pre><p>close 逻辑比较简单，对于一个 channel，recvq 和 sendq 中分别保存了阻塞的发送者和接收者。关闭 channel 后，对于等待接收者而言，会收到一个相应类型的零值。对于等待发送者，会直接 panic。所以，在不了解 channel 还有没有接收者的情况下，不能贸然关闭 channel。</p><p>close 函数先上一把大锁，接着把所有挂在这个 channel 上的 sender 和 receiver 全都连成一个 sudog 链表，再解锁。最后，再将所有的 sudog 全都唤醒。</p><p>唤醒之后，该干嘛干嘛。sender 会继续执行 chansend 函数里 goparkunlock 函数之后的代码，很不幸，检测到 channel 已经关闭了，panic。receiver 则比较幸运，进行一些扫尾工作后，返回。这里，selected 返回 true，而返回值 received 则要根据 channel 是否关闭，返回不同的值。如果 channel 关闭，received 为 false，否则为 true。这我们分析的这种情况下，received 返回 false。</p><h1 id="channel-进阶"><a href="#channel-进阶" class="headerlink" title="channel 进阶"></a>channel 进阶</h1><p>总结一下操作 channel 的结果：</p><table><thead><tr><th>操作</th><th>nil channel</th><th>closed channel</th><th>not nil, not closed channel</th></tr></thead><tbody><tr><td>close</td><td>panic</td><td>panic</td><td>正常关闭</td></tr><tr><td>读 &lt;- ch</td><td>阻塞</td><td>读到对应类型的零值</td><td>阻塞或正常读取数据。缓冲型 channel 为空或非缓冲型 channel 没有等待发送者时会阻塞</td></tr><tr><td>写 ch &lt;-</td><td>阻塞</td><td>panic</td><td>阻塞或正常写入数据。非缓冲型 channel 没有等待接收者或缓冲型 channel buf 满时会被阻塞</td></tr></tbody></table><p>总结一下，发生 panic 的情况有三种：向一个关闭的 channel 进行写操作；关闭一个 nil 的 channel；重复关闭一个 channel。</p><p>读、写一个 nil channel 都会被阻塞。</p><h2 id="发送和接收元素的本质"><a href="#发送和接收元素的本质" class="headerlink" title="发送和接收元素的本质"></a>发送和接收元素的本质</h2><p>Channel 发送和接收元素的本质是什么？参考资料【深入 channel 底层】里是这样回答的：</p><blockquote><p>Remember all transfer of value on the go channels happens with the copy of value.</p></blockquote><p>就是说 channel 的发送和接收操作本质上都是 “值的拷贝”，无论是从 sender goroutine 的栈到 chan buf，还是从 chan buf 到 receiver goroutine，或者是直接从 sender goroutine 到 receiver goroutine。</p><p>这里再引用文中的一个例子，我会加上更加详细地解释。顺带说一下，这是一篇英文的博客，写得很好，没有像我们这篇文章那样大段的源码分析，它是将代码里情况拆开来各自描述的，各有利弊吧。推荐去读下原文，阅读体验比较好。</p><pre class=" language-golang"><code class="language-golang">type user struct {    name string    age int8}var u = user{name: "Ankur", age: 25}var g = &ufunc modifyUser(pu *user) {    fmt.Println("modifyUser Received Vaule", pu)    pu.name = "Anand"}func printUser(u <-chan *user) {    time.Sleep(2 * time.Second)    fmt.Println("printUser goRoutine called", <-u)}func main() {    c := make(chan *user, 5)    c <- g    fmt.Println(g)    // modify g    g = &user{name: "Ankur Anand", age: 100}    go printUser(c)    go modifyUser(g)    time.Sleep(5 * time.Second)    fmt.Println(g)}</code></pre><p>运行结果：</p><pre class=" language-shell"><code class="language-shell">&{Ankur 25}modifyUser Received Value &{Ankur Anand 100}printUser goRoutine called &{Ankur 25}&{Anand 100}</code></pre><p>这里就是一个很好的 <code>share memory by communicating</code> 的例子。</p><p><img src="https://user-images.githubusercontent.com/7698088/61191276-16ad1000-a6db-11e9-9729-cdea7744f002.png" alt="output"></p><p>一开始构造一个结构体 u，地址是 0x56420，图中地址上方就是它的内容。接着把 <code>&amp;u</code> 赋值给指针 <code>g</code>，g 的地址是 0x565bb0，它的内容就是一个地址，指向 u。</p><p>main 程序里，先把 g 发送到 c，根据 <code>copy value</code> 的本质，进入到 chan buf 里的就是 <code>0x56420</code>，它是指针 g 的值（不是它指向的内容），所以打印从 channel 接收到的元素时，它就是 <code>&amp;{Ankur 25}</code>。因此，这里并不是将指针 g “发送” 到了 channel 里，只是拷贝它的值而已。</p><p>再强调一次：</p><blockquote><p>Remember all transfer of value on the go channels happens with the copy of value.</p></blockquote><h2 id="资源泄漏"><a href="#资源泄漏" class="headerlink" title="资源泄漏"></a>资源泄漏</h2><p>Channel 可能会引发 goroutine 泄漏。</p><p>泄漏的原因是 goroutine 操作 channel 后，处于发送或接收阻塞状态，而 channel 处于满或空的状态，一直得不到改变。同时，垃圾回收器也不会回收此类资源，进而导致 gouroutine 会一直处于等待队列中，不见天日。</p><p>雨痕老师的《Go 语言学习笔记》第 8 章通道的“资源泄露”一节举了个例子，大家可以自己去看。</p><h2 id="happened-before"><a href="#happened-before" class="headerlink" title="happened before"></a>happened before</h2><p>维基百科上给的定义：</p><blockquote><p>In computer science, the happened-before relation (denoted: -&gt;) is a relation between the result of two events, such that if one event should happen before another event, the result must reflect that, even if those events are in reality executed out of order (usually to optimize program flow).</p></blockquote><p>简单来说就是如果事件 a 和事件 b 存在 happened-before 关系，即 a -&gt; b，那么 a，b 完成后的结果一定要体现这种关系。由于现代编译器、CPU 会做各种优化，包括编译器重排、内存重排等等，在并发代码里，happened-before 限制就非常重要了。</p><p>根据晃岳攀老师在 Gopher China 2019 上的并发编程分享，关于 channel 的发送（send）、发送完成（send finished）、接收（receive）、接收完成（receive finished）的 happened-before 关系如下：</p><ol><li>第 n 个 <code>send</code> 一定 <code>happened before</code> 第 n 个 <code>receive finished</code>，无论是缓冲型还是非缓冲型的 channel。</li><li>对于容量为 m 的缓冲型 channel，第 n 个 <code>receive</code> 一定 <code>happened before</code> 第 n+m 个 <code>send finished</code>。</li><li>对于非缓冲型的 channel，第 n 个 <code>receive</code> 一定 <code>happened before</code> 第 n 个 <code>send finished</code>。</li><li>channel close 一定 <code>happened before</code> receiver 得到通知。</li></ol><p>我们来逐条解释一下。</p><p>第一条，我们从源码的角度看也是对的，send 不一定是 <code>happened before</code> receive，因为有时候是先 receive，然后 goroutine 被挂起，之后被 sender 唤醒，send happened after receive。但不管怎样，要想完成接收，一定是要先有发送。</p><p>第二条，缓冲型的 channel，当第 n+m 个 send 发生后，有下面两种情况：</p><p>若第 n 个 receive 没发生。这时，channel 被填满了，send 就会被阻塞。那当第 n 个 receive 发生时，sender goroutine 会被唤醒，之后再继续发送过程。这样，第 n 个 <code>receive</code> 一定 <code>happened before</code> 第 n+m 个 <code>send finished</code>。</p><p>若第 n 个 receive 已经发生过了，这直接就符合了要求。</p><p>第三条，也是比较好理解的。第 n 个 send 如果被阻塞，sender goroutine 挂起，第 n 个 receive 这时到来，先于第 n 个 send finished。如果第 n 个 send 未被阻塞，说明第 n 个 receive 早就在那等着了，它不仅 happened before send finished，它还 happened before send。</p><p>第四条，回忆一下源码，先设置完 closed = 1，再唤醒等待的 receiver，并将零值拷贝给 receiver。</p><p>参考资料【鸟窝 并发编程分享】这篇博文的评论区有 PPT 的下载链接，这是晁老师在 Gopher 2019 大会上的演讲。</p><p>关于 happened before，这里再介绍一个柴大和曹大的新书《Go 语言高级编程》里面提到的一个例子。</p><p>书中 1.5 节先讲了顺序一致性的内存模型，这是并发编程的基础。</p><p>我们直接来看例子：</p><pre class=" language-golang"><code class="language-golang">var done = make(chan bool)var msg stringfunc aGoroutine() {    msg = "hello, world"    done <- true}func main() {    go aGoroutine()    <-done    println(msg)}</code></pre><p>先定义了一个 done channel 和一个待打印的字符串。在 main 函数里，启动一个 goroutine，等待从 done 里接收到一个值后，执行打印 msg 的操作。如果 main 函数中没有 <code>&lt;-done</code> 这行代码，打印出来的 msg 为空，因为 aGoroutine 来不及被调度，还来不及给 msg 赋值，主程序就会退出。而在 Go 语言里，主协程退出时不会等待其他协程。</p><p>加了 <code>&lt;-done</code> 这行代码后，就会阻塞在此。等 aGoroutine 里向 done 发送了一个值之后，才会被唤醒，继续执行打印 msg 的操作。而这在之前，msg 已经被赋值过了，所以会打印出 <code>hello, world</code>。</p><p>这里依赖的 happened before 就是前面讲的第一条。第一个 send 一定 happened before 第一个 receive finished，即 <code>done &lt;- true</code> 先于 <code>&lt;-done</code> 发生，这意味着 main 函数里执行完 <code>&lt;-done</code> 后接着执行 <code>println(msg)</code> 这一行代码时，msg 已经被赋过值了，所以会打印出想要的结果。</p><p>书中，又进一步利用前面提到的第 3 条 happened before 规则，修改了一下代码：</p><pre class=" language-golang"><code class="language-golang">var done = make(chan bool)var msg stringfunc aGoroutine() {    msg = "hello, world"    <-done}func main() {    go aGoroutine()    done <- true    println(msg)}</code></pre><p>同样可以得到相同的结果，为什么？根据第三条规则，对于非缓冲型的 channel，第一个 receive 一定 happened before 第一个 send finished。也就是说，<br>在 <code>done &lt;- true</code> 完成之前，<code>&lt;-done</code> 就已经发生了，也就意味着 msg 已经被赋上值了，最终也会打印出 <code>hello, world</code>。</p><h2 id="如何优雅地关闭-channel"><a href="#如何优雅地关闭-channel" class="headerlink" title="如何优雅地关闭 channel"></a>如何优雅地关闭 channel</h2><p>这部分内容主要来自 Go 101 上的一篇英文文章，参考资料【如何优雅地关闭 channel】可以直达原文。</p><p>文章先“吐槽”了下 Go channel 在设计上的一些问题，接着给出了几种不同情况下如何优雅地关闭 channel 的例子。按照惯例，我会在原作者内容的基础上给出自己的解读，看完这一节你可以再回头看一下英文原文，会觉得很有意思。</p><p>关于 channel 的使用，有几点不方便的地方：</p><ol><li>在不改变 channel 自身状态的情况下，无法获知一个 channel 是否关闭。</li><li>关闭一个 closed channel 会导致 panic。所以，如果关闭 channel 的一方在不知道 channel 是否处于关闭状态时就去贸然关闭 channel 是很危险的事情。</li><li>向一个 closed channel 发送数据会导致 panic。所以，如果向 channel 发送数据的一方不知道 channel 是否处于关闭状态时就去贸然向 channel 发送数据是很危险的事情。</li></ol><p>文中还真的就给出了一个检查 channel 是否关闭的函数：</p><pre class=" language-golang"><code class="language-golang">func IsClosed(ch <-chan T) bool {    select {    case <-ch:        return true    default:    }    return false}func main() {    c := make(chan T)    fmt.Println(IsClosed(c)) // false    close(c)    fmt.Println(IsClosed(c)) // true}</code></pre><p>看一下代码，其实存在很多问题。首先，IsClosed 函数是一个有副作用的函数。每调用一次，都会读出 channel 里的一个元素，改变了 channel 的状态。这不是一个好的函数，干活就干活，还顺手牵羊！</p><p>其次，IsClosed 函数返回的结果仅代表调用那个瞬间，并不能保证调用之后会不会有其他 goroutine 对它进行了一些操作，改变了它的这种状态。例如，IsClosed 函数返回 true，但这时有另一个 goroutine 关闭了 channel，而你还拿着这个过时的 “channel 未关闭”的信息，向其发送数据，就会导致 panic 的发生。当然，一个 channel 不会被重复关闭两次，如果 IsClosed 函数返回的结果是 true，说明 channel 是真的关闭了。</p><p>有一条广泛流传的关闭 channel 的原则：</p><blockquote><p>don’t close a channel from the receiver side and don’t close a channel if the channel has multiple concurrent senders.</p></blockquote><p>不要从一个 receiver 侧关闭 channel，也不要在有多个 sender 时，关闭 channel。</p><p>比较好理解，向 channel 发送元素的就是 sender，因此 sender 可以决定何时不发送数据，并且关闭 channel。但是如果有多个 sender，某个 sender 同样没法确定其他 sender 的情况，这时也不能贸然关闭 channel。</p><p>但是上面所说的并不是最本质的，最本质的原则就只有一条：</p><blockquote><p>don’t close (or send values to) closed channels.</p></blockquote><p>有两个不那么优雅地关闭 channel 的方法：</p><ol><li><p>使用 defer-recover 机制，放心大胆地关闭 channel 或者向 channel 发送数据。即使发生了 panic，有 defer-recover 在兜底。</p></li><li><p>使用 sync.Once 来保证只关闭一次。</p></li></ol><p>代码我就不贴上来了，直接去看原文。</p><p>这一节的重头戏来了，那应该如何优雅地关闭 channel？</p><p>根据 sender 和 receiver 的个数，分下面几种情况：</p><ol><li>一个 sender，一个 receiver</li><li>一个 sender， M 个 receiver</li><li>N 个 sender，一个 reciver</li><li>N 个 sender， M 个 receiver</li></ol><p>对于 1，2，只有一个 sender 的情况就不用说了，直接从 sender 端关闭就好了，没有问题。重点关注第 3，4 种情况。</p><p>第 3 种情形下，优雅关闭 channel 的方法是：the only receiver says “please stop sending more” by closing an additional signal channel。</p><p>解决方案就是增加一个传递关闭信号的 channel，receiver 通过信号 channel 下达关闭数据 channel 指令。senders 监听到关闭信号后，停止发送数据。我把代码修改地更简洁了：</p><pre class=" language-golang"><code class="language-golang">func main() {    rand.Seed(time.Now().UnixNano())    const Max = 100000    const NumSenders = 1000    dataCh := make(chan int, 100)    stopCh := make(chan struct{})    // senders    for i := 0; i < NumSenders; i++ {        go func() {            for {                select {                case <- stopCh:                    return                case dataCh <- rand.Intn(Max):                }            }        }()    }    // the receiver    go func() {        for value := range dataCh {            if value == Max-1 {                fmt.Println("send stop signal to senders.")                close(stopCh)                return            }            fmt.Println(value)        }    }()    select {    case <- time.After(time.Hour):    }}</code></pre><p>这里的 stopCh 就是信号 channel，它本身只有一个 sender，因此可以直接关闭它。senders 收到了关闭信号后，select 分支 “case &lt;- stopCh” 被选中，退出函数，不再发送数据。</p><p>需要说明的是，上面的代码并没有明确关闭 dataCh。在 Go 语言中，对于一个 channel，如果最终没有任何 goroutine 引用它，不管 channel 有没有被关闭，最终都会被 gc 回收。所以，在这种情形下，所谓的优雅地关闭 channel 就是不关闭 channel，让 gc 代劳。</p><p>最后一种情况，优雅关闭 channel 的方法是：any one of them says “let’s end the game” by notifying a moderator to close an additional signal channel。</p><p>和第 3 种情况不同，这里有 M 个 receiver，如果直接还是采取第 3 种解决方案，由 receiver 直接关闭 stopCh 的话，就会重复关闭一个 channel，导致 panic。因此需要增加一个中间人，M 个 receiver 都向它发送关闭 dataCh 的“请求”，中间人收到第一个请求后，就会直接下达关闭 dataCh 的指令（通过关闭 stopCh，这时就不会发生重复关闭的情况，因为 stopCh 的发送方只有中间人一个）。另外，这里的 N 个 sender 也可以向中间人发送关闭 dataCh 的请求。</p><pre class=" language-golang"><code class="language-golang">func main() {    rand.Seed(time.Now().UnixNano())    const Max = 100000    const NumReceivers = 10    const NumSenders = 1000    dataCh := make(chan int, 100)    stopCh := make(chan struct{})    // It must be a buffered channel.    toStop := make(chan string, 1)    var stoppedBy string    // moderator    go func() {        stoppedBy = <-toStop        close(stopCh)    }()    // senders    for i := 0; i < NumSenders; i++ {        go func(id string) {            for {                value := rand.Intn(Max)                if value == 0 {                    select {                    case toStop <- "sender#" + id:                    default:                    }                    return                }                select {                case <- stopCh:                    return                case dataCh <- value:                }            }        }(strconv.Itoa(i))    }    // receivers    for i := 0; i < NumReceivers; i++ {        go func(id string) {            for {                select {                case <- stopCh:                    return                case value := <-dataCh:                    if value == Max-1 {                        select {                        case toStop <- "receiver#" + id:                        default:                        }                        return                    }                    fmt.Println(value)                }            }        }(strconv.Itoa(i))    }    select {    case <- time.After(time.Hour):    }}</code></pre><p>代码里 toStop 就是中间人的角色，使用它来接收 senders 和 receivers 发送过来的关闭 dataCh 请求。</p><p>这里将 toStop 声明成了一个 缓冲型的 channel。假设 toStop 声明的是一个非缓冲型的 channel，那么第一个发送的关闭 dataCh 请求可能会丢失。因为无论是 sender 还是 receiver 都是通过 select 语句来发送请求，如果中间人所在的 goroutine 没有准备好，那 select 语句就不会选中，直接走 default 选项，什么也不做。这样，第一个关闭 dataCh 的请求就会丢失。</p><p>如果，我们把 toStop 的容量声明成 Num(senders) + Num(receivers)，那发送 dataCh 请求的部分可以改成更简洁的形式：</p><pre class=" language-golang"><code class="language-golang">...toStop := make(chan string, NumReceivers + NumSenders)...            value := rand.Intn(Max)            if value == 0 {                toStop <- "sender#" + id                return            }...                if value == Max-1 {                    toStop <- "receiver#" + id                    return                }...</code></pre><p>直接向 toStop 发送请求，因为 toStop 容量足够大，所以不用担心阻塞，自然也就不用 select 语句再加一个 default case 来避免阻塞。</p><p>可以看到，这里同样没有真正关闭 dataCh，原样同第 3 种情况。</p><p>以上，就是最基本的一些情形，但已经能覆盖几乎所有的情况及其变种了。只要记住：</p><blockquote><p>don’t close a channel from the receiver side and don’t close a channel if the channel has multiple concurrent senders.</p></blockquote><p>以及更本质的原则：</p><blockquote><p>don’t close (or send values to) closed channels.</p></blockquote><h2 id="关闭的-channel-仍能读出数据"><a href="#关闭的-channel-仍能读出数据" class="headerlink" title="关闭的 channel 仍能读出数据"></a>关闭的 channel 仍能读出数据</h2><p>从一个有缓冲的 channel 里读数据，当 channel 被关闭，依然能读出有效值。只有当返回的 ok 为 false 时，读出的数据才是无效的。</p><pre class=" language-golang"><code class="language-golang">func main() {    ch := make(chan int, 5)    ch <- 18    close(ch)    x, ok := <-ch    if ok {        fmt.Println("received: ", x)    }    x, ok = <-ch    if !ok {        fmt.Println("channel closed, data invalid.")    }}</code></pre><p>运行结果：</p><pre class=" language-golang"><code class="language-golang">received:  18channel closed, data invalid.</code></pre><p>先创建了一个有缓冲的 channel，向其发送一个元素，然后关闭此 channel。之后两次尝试从 channel 中读取数据，第一次仍然能正常读出值。第二次返回的 ok 为 false，说明 channel 已关闭，且通道里没有数据。</p><h1 id="channel-应用"><a href="#channel-应用" class="headerlink" title="channel 应用"></a>channel 应用</h1><p>Channel 和 goroutine 的结合是 Go 并发编程的大杀器。而 Channel 的实际应用也经常让人眼前一亮，通过与 select，cancel，timer 等结合，它能实现各种各样的功能。接下来，我们就要梳理一下 channel 的应用。</p><h2 id="停止信号"><a href="#停止信号" class="headerlink" title="停止信号"></a>停止信号</h2><p>前面一节如何优雅关闭 channel 那一节已经讲得很多了，这块就略过了。</p><p>channel 用于停止信号的场景还是挺多的，经常是关闭某个 channel 或者向 channel 发送一个元素，使得接收 channel 的那一方获知道此信息，进而做一些其他的操作。</p><h2 id="任务定时"><a href="#任务定时" class="headerlink" title="任务定时"></a>任务定时</h2><p>与 timer 结合，一般有两种玩法：实现超时控制，实现定期执行某个任务。</p><p>有时候，需要执行某项操作，但又不想它耗费太长时间，上一个定时器就可以搞定：</p><pre class=" language-golang"><code class="language-golang">select {    case <-time.After(100 * time.Millisecond):    case <-s.stopc:        return false}</code></pre><p>等待 100 ms 后，如果 s.stopc 还没有读出数据或者被关闭，就直接结束。这是来自 etcd 源码里的一个例子，这样的写法随处可见。</p><p>定时执行某个任务，也比较简单：</p><pre class=" language-golang"><code class="language-golang">func worker() {    ticker := time.Tick(1 * time.Second)    for {        select {        case <- ticker:            // 执行定时任务            fmt.Println("执行 1s 定时任务")        }    }}</code></pre><p>每隔 1 秒种，执行一次定时任务。</p><h2 id="解耦生产方和消费方"><a href="#解耦生产方和消费方" class="headerlink" title="解耦生产方和消费方"></a>解耦生产方和消费方</h2><p>服务启动时，启动 n 个 worker，作为工作协程池，这些协程工作在一个 <code>for {}</code> 无限循环里，从某个 channel 消费工作任务并执行：</p><pre class=" language-golang"><code class="language-golang">func main() {    taskCh := make(chan int, 100)    go worker(taskCh)    // 塞任务    for i := 0; i < 10; i++ {        taskCh <- i    }    // 等待 1 小时     select {    case <-time.After(time.Hour):    }}func worker(taskCh <-chan int) {    const N = 5    // 启动 5 个工作协程    for i := 0; i < N; i++ {        go func(id int) {            for {                task := <- taskCh                fmt.Printf("finish task: %d by worker %d\n", task, id)                time.Sleep(time.Second)            }        }(i)    }}</code></pre><p>5 个工作协程在不断地从工作队列里取任务，生产方只管往 channel 发送任务即可，解耦生产方和消费方。</p><p>程序输出：</p><pre class=" language-shell"><code class="language-shell">finish task: 1 by worker 4finish task: 2 by worker 2finish task: 4 by worker 3finish task: 3 by worker 1finish task: 0 by worker 0finish task: 6 by worker 0finish task: 8 by worker 3finish task: 9 by worker 1finish task: 7 by worker 4finish task: 5 by worker 2</code></pre><h2 id="控制并发数"><a href="#控制并发数" class="headerlink" title="控制并发数"></a>控制并发数</h2><p>有时需要定时执行几百个任务，例如每天定时按城市来执行一些离线计算的任务。但是并发数又不能太高，因为任务执行过程依赖第三方的一些资源，对请求的速率有限制。这时就可以通过 channel 来控制并发数。</p><p>下面的例子来自《Go 语言高级编程》：</p><pre class=" language-golang"><code class="language-golang">var limit = make(chan int, 3)func main() {    // …………    for _, w := range work {        go func() {            limit <- 1            w()            <-limit        }()    }    // …………}</code></pre><p>构建一个缓冲型的 channel，容量为 3。接着遍历任务列表，每个任务启动一个 goroutine 去完成。真正执行任务，访问第三方的动作在 w() 中完成，在执行 w() 之前，先要从 limit 中拿“许可证”，拿到许可证之后，才能执行 w()，并且在执行完任务，要将“许可证”归还。这样就可以控制同时运行的 goroutine 数。</p><p>这里，<code>limit &lt;- 1</code> 放在 func 内部而不是外部，书籍作者柴大在读者群里的解释是：</p><blockquote><p>如果在外层，就是控制系统 goroutine 的数量，可能会阻塞 for 循环，影响业务逻辑。</p></blockquote><blockquote><p>limit 其实和逻辑无关，只是性能调优，放在内层和外层的语义不太一样。</p></blockquote><p>还有一点要注意的是，如果 w() 发生 panic，那“许可证”可能就还不回去了，因此需要使用 defer 来保证。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>终于写完了，你也终于看完了，恭喜！</p><p>回顾一下，这篇文章先从并发和并行讲起，又讲到了 CSP，Go 语言用 channel 实现 CSP。接着讲了什么是 channel，为什么需要 channel，然后详细分析了 channel 的实现原理，这也是全文最重要的部分。之后，又讲了几个进阶的例子，最后，列举了几个 channel 应用的场景。</p><p>希望大家能借助本文去读一下 Go 源码，这部分源码也不长，和 context 包一样，短小精悍，值得一读。</p><p>我在参考资料里列举了很多文章、书籍，很多都值得去细看，我在文中也有提及。</p><p>当你理解这 channel 的底层原理后，再去看这些英文文章，会觉得很有意思。以前对他有一种“畏难”心理，理解了之后再读，就会觉得很有意思，因为你确实都能看懂。</p><p>最后，阅读愉快！</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【Concurrency In Go】<a href="https://github.com/arpitjindal97/technology_books/blob/master/Golang/Concurrency-in-Go:Tools-and-Techniques-for-Developers.pdf">https://github.com/arpitjindal97/technology_books/blob/master/Golang/Concurrency-in-Go:Tools-and-Techniques-for-Developers.pdf</a></p><p>【Go 语言高级编程开源书】<a href="https://chai2010.cn/advanced-go-programming-book/ch1-basic/ch1-05-mem.html" target="_blank" rel="noopener">https://chai2010.cn/advanced-go-programming-book/ch1-basic/ch1-05-mem.html</a></p><p>【简洁清晰明了】<a href="http://litang.me/post/golang-channel/" target="_blank" rel="noopener">http://litang.me/post/golang-channel/</a></p><p>【柴大 &amp;&amp; 曹大 《Go语言高级编程》】<a href="https://chai2010.cn/advanced-go-programming-book/ch1-basic/ch1-05-mem.html" target="_blank" rel="noopener">https://chai2010.cn/advanced-go-programming-book/ch1-basic/ch1-05-mem.html</a></p><p>【Go 并发编程实战】<a href="https://book.douban.com/subject/26244729/" target="_blank" rel="noopener">https://book.douban.com/subject/26244729/</a></p><p>【曹大 golang notes】<a href="https://github.com/cch123/golang-notes/blob/master/channel.md">https://github.com/cch123/golang-notes/blob/master/channel.md</a></p><p>【互联网技术窝 图解 channel 实现 动画】<a href="https://mp.weixin.qq.com/s/40uxAPdubIk0lU321LmfRg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/40uxAPdubIk0lU321LmfRg</a></p><p>【一起学 Golang，推荐的资料非常有用】<a href="https://segmentfault.com/a/1190000018385779" target="_blank" rel="noopener">https://segmentfault.com/a/1190000018385779</a></p><p>【如何优雅地关闭 channel】<a href="https://go101.org/article/channel-closing.html" target="_blank" rel="noopener">https://go101.org/article/channel-closing.html</a></p><p>【深入 channel 底层】<a href="https://codeburst.io/diving-deep-into-the-golang-channels-549fd4ed21a8" target="_blank" rel="noopener">https://codeburst.io/diving-deep-into-the-golang-channels-549fd4ed21a8</a></p><p>【Kavya在Gopher Con 上关于 channel 的设计，非常好】<a href="https://speakerd.s3.amazonaws.com/presentations/10ac0b1d76a6463aa98ad6a9dec917a7/GopherCon_v10.0.pdf" target="_blank" rel="noopener">https://speakerd.s3.amazonaws.com/presentations/10ac0b1d76a6463aa98ad6a9dec917a7/GopherCon_v10.0.pdf</a></p><p>【channel 应用】<a href="https://www.s0nnet.com/archives/go-channels-practice" target="_blank" rel="noopener">https://www.s0nnet.com/archives/go-channels-practice</a></p><p>【应用举例】<a href="https://zhuyasen.com/post/go_queue.html" target="_blank" rel="noopener">https://zhuyasen.com/post/go_queue.html</a></p><p>【应用】<a href="https://tonybai.com/2014/09/29/a-channel-compendium-for-golang/" target="_blank" rel="noopener">https://tonybai.com/2014/09/29/a-channel-compendium-for-golang/</a></p><p>【鸟窝 并发编程分享】<a href="https://colobu.com/2019/04/28/gopher-2019-concurrent-in-action/" target="_blank" rel="noopener">https://colobu.com/2019/04/28/gopher-2019-concurrent-in-action/</a></p><p>【Go-Questions，码农桃花源项目】<a href="https://github.com/qcrao/Go-Questions">https://github.com/qcrao/Go-Questions</a></p><p>【GitBook 码农桃花源开源书】<a href="https://qcrao91.gitbook.io/go/" target="_blank" rel="noopener">https://qcrao91.gitbook.io/go/</a></p><p><img src="https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png" alt="QR"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大家好！“深度解密 Go 语言”系列好久未见，我们今天讲 channel，预祝阅读愉快！在开始正文之前，我们先说些题外话。&lt;/p&gt;
&lt;p&gt;上一篇关于 Go 语言的文章讲 Go 程序的整个编码、编译、运行、退出的全过程。文章发出后，反响强烈，在各大平台的阅读量都不错。例如博客
      
    
    </summary>
    
      <category term="编程语言" scheme="https://github.com/qcrao/qcrao.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Golang" scheme="https://github.com/qcrao/qcrao.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>如何打造一份优雅的简历</title>
    <link href="https://github.com/qcrao/qcrao.github.io/2019/07/08/how-to-write-resume-gracefully/"/>
    <id>https://github.com/qcrao/qcrao.github.io/2019/07/08/how-to-write-resume-gracefully/</id>
    <published>2019-07-08T01:00:00.000Z</published>
    <updated>2019-07-24T04:27:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近一些朋友找我内推，并且给我发了他们的简历。很多简历在我看来都不合格，不只是内容，还有格式，在我这都没过关。然后，我都会把我的简历模板贡献出来，收获了诸多好评。</p><p>为了让更多读者朋友拥有一份优雅得体的简历，我会倾其所能，把经验全部传授出来，希望你能有收获。</p><p>虽然现在不是求职的高峰期，但是社招、实习还是随时都可以进行的。我也不是一个追热点的人，只求对你有所帮助。另外，简历的制作其实并不是一蹴而就的事，当你知道了写简历的套路，平时就会有意识的积累素材，所以什么时候都可以学习如何打造一份优雅的简历。</p><p>简历是什么？在我看来，在面试之前，直接代表你这个人。虽然简历不会说话，但是简历的内容会让面试官直接在脑海里勾勒出你的形象。如果简历排版非常精致，你就会被塑造成一位细心、得体的形象；反之，如果简历里出现了错别字，那粗心这个标签就会打到你身上了。</p><p>所以，对待简历一定要重视！它是找工作过程中的第一道关卡，过了这一关，才有在面试中展示自我的机会。当然，平时的积累，个人的真实水平，临场发挥、人脉、运气也都很重要。这篇文章假设那些因素大家都一样，只比拼简历，就看谁简历写得好。</p><p>好的简历就是你的名片，不好的简历可能就是你的黑历史。接下来我们进入正题，说说简历该怎么写。</p><p>先贴一份完成了的简历。为了不暴露隐私，简历中的信息都是虚构的，但是写法都是按照模板来的，所以仍然不失一份精彩的样例，可以细看研究的。</p><p><img src="https://user-images.githubusercontent.com/7698088/60750234-2d1ae380-9fd8-11e9-8071-8aee3887d960.png" alt="整体"></p><p>顺便说一句，这张图片，可以自由传播。如果你仔细研究一下简历中的三个项目，你肯定会被我的才华折服的。</p><p>接下来就按简历模板里各个板块的顺序，详细解释每个部分该怎么写。</p><h1 id="抬头"><a href="#抬头" class="headerlink" title="抬头"></a>抬头</h1><p>直接写名字，电话号码，邮箱，其他信息不用填写。</p><p>我找工作那会，实验室的信号不是太好，所以在手机号码后面还留了个座机号码，防止联系不上，这是细节。</p><p>关于电子邮箱，校招的同学可以留学校的邮箱；对于社招，gmail.com，163.com，foxmail.com 都不错，qq.com 也是可以的，只是需要把邮箱前缀改成一些有意义的，例如姓名的缩写之类的，这在邮箱设置里直接设置就好了，一定不要出现一些“中二”的邮箱名，例如“今夜无眠”之类的绝对不要出现。</p><p>有些同学问，需不需要挂个相片上去？其实，在抬头右侧空白部分，是可以挂上的。但是，我建议男生一率不要挂照片（当然如果你有吴彦祖的风彩当我没说），女生可以适当挂上证件照，前提是颜值是你的一大优势。</p><p>当然，一些国企事业单位会强制要求你贴上照片，那就贴好了。但也不要随便找一个白拍照就放上去了，找一家正规的照相馆，化好妆，照片精修后的效果肯定可以提高你在面试官那里的第一印象，这是好的开始。</p><h1 id="教育背景"><a href="#教育背景" class="headerlink" title="教育背景"></a>教育背景</h1><p>这块直接从最高学历写起，写到本科即可。包括时间，学位，学校，专业，排名这些信息。有些可以体现你实力的东西是可以备注上的，例如优秀毕业生，免试推荐研究生，这些是可以在挂号里备注上的。</p><p>有些人说，这样是不是太高调了？借用 caoz 的一句话：你矜持，你活该。</p><p>最后，关于排名，如果你是专业第一名，就直接写上；否则，就计算一下你的排名大概占比百分之多少。如果班级排名高，就按班级的排名来，如果学校排名高，就写学校的排名。总之，按最高的来写。研究生一般没有排名这个说法，那你就估个数好了，填上 Top 5%，一般没有问题。</p><p>这里教大家一个小技巧，你看前面贴出来的简历是不是排列得很整齐？让你自己动手做，你不一定排得这么整齐。教你一招：</p><p><img src="https://user-images.githubusercontent.com/7698088/60749990-b6301b80-9fd4-11e9-9002-b0c09a0061b3.png" alt="表格"></p><p>通过表格，能自动地让文字对齐。写完之后，只需要将表格的边框设置为不可见就行了！深藏功与名！隐藏表格边框后的效果是这样的：</p><p><img src="https://user-images.githubusercontent.com/7698088/60750002-ea0b4100-9fd4-11e9-9eca-b286b61894fc.png" alt="表格去边框"></p><p>有没有被惊艳到？如果你早就知道了这个技巧，当我没说。</p><h1 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h1><p>如实写就好了，校招同学这一项可以写下实习经历，如果没有实习，这一项整体就不要了。社招同学不要在这上面弄虚作假，因为社招入职都会做尽调，被查出不诚信就尴尬了。</p><p>同样，可以用到上面提到的用表格排版的小技巧。</p><h1 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h1><p>找互联网工作的同学，一定刷过《剑指 offer》这本书，书里面的题在面试过程中出场率还是挺高的。但是，很多同学都只看了其中的题目部分，对于前两章可能就略读了，甚至直接跳过去了。其实，书的前两章是讲如何面试的，同样写得很精彩，值得细细研究。</p><p>咱们这篇文章不说面试，只说简历。但书里面有一个非常好的点 —— 描述项目的 STAR 模型：</p><p><img src="https://user-images.githubusercontent.com/7698088/60749073-7b73b680-9fc7-11e9-8cd2-4ca103a827b4.png" alt="STAR模型"></p><p>项目经历这一项按照这个模型来写就 OK 了。</p><p>先简述项目背景，为什么要做它，要简短、清晰，也就是 <code>Situation</code>；</p><p>再来说你负责哪一块，做了哪些有价值的工作，这一块要学会提炼，不能是简单的工作罗列，尽量让人觉得这是有技术含量的，包含 <code>Task &amp; Action</code>；</p><p>最后，就是这件事完成的效果如何，是性能提升了 100 倍还是从零到一完成了某个复杂的系统，关键在于你要用数字来表达。例如，我经过一系列的优化过程，使得系统响应时间缩短为原来的 50%，或者说响应时间提升 1 倍，平均响应时间达到 1 ms 等等。</p><p>举个例子来说：</p><p><img src="https://user-images.githubusercontent.com/7698088/60750894-59872d80-9fe1-11e9-9fe3-9c6b48aade9e.png" alt="project"></p><p>最开始一行，项目的简要信息。首先<code>项目的起止时间</code>，这个要斟酌一下，太长显得效率太低，太短可能又显得不深入。不是要教大家不诚信，这块适当“优化”下没太大问题；然后是<code>地点</code>，可以是学校，也可以是公司，照实写；接着是<code>项目名</code>，简短、清晰；最后是你的<code>角色</code>，一般可以写项目总负责人，核心参与者，项目主导者等等，不要太浮夸，也不要太低下。</p><p>接着，项目介绍。主要是讲清楚你做这个事的背景是什么。注意，不能说“这是实验室项目要求”或者“老师指定我做的”，要写这个项目的背景，业界是个什么进展，本项目它能解决什么问题，价值在哪，这是应该写的。有些项目确实垃圾，但编也得编一个高大上的介绍，毕竟它代表了你的水平不是嘛？</p><p>接着，个人职责。先是概要的一句话，例如负责系统的整体架构，打上一个句号，这是总起，后面用更细致的话来解释。例如，充分调研市面上的相关系统，反复设计修改，设计出一套高可用、高性能、可扩展的系统架构。一般要列三点，多了太长，少了显得工作量少。所以，要挑选最重要的点来说，例如，设计并实现了某个算法，性能是之前的多少倍。</p><p>最后，项目成果。这块一定要挑最亮点的来说，而且一定要能用数字量化。常见的就是性能提升了多少倍，支持了多少并发，支持了多少用户，不可用时长为 0，发表文章专利多少篇……</p><p>重要词语、数字用加粗来突出显示。这些加粗就是你最擅长的点，也是面试官可能会问你。所以你想让他问你什么，就加粗吧！</p><h1 id="个人技能"><a href="#个人技能" class="headerlink" title="个人技能"></a>个人技能</h1><p>这一项比较好搞定，把你的技能罗列出来，注意是和工作相关的。你找互联网的工作，写上一句“熟悉 office 的操作”就不太合适了吧。可以写：熟练掌握常见的数据结构和算法，熟悉 C/C++，熟悉 mysql/codis/etcd/zookper……</p><p>英语听说读写能力也可以写上，例如“能熟练进行英文的听说读写”。</p><p>唯一需要注意的是，不要也不能写“精通”。“精通”是一个非常强的词，很少人能做到。这里并不是谦虚的问题，还涉及到一个预期管理的问题，也就是面对“精通”和“熟悉”，面试官对你的期待是不一样的。</p><p>如果你写上“熟悉 Golang”，那么当面试官问你一个比较深入的问题时（例如 Golang 的 map 是怎么进行扩容的），你答上来了，他会觉得你水平比较高，而且还很谦虚。相反，你写的是“精通 Golang”，面试过程中，只要有一个问题没答上，那是不是一下子印象就下去了？</p><p>还写人写“精通 C/C++”，要知道，就是 C++ 的作者，他也不能完全掌握 C++ 的特性啊，即使 C++ 编译器，也不是所有的特性它都支持。换句话说，即使是编译器，也不能说它精通 C++。</p><h1 id="个人评价"><a href="#个人评价" class="headerlink" title="个人评价"></a>个人评价</h1><p>这一栏，可以展示你在工作技能之外的特性。例如，我看到有师兄这样写：</p><blockquote><p>高中班主任这样评价我：你是一个严于律己的人，一个精诚团结的人，一个志向远大的人。</p></blockquote><p>面试官可能会问：班主任为什么要这么评价？这时，他就掉入你提前挖好的“坑”，因为一个可以展示你优秀品质的故事正在等着他，这是你提前准备的已经演练了无数遍了。而且，面试进程也在你的掌握之中了。</p><p>注意，不要太多，也不要太浮夸，着重展示你是一个可以合作，善于沟通，工作积极的人。</p><h1 id="其他事项"><a href="#其他事项" class="headerlink" title="其他事项"></a>其他事项</h1><p>这块说一下其他未尽事项。</p><p>校招简历一般只要一页，就算你有再多内容要写，也只能压缩到一页，把那些最重要的，最能展示你能力的那部分内容保留下来，其他的干掉。</p><p>社招简历也不要超过两页，这样显得简练，展示的也都是高质量的项目，不能是简单的罗列，要总结升华。这样也可以打印到一页纸上，方便面试官，也就是方便你自己。</p><p>工作中，有一项非常重要的能力就是总结、提炼、升华。可能实验室的项目是一些企业的横向项目，就是 1+1=2 的事，非常简单，可能你觉得没啥可写的。这就是你发挥能力的时候了，从这些日常操作中，总结出一些高大上的东西来。如果不会，多参考一下优秀学长学姐的简历。</p><p>总之，你写到简历上的项目一定是经过总结升华的，这需要经过你无数次的修改。</p><p>还有一点要注意的是，发给别人的简历一定要是 pdf 格式，有些同学直接把 word 版 丟给别人，不同软件版本的电脑上可能会有兼容性问题啊，可能会有乱码，而且 word 版可能会被篡改。另外，打印简历的时候，也是要用 pdf 版本，不会出问题。</p><p>简历文件命名也是一个要注意的点。一般用 “码农桃花源-桃花源工作室-18888888888”，也就是“姓名-学校/公司-手机”这样的格式。这样，方便 HR 或者面试官联系你，因为只看文件名就能知道你的联系方式，和一些最重要的信息。再说一次，方便面试官就是方便你自己。</p><p>还有一个点，针对不同职位的简历应该是不一样的。这时，你可以把你的项目进行组合，不同职位的简历对应不同的项目组合，有的放矢。有些人会用 git 的不同分支维护不同的简历版本。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>简历是你的代表，无声代表你这个人；它也是一个面试索引，能引导面试官的提问。所以如果你特别擅长某个方面，一定要在简历上突出。这相当于给面试官“挖坑”，如果他进坑了，那问的问题一定要你早就烂熟于心的，因为那是你准备无数遍的精彩故事、优化案例。</p><p>这样，面试官整个过程都是受你的引导，在你的框框里，不知不觉，在你讲述你擅长内容的过程中，面试进程被你掌握了。面试官接下来的问题，也会是围绕你的回答、故事展开。</p><p>要知道，如果你让面试官自己想问题，那你多半是招架不住的，因为真正的高手可能不会看这篇文章，哈哈，开个玩笑。</p><p>这篇文章里的简历是用我真实的简历进行修改的，当然主要是修改的内容。而且，为了展示我的幽默，我还编了三个项目，非常精彩，值得一看。我也真的是够了，哈哈。</p><p>这份简历模板是我在学校的时候，从师兄师组那学习过来的，包括用表格排版的技巧。他们去的都是像微软、谷歌、FB、BAT 这些高大上的互联网公司。所以这绝对是一份久经考验的简历模板。而且，初看起来，似乎平淡无奇，但细细琢磨，真的是低调奢华有内涵，你值得拥有。</p><p>我把 word 版本放到网盘上了，公众号回复“简历模板”或者 “jlmb”，我会回复你下载地址。</p><p>仅仅是把你简历上的内容 copy 到这个模板上，你也会觉得“瞬间高大上起来了”。加油~~</p><p><img src="https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png" alt="QR"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近一些朋友找我内推，并且给我发了他们的简历。很多简历在我看来都不合格，不只是内容，还有格式，在我这都没过关。然后，我都会把我的简历模板贡献出来，收获了诸多好评。&lt;/p&gt;
&lt;p&gt;为了让更多读者朋友拥有一份优雅得体的简历，我会倾其所能，把经验全部传授出来，希望你能有收获。&lt;/
      
    
    </summary>
    
      <category term="求职" scheme="https://github.com/qcrao/qcrao.github.io/categories/%E6%B1%82%E8%81%8C/"/>
    
    
      <category term="简历" scheme="https://github.com/qcrao/qcrao.github.io/tags/%E7%AE%80%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>曹大谈内存重排</title>
    <link href="https://github.com/qcrao/qcrao.github.io/2019/06/17/cch-says-memory-reorder/"/>
    <id>https://github.com/qcrao/qcrao.github.io/2019/06/17/cch-says-memory-reorder/</id>
    <published>2019-06-17T01:00:00.000Z</published>
    <updated>2019-07-24T14:12:28.593Z</updated>
    
    <content type="html"><![CDATA[<p>写这篇文章的原因很简单，公司内部的 Golang 社区组织了第一期分享，主讲嘉宾就是我们敬爱的曹大。这个必定是要去听的，只是曹大的讲题非常硬核，所以提前找他要了参考资料，花了 1 个小时提前预习，才不至于在正式分享的时候什么也不懂。当然了，这也是对自己和主讲者的尊重。所有的参考资料都在文章最后一部分，欢迎自行探索。</p><p>在我读曹大给我的中英文参考资料时，我发现英文的我能读懂，读中文却很费劲。经过对比，我发现，英文文章是由一个例子引入，循序渐进，逐步深入。跟着作者的脚步探索，非常有意思。而中文的博客上来就直奔主题，对于第一次接触的人非常不友好。</p><p>两者就像演绎法和归纳法区别。国内的教材通常是演绎法，也就是上来先讲各种概念、原理，再推出另一些定理，比较枯燥；国外的教材更喜欢由例子引入，步步深入，引人入胜。这里，不去评判孰孰劣。多看看一些英文原版材料，总是有益的。据我所知，曹大经常从亚马逊上购买英文书籍，这个侧面也可以反映曹大的水平高啊。据说英文书一般都很贵，可见曹大也是很有钱的。</p><p>所以啊，技术文章写好不容易，我也自省一下。</p><h1 id="什么是内存重排"><a href="#什么是内存重排" class="headerlink" title="什么是内存重排"></a>什么是内存重排</h1><p>分两种，硬件和软件层面的，包括 CPU 重排、编译器重排。</p><h2 id="CPU-重排"><a href="#CPU-重排" class="headerlink" title="CPU 重排"></a>CPU 重排</h2><p>引用参考资料 <code>【内存一致模型】</code> 里的例子：</p><p><img src="https://user-images.githubusercontent.com/7698088/59549609-c2efbf80-8f92-11e9-86c2-1e3cd8305db1.png" alt="2 thread"></p><p>在两个线程里同时执行上面的代码，A 和 B 初始化值都是 0，那最终的输出是什么？</p><p>先说几种显而易见的结果：</p><table><thead><tr><th>执行顺序</th><th>输出结果</th></tr></thead><tbody><tr><td>1-2-3-4</td><td>01</td></tr><tr><td>3-4-1-2</td><td>01</td></tr><tr><td>1-3-2-4</td><td>11</td></tr><tr><td>1-3-4-2</td><td>11</td></tr></tbody></table><p>当然，还有一些对称的情形，和上面表格中列出的输出是一样的。例如，执行为顺序为 3-1-4-2 的输出为 11。</p><p>从 01 的排列组合来看，总共有4种：00、01、10、11。表格中还差两种：10、00。我们来重点分析下这两种结果究竟会不会出现。</p><p>首先是 <code>10</code>，假设 (2) 输出 1，(4) 输出 0。那么首先给 2，3 排个序：(3) -&gt; (2)，因为先要将 B 赋值为 1，(2) 才能打印出 1；同理，(4) -&gt; (1)。另外，因为先打印 1，所以 (2) 要在 (4) 前面，合起来：(3) -&gt; (2) -&gt; (4) -&gt; (1)。(2) 竟然在 (1) 前面执行了，不可能的！</p><p>那我们再分析下 <code>00</code>，要想打印 00，打印语句必须在相应变量赋值前执行：</p><p><img src="https://user-images.githubusercontent.com/7698088/59549674-b455d800-8f93-11e9-83bb-074f2ab4c490.png" alt="00"></p><p>图中箭头表示先后顺序。这就尴尬了，形成了一个环。如果先从 (1) 开始，那顺序就是 (1) -&gt; (2) -&gt; (3) -&gt; (4) -&gt; (1)。(1) 要被执行了 2 次，怎么可能？所以 <code>00</code> 这种情形也是不可能出现的。</p><p>但是，上面说的两种情况在真实世界是有可能发生的。曹大的讲义里有验证的方法，感兴起的同学自己去尝试。总共测试了 100 百万次，测试结果如下：</p><p><img src="https://user-images.githubusercontent.com/7698088/59570902-5d561d00-90d1-11e9-842d-cf30babbc0a4.png" alt="test result"></p><p>非常反直觉，但是在多线程的世界，各种诡异的问题，只有你想不到，没有计算机做不到的。</p><p>我们知道，用户写下的代码，先要编译成汇编代码，也就是各种指令，包括读写内存的指令。CPU 的设计者们，为了榨干 CPU 的性能，无所不用其极，各种手段都用上了，你可能听过不少，像流水线、分支预测等等。</p><p>其中，为了提高读写内存的效率，会对读写指令进行重新排列，这就是所谓的 <code>内存重排</code>，英文为 <code>Memory Reordering</code>。</p><p>这一部分说的是 CPU 重排，其实还有编译器重排。</p><h2 id="编译器重排"><a href="#编译器重排" class="headerlink" title="编译器重排"></a>编译器重排</h2><p>来看一个代码片段：</p><pre class=" language-python"><code class="language-python">X <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    X <span class="token operator">=</span> <span class="token number">1</span>    <span class="token keyword">print</span> X</code></pre><p>这段代码执行的结果是打印 100 个 1。一个聪明的编译器会分析到循环里对 X 的赋值 <code>X = 1</code> 是多余的，每次都要给它赋上 1，完全没必要。因此会把代码优化一下：</p><pre class=" language-python"><code class="language-python">X <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span> X</code></pre><p>优化后的运行结果完全和之前的一样，完美！</p><p>但是，如果这时有另外一个线程同时干了这么一件事：</p><pre class=" language-python"><code class="language-python">X <span class="token operator">=</span> <span class="token number">0</span></code></pre><p>由于这两个线程并行执行，优化前的代码运行的结果可能是这样的：<code>11101111...</code>。出现了 1 个 0，但在下次循环中，又会被重新赋值为 1，而且之后一直都是 1。</p><p>但是优化后的代码呢：<code>11100000...</code>。由于把 <code>X = 1</code> 这一条赋值语句给优化掉了，某个时刻 X 变成 <code>0</code> 之后，再也没机会变回原来的 <code>1</code> 了。</p><blockquote><p>在多核心场景下,没有办法轻易地判断两段程序是“等价”的。</p></blockquote><p>可见编译器的重排也是基于运行效率考虑的，但以多线程运行时，就会出各种问题。</p><h1 id="为什么要内存重排"><a href="#为什么要内存重排" class="headerlink" title="为什么要内存重排"></a>为什么要内存重排</h1><p>引用曹大的一句话：</p><blockquote><p>软件或硬件系统可以根据其对代码的分析结果，一定程度上打乱代码的执行顺序，以达到其不可告人的目的。</p></blockquote><p>软件指的是编译器，硬件是 CPU。不可告人的目的就是：</p><blockquote><p>减少程序指令数<br>最大化提高 CPU 利用率</p></blockquote><p>曹大又皮了！</p><h1 id="内存重排的底层原理"><a href="#内存重排的底层原理" class="headerlink" title="内存重排的底层原理"></a>内存重排的底层原理</h1><p>CPU 重排的例子里提到的两种不可能出现的情况，并不是那么显而易见，甚至是难以理解。原因何在？</p><p>因为我们相信在多线程的程序里，虽然是并行执行，但是访问的是同一块内存，所以没有语句，准确说是指令，能“真正”同时执行的。对同一个内存地址的写，一定是有先有后，先写的结果一定会被后来的操作看到。</p><p>当我们写的代码以单线程运行的时候，语句会按我们的本来意图 <code>顺序</code> 地去执行。一旦单线程变成多线程，情况就变了。</p><p>想像一个场景，有两个线程在运行，操作系统会在它们之间进行调度。每个线程在运行的时候，都会顺序地执行它的代码。由于对同一个变量的读写，会访问内存的同一地址，所以同一时刻只能有一个线程在运行，即使 CPU 有多个核心：前一个指令操作的结果要让后一个指令看到。</p><p>这样带来的后果就是效率低下。两个线程没法做到并行，因为一个线程所做的修改会影响到另一个线程，那后者只能在前者的修改所造成的影响“可见”了之后，才能运行，变成了串行。</p><p>重新来思考前面的例子：</p><p><img src="https://user-images.githubusercontent.com/7698088/59549609-c2efbf80-8f92-11e9-86c2-1e3cd8305db1.png" alt="2 thread"></p><p>考虑一个问题，为什么 (2) 要等待 (1) 执行完之后才能执行呢？它们之间又没有什么联系，影响不到彼此，完全可以并行去做啊！</p><p>由于 (1) 是写语句，所以比 (2) 更耗时，从 <code>a single view of memory</code> 这个视角来看，(2) 应该等 (1) 的“效果”对其他所有线程可见了之后才可以执行。但是，在一个现代 CPU 里，这需要花费上百个 CPU 周期。</p><p>现代 CPU 为了“抚平” 内核、内存、硬盘之间的速度差异，搞出了各种策略，例如三级缓存等。</p><p><img src="https://user-images.githubusercontent.com/7698088/59557419-223de600-900c-11e9-8c08-a1ba4b0bbbff.png" alt="cpu cache"></p><p>为了让 (2) 不必等待 (1) 的执行“效果”可见之后才能执行，我们可以把 (1) 的效果保存到 <code>store buffer</code>：</p><p><img src="https://user-images.githubusercontent.com/7698088/59557443-e3f4f680-900c-11e9-975e-82d9b7da74c7.png" alt="store buffer"></p><p>当 (1) 的“效果”写到了 <code>store buffer</code> 后，(2) 就可以开始执行了，不必等到 <code>A = 1</code> 到达 L3 cache。因为 <code>store buffer</code> 是在内核里完成的，所以速度非常快。在这之后的某个时刻，<code>A = 1</code> 会被逐级写到 L3 cache，从而被其他所有线程看到。<code>store buffer</code> 相当于把写的耗时隐藏了起来。</p><p><code>store buffer</code> 对单线程是完美的，例如：</p><p><img src="https://user-images.githubusercontent.com/7698088/59557508-e99f0c00-900d-11e9-81d5-5c7a22faecfc.png" alt="store buffer 1 thread"></p><p>将 (1) 存入 <code>store buffer</code> 后，(2) 开始执行。注意，由于是同一个线程，所以语句的执行顺序还是要保持的。</p><p>(2) 直接从 <code>store buffer</code> 里读出了 <code>A = 1</code>，不必从 L3 Cache 或者内存读取，简直完美！</p><p>有了 <code>store buffer</code> 的概念，我们再来研究前面的那个例子：</p><p><img src="https://user-images.githubusercontent.com/7698088/59557535-bf9a1980-900e-11e9-9d19-f84a0f3196db.png" alt="store buffer 2 threads"></p><p>先执行 (1) 和 (3)，将他们直接写入 <code>store buffer</code>，接着执行 (2) 和 (4)。“奇迹”要发生了：(2) 看了下  <code>store buffer</code>，并没有发现有 B 的值，于是从 Memory 读出了 0，(4) 同样从 Memory 读出了 0。最后，打印出了 <code>00</code>。</p><p>所有的现代 CPU 都支持 <code>store buffer</code>，这导致了很多对程序员来说是难以理解的现象。从某种角度来说，不等 <code>A = 1</code> 扩散到 Memory，就去执行 <code>print(B)</code> 语句，可以看成<code>读写指令重排</code>。有些 CPU 甚至优化得更多，几乎所有的操作都可以重排，简直是噩梦。</p><p>因此，对于多线程的程序，所有的 CPU 都会提供“锁”支持，称之为 <code>barrier</code>，或者 <code>fence</code>。它要求：</p><pre class=" language-shell"><code class="language-shell">A barrier instruction forces all memory operations before it to complete before any memory operation after it can begin.</code></pre><p>barrier 指令要求所有对内存的操作都必须要“扩散”到 memory 之后才能继续执行其他对 memory 的操作。</p><p>barrier 指令要耗费几百个 CPU 周期，而且容易出错。因此，我们可以用高级点的 <code>atomic compare-and-swap</code>，或者直接用更高级的锁，通常是标准库提供。</p><blockquote><p>正是 CPU 提供的 barrier 指令，我们才能实现应用层的各种同步原语，如 atomic，而 atomic 又是各种更上层的 lock 的基础。</p></blockquote><p>以上说的是 CPU 重排的原理。编译器重排主要是依据语言自己的“内存模型”，不深入了。</p><p>出现前面描述的诡异现象的根源在于程序存在 <code>data race</code>，也就是说多个线程会同时访问内存的同一个地方，并且至少有一个是写，而且导致了内存重排。所以，最重要的是当我们在写并发程序的时候，要使用一些“同步”的标准库，简单理解就是各种锁，来避免由于内存重排而带来的一些不可预知的结果。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>内存重排是指程序在实际运行时对内存的访问顺序和代码编写时的顺序不一致，主要是为了提高运行效率。分别是硬件层面的 <code>CPU 重排</code> 和软件层面的 <code>编译器重排</code>。</p><p>单线程的程序一般不会有太大问题；多线程情况下，有时会出现诡异的现象，解决办法就是使用标准库里的锁。锁会带来性能问题，为了降低影响，锁应该尽量减小粒度，并且不要在互斥区（锁住的代码）放入耗时长的操作。</p><blockquote><p>lock contention 的本质问题是需要进入互斥区的 goroutine 需要等待独占 goroutine 退出后才能进入互斥区，并行 → 串行。</p></blockquote><p>本文讲的是曹大讲座的一部分，我没有深入研究其他内容，例如 MESI协议、cache contention 等，讲清这些又要牵扯到很多，我还是聚集到深度解密 Go 语言系列吧。有兴趣的话，去曹大博客，给我们提供了很多参考链接，可以自行探索。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【曹大 github】<a href="https://github.com/cch123/golang-notes/blob/master/memory_barrier.md">https://github.com/cch123/golang-notes/blob/master/memory_barrier.md</a></p><p>【曹大讲义】<a href="https://cch123.github.io/ooo/" target="_blank" rel="noopener">https://cch123.github.io/ooo/</a></p><p>【内存一致模型】<a href="https://homes.cs.washington.edu/~bornholt/post/memory-models.html" target="_blank" rel="noopener">https://homes.cs.washington.edu/~bornholt/post/memory-models.html</a></p><p>【掘金咔叽咔叽，译】<a href="https://juejin.im/post/5d0519e05188257a78764d5d#comment" target="_blank" rel="noopener">https://juejin.im/post/5d0519e05188257a78764d5d#comment</a></p><p><img src="https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png" alt="QR"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写这篇文章的原因很简单，公司内部的 Golang 社区组织了第一期分享，主讲嘉宾就是我们敬爱的曹大。这个必定是要去听的，只是曹大的讲题非常硬核，所以提前找他要了参考资料，花了 1 个小时提前预习，才不至于在正式分享的时候什么也不懂。当然了，这也是对自己和主讲者的尊重。所有的
      
    
    </summary>
    
      <category term="操作系统" scheme="https://github.com/qcrao/qcrao.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="内存重排" scheme="https://github.com/qcrao/qcrao.github.io/tags/%E5%86%85%E5%AD%98%E9%87%8D%E6%8E%92/"/>
    
  </entry>
  
  <entry>
    <title>深度解密Go语言之context</title>
    <link href="https://github.com/qcrao/qcrao.github.io/2019/06/12/dive-into-go-context/"/>
    <id>https://github.com/qcrao/qcrao.github.io/2019/06/12/dive-into-go-context/</id>
    <published>2019-06-12T01:26:00.000Z</published>
    <updated>2019-07-24T14:07:22.993Z</updated>
    
    <content type="html"><![CDATA[<p>Go 语言的 context 包短小精悍，非常适合新手学习。不论是它的源码还是实际使用，都值得投入时间去学习。</p><p>这篇文章依然想尝试全面、深入地去研究。文章相比往期而言，整体不长，希望你看完可以有所收获！</p><h1 id="什么是-context"><a href="#什么是-context" class="headerlink" title="什么是 context"></a>什么是 context</h1><p>Go 1.7 标准库引入 context，中文译作“上下文”，准确说它是 goroutine 的上下文，包含 goroutine 的运行状态、环境、现场等信息。</p><p>context 主要用来在 goroutine 之间传递上下文信息，包括：取消信号、超时时间、截止时间、k-v 等。</p><p>随着 context 包的引入，标准库中很多接口因此加上了 context 参数，例如 database/sql 包。context 几乎成为了并发控制和超时控制的标准做法。</p><blockquote><p>context.Context 类型的值可以协调多个 groutine 中的代码执行“取消”操作，并且可以存储键值对。最重要的是它是并发安全的。</p></blockquote><blockquote><p>与它协作的 API 都可以由外部控制执行“取消”操作，例如：取消一个 HTTP 请求的执行。</p></blockquote><p>没看懂？没关系，先往后看。</p><h1 id="为什么有-context"><a href="#为什么有-context" class="headerlink" title="为什么有 context"></a>为什么有 context</h1><p>Go 常用来写后台服务，通常只需要几行代码，就可以搭建一个 http server。</p><p>在 Go 的 server 里，通常每来一个请求都会启动若干个 goroutine 同时工作：有些去数据库拿数据，有些调用下游接口获取相关数据……</p><p><img src="https://user-images.githubusercontent.com/7698088/59235934-643ee480-8c26-11e9-8931-456333900657.png" alt="request"></p><p>这些 goroutine 需要共享这个请求的基本数据，例如登陆的 token，处理请求的最大超时时间（如果超过此值再返回数据，请求方因为超时接收不到）等等。当请求被取消或是处理时间太长，这有可能是使用者关闭了浏览器或是已经超过了请求方规定的超时时间，请求方直接放弃了这次请求结果。这时，所有正在为这个请求工作的 goroutine 需要快速退出，因为它们的“工作成果”不再被需要了。在相关联的 goroutine 都退出后，系统就可以回收相关的资源。</p><p>再多说一点，Go 语言中的 server 实际上是一个“协程模型”，也就是说一个协程处理一个请求。例如在业务的高峰期，某个下游服务的响应变慢，而当前系统的请求又没有超时控制，或者超时时间设置地过大，那么等待下游服务返回数据的协程就会越来越多。而我们知道，协程是要消耗系统资源的，后果就是协程数激增，内存占用飙涨，甚至导致服务不可用。更严重的会导致雪崩效应，整个服务对外表现为不可用，这肯定是 P0 级别的事故。这时，肯定有人要背锅了。</p><p>其实前面描述的 P0 级别事故，通过设置“允许下游最长处理时间”就可以避免。例如，给下游设置的 timeout 是 50 ms，如果超过这个值还没有接收到返回数据，就直接向客户端返回一个默认值或者错误。例如，返回商品的一个默认库存数量。注意，这里设置的超时时间和创建一个 http client 设置的读写超时时间不一样，这里不详细展开。可以去看看参考资料<code>【Go 在今日头条的实践】</code>一文，有很精彩的论述。</p><p>context 包就是为了解决上面所说的这些问题而开发的：在 一组 goroutine 之间传递共享的值、取消信号、deadline……</p><p><img src="https://user-images.githubusercontent.com/7698088/59235969-a405cc00-8c26-11e9-9448-2c6c86e8263b.png" alt="request with context"></p><p>用简练一些的话来说，在Go 里，我们不能直接杀死协程，协程的关闭一般会用 <code>channel+select</code> 方式来控制。但是在某些场景下，例如处理一个请求衍生了很多协程，这些协程之间是相互关联的：需要共享一些全局变量、有共同的 deadline 等，而且可以同时被关闭。再用 <code>channel+select</code> 就会比较麻烦，这时就可以通过 context 来实现。</p><p>一句话：context 用来解决 goroutine 之间<code>退出通知</code>、<code>元数据传递</code>的功能。</p><h1 id="context-底层实现原理"><a href="#context-底层实现原理" class="headerlink" title="context 底层实现原理"></a>context 底层实现原理</h1><p>我们分析的 Go 版本依然是 <code>1.9.2</code>。</p><h2 id="整体概览"><a href="#整体概览" class="headerlink" title="整体概览"></a>整体概览</h2><p>context 包的代码并不长，<code>context.go</code> 文件总共不到 500 行，其中还有很多大段的注释，代码可能也就 200 行左右的样子，是一个非常值得研究的代码库。</p><p>先给大家看一张整体的图：</p><p><img src="https://user-images.githubusercontent.com/7698088/59145775-173af280-8a1b-11e9-8867-c99ce02edb09.png" alt="structure"></p><table><thead><tr><th>类型</th><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>Context</td><td>接口</td><td>定义了 Context 接口的四个方法</td></tr><tr><td>emptyCtx</td><td>结构体</td><td>实现了 Context 接口，它其实是个空的 context</td></tr><tr><td>CancelFunc</td><td>函数</td><td>取消函数</td></tr><tr><td>canceler</td><td>接口</td><td>context 取消接口，定义了两个方法</td></tr><tr><td>cancelCtx</td><td>结构体</td><td>可以被取消</td></tr><tr><td>timerCtx</td><td>结构体</td><td>超时会被取消</td></tr><tr><td>valueCtx</td><td>结构体</td><td>可以存储 k-v 对</td></tr><tr><td>Background</td><td>函数</td><td>返回一个空的 context，常作为根 context</td></tr><tr><td>TODO</td><td>函数</td><td>返回一个空的 context，常用于重构时期，没有合适的 context 可用</td></tr><tr><td>WithCancel</td><td>函数</td><td>基于父 context，生成一个可以取消的 context</td></tr><tr><td>newCancelCtx</td><td>函数</td><td>创建一个可取消的 context</td></tr><tr><td>propagateCancel</td><td>函数</td><td>向下传递 context 节点间的取消关系</td></tr><tr><td>parentCancelCtx</td><td>函数</td><td>找到第一个可取消的父节点</td></tr><tr><td>removeChild</td><td>函数</td><td>去掉父节点的孩子节点</td></tr><tr><td>init</td><td>函数</td><td>包初始化</td></tr><tr><td>WithDeadline</td><td>函数</td><td>创建一个有 deadline 的 context</td></tr><tr><td>WithTimeout</td><td>函数</td><td>创建一个有 timeout 的 context</td></tr><tr><td>WithValue</td><td>函数</td><td>创建一个存储 k-v 对的 context</td></tr></tbody></table><p>上面这张表展示了 context 的所有函数、接口、结构体，可以纵览全局，可以在读完文章后，再回头细看。</p><p>整体类图如下：</p><p><img src="https://user-images.githubusercontent.com/7698088/59153629-c1a12d00-8a90-11e9-89a4-eaf3e34f190e.png" alt="classes"></p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>现在可以直接看源码：</p><pre class=" language-golang"><code class="language-golang">type Context interface {    // 当 context 被取消或者到了 deadline，返回一个被关闭的 channel    Done() <-chan struct{}    // 在 channel Done 关闭后，返回 context 取消原因    Err() error    // 返回 context 是否会被取消以及自动取消时间（即 deadline）    Deadline() (deadline time.Time, ok bool)    // 获取 key 对应的 value    Value(key interface{}) interface{}}</code></pre><p><code>Context</code> 是一个接口，定义了 4 个方法，它们都是<code>幂等</code>的。也就是说连续多次调用同一个方法，得到的结果都是相同的。</p><p><code>Done()</code> 返回一个 channel，可以表示 context 被取消的信号：当这个 channel 被关闭时，说明 context 被取消了。注意，这是一个只读的channel。 我们又知道，读一个关闭的 channel 会读出相应类型的零值。并且源码里没有地方会向这个 channel 里面塞入值。换句话说，这是一个 <code>receive-only</code> 的 channel。因此在子协程里读这个 channel，除非被关闭，否则读不出来任何东西。也正是利用了这一点，子协程从 channel 里读出了值（零值）后，就可以做一些收尾工作，尽快退出。</p><p><code>Err()</code> 返回一个错误，表示 channel 被关闭的原因。例如是被取消，还是超时。</p><p><code>Deadline()</code> 返回 context 的截止时间，通过此时间，函数就可以决定是否进行接下来的操作，如果时间太短，就可以不往下做了，否则浪费系统资源。当然，也可以用这个 deadline 来设置一个 I/O 操作的超时时间。</p><p><code>Value()</code> 获取之前设置的 key 对应的 value。</p><h3 id="canceler"><a href="#canceler" class="headerlink" title="canceler"></a>canceler</h3><p>再来看另外一个接口：</p><pre class=" language-golang"><code class="language-golang">type canceler interface {    cancel(removeFromParent bool, err error)    Done() <-chan struct{}}</code></pre><p>实现了上面定义的两个方法的 Context，就表明该 Context 是可取消的。源码中有两个类型实现了 canceler 接口：<code>*cancelCtx</code> 和 <code>*timerCtx</code>。注意是加了 <code>*</code> 号的，是这两个结构体的指针实现了 canceler 接口。</p><p>Context 接口设计成这个样子的原因：</p><ul><li>“取消”操作应该是建议性，而非强制性</li></ul><p>caller 不应该去关心、干涉 callee 的情况，决定如何以及何时 return 是 callee 的责任。caller 只需发送“取消”信息，callee 根据收到的信息来做进一步的决策，因此接口并没有定义 cancel 方法。</p><ul><li>“取消”操作应该可传递</li></ul><p>“取消”某个函数时，和它相关联的其他函数也应该“取消”。因此，<code>Done()</code> 方法返回一个只读的 channel，所有相关函数监听此 channel。一旦 channel 关闭，通过 channel 的“广播机制”，所有监听者都能收到。</p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="emptyCtx"><a href="#emptyCtx" class="headerlink" title="emptyCtx"></a>emptyCtx</h3><p>源码中定义了 <code>Context</code> 接口后，并且给出了一个实现：</p><pre class=" language-golang"><code class="language-golang">type emptyCtx intfunc (*emptyCtx) Deadline() (deadline time.Time, ok bool) {    return}func (*emptyCtx) Done() <-chan struct{} {    return nil}func (*emptyCtx) Err() error {    return nil}func (*emptyCtx) Value(key interface{}) interface{} {    return nil}</code></pre><p>看这段源码，非常 happy。因为每个函数都实现的异常简单，要么是直接返回，要么是返回 nil。</p><p>所以，这实际上是一个空的 context，永远不会被 cancel，没有存储值，也没有 deadline。</p><p>它被包装成：</p><pre class=" language-golang"><code class="language-golang">var (    background = new(emptyCtx)    todo       = new(emptyCtx))</code></pre><p>通过下面两个导出的函数（首字母大写）对外公开：</p><pre class=" language-golang"><code class="language-golang">func Background() Context {    return background}func TODO() Context {    return todo}</code></pre><p>background 通常用在 main 函数中，作为所有 context 的根节点。</p><p>todo 通常用在并不知道传递什么 context的情形。例如，调用一个需要传递 context 参数的函数，你手头并没有其他 context 可以传递，这时就可以传递 todo。这常常发生在重构进行中，给一些函数添加了一个 Context 参数，但不知道要传什么，就用 todo “占个位子”，最终要换成其他 context。</p><h3 id="cancelCtx"><a href="#cancelCtx" class="headerlink" title="cancelCtx"></a>cancelCtx</h3><p>再来看一个重要的 context：</p><pre class=" language-golang"><code class="language-golang">type cancelCtx struct {    Context    // 保护之后的字段    mu       sync.Mutex    done     chan struct{}    children map[canceler]struct{}    err      error}</code></pre><p>这是一个可以取消的 Context，实现了 canceler 接口。它直接将接口 Context 作为它的一个匿名字段，这样，它就可以被看成一个 Context。</p><p>先来看 <code>Done()</code> 方法的实现：</p><pre class=" language-golang"><code class="language-golang">func (c *cancelCtx) Done() <-chan struct{} {    c.mu.Lock()    if c.done == nil {        c.done = make(chan struct{})    }    d := c.done    c.mu.Unlock()    return d}</code></pre><p>c.done 是“懒汉式”创建，只有调用了 Done() 方法的时候才会被创建。再次说明，函数返回的是一个只读的 channel，而且没有地方向这个 channel 里面写数据。所以，直接调用读这个 channel，协程会被 block 住。一般通过搭配 select 来使用。一旦关闭，就会立即读出零值。</p><p><code>Err()</code> 和 <code>String()</code> 方法比较简单，不多说。推荐看源码，非常简单。</p><p>接下来，我们重点关注 <code>cancel()</code> 方法的实现：</p><pre class=" language-golang"><code class="language-golang">func (c *cancelCtx) cancel(removeFromParent bool, err error) {    // 必须要传 err    if err == nil {        panic("context: internal error: missing cancel error")    }    c.mu.Lock()    if c.err != nil {        c.mu.Unlock()        return // 已经被其他协程取消    }    // 给 err 字段赋值    c.err = err    // 关闭 channel，通知其他协程    if c.done == nil {        c.done = closedchan    } else {        close(c.done)    }    // 遍历它的所有子节点    for child := range c.children {        // 递归地取消所有子节点        child.cancel(false, err)    }    // 将子节点置空    c.children = nil    c.mu.Unlock()    if removeFromParent {        // 从父节点中移除自己         removeChild(c.Context, c)    }}</code></pre><p>总体来看，<code>cancel()</code> 方法的功能就是关闭 channel：c.done；递归地取消它的所有子节点；从父节点从删除自己。达到的效果是通过关闭 channel，将取消信号传递给了它的所有子节点。goroutine 接收到取消信号的方式就是 select 语句中的<code>读 c.done</code> 被选中。</p><p>我们再来看创建一个可取消的 Context 的方法：</p><pre class=" language-golang"><code class="language-golang">func WithCancel(parent Context) (ctx Context, cancel CancelFunc) {    c := newCancelCtx(parent)    propagateCancel(parent, &c)    return &c, func() { c.cancel(true, Canceled) }}func newCancelCtx(parent Context) cancelCtx {    return cancelCtx{Context: parent}}</code></pre><p>这是一个暴露给用户的方法，传入一个父 Context（这通常是一个 <code>background</code>，作为根节点），返回新建的 context，新 context 的 done channel 是新建的（前文讲过）。</p><p>当 WithCancel 函数返回的 CancelFunc 被调用或者是父节点的 done channel 被关闭（父节点的 CancelFunc 被调用），此 context（子节点） 的 done channel 也会被关闭。</p><p>注意传给 WithCancel 方法的参数，前者是 true，也就是说取消的时候，需要将自己从父节点里删除。第二个参数则是一个固定的取消错误类型：</p><pre class=" language-golang"><code class="language-golang">var Canceled = errors.New("context canceled")</code></pre><p>还注意到一点，调用子节点 cancel 方法的时候，传入的第一个参数 <code>removeFromParent</code> 是 false。</p><p>两个问题需要回答：1. 什么时候会传 true？2. 为什么有时传 true，有时传 false？</p><p>当 <code>removeFromParent</code> 为 true 时，会将当前节点的 context 从父节点 context 中删除：</p><pre class=" language-golang"><code class="language-golang">func removeChild(parent Context, child canceler) {    p, ok := parentCancelCtx(parent)    if !ok {        return    }    p.mu.Lock()    if p.children != nil {        delete(p.children, child)    }    p.mu.Unlock()}</code></pre><p>最关键的一行：</p><pre class=" language-golang"><code class="language-golang">delete(p.children, child)</code></pre><p>什么时候会传 true 呢？答案是调用 <code>WithCancel()</code> 方法的时候，也就是新创建一个可取消的 context 节点时，返回的 cancelFunc 函数会传入 true。这样做的结果是：当调用返回的 cancelFunc 时，会将这个 context 从它的父节点里“除名”，因为父节点可能有很多子节点，你自己取消了，所以我要和你断绝关系，对其他人没影响。</p><p>在取消函数内部，我知道，我所有的子节点都会因为我的一：<code>c.children = nil</code> 而化为灰烬。我自然就没有必要再多做这一步，最后我所有的子节点都会和我断绝关系，没必要一个个做。另外，如果遍历子节点的时候，调用 child.cancel 函数传了 true，还会造成同时遍历和删除一个 map 的境地，会有问题的。</p><p><img src="https://user-images.githubusercontent.com/7698088/59315867-37ee9b00-8cee-11e9-8c19-9a4cf7606d14.png" alt="context cancel"></p><p>如上左图，代表一棵 context 树。当调用左图中标红 context 的 cancel 方法后，该 context 从它的父 context 中去除掉了：实线箭头变成了虚线。且虚线圈框出来的 context 都被取消了，圈内的 context 间的父子关系都荡然无存了。</p><p>重点看 <code>propagateCancel()</code>：</p><pre class=" language-golang"><code class="language-golang">func propagateCancel(parent Context, child canceler) {    // 父节点是个空节点    if parent.Done() == nil {        return // parent is never canceled    }    // 找到可以取消的父 context    if p, ok := parentCancelCtx(parent); ok {        p.mu.Lock()        if p.err != nil {            // 父节点已经被取消了，本节点（子节点）也要取消            child.cancel(false, p.err)        } else {            // 父节点未取消            if p.children == nil {                p.children = make(map[canceler]struct{})            }            // "挂到"父节点上            p.children[child] = struct{}{}        }        p.mu.Unlock()    } else {        // 如果没有找到可取消的父 context。新启动一个协程监控父节点或子节点取消信号        go func() {            select {            case <-parent.Done():                child.cancel(false, parent.Err())            case <-child.Done():            }        }()    }}</code></pre><p>这个方法的作用就是向上寻找可以“挂靠”的“可取消”的 context，并且“挂靠”上去。这样，调用上层 cancel 方法的时候，就可以层层传递，将那些挂靠的子 context 同时“取消”。</p><p>这里着重解释下为什么会有 else 描述的情况发生。<code>else</code> 是指当前节点 context 没有向上找到可以取消的父节点，那么就要再启动一个协程监控父节点或者子节点的取消动作。</p><p>这里就有疑问了，既然没找到可以取消的父节点，那 <code>case &lt;-parent.Done()</code> 这个 case 就永远不会发生，所以可以忽略这个 case；而 <code>case &lt;-child.Done()</code> 这个 case 又啥事不干。那这个 <code>else</code> 不就多余了吗？</p><p>其实不然。我们来看 <code>parentCancelCtx</code> 的代码：</p><pre class=" language-golang"><code class="language-golang">func parentCancelCtx(parent Context) (*cancelCtx, bool) {    for {        switch c := parent.(type) {        case *cancelCtx:            return c, true        case *timerCtx:            return &c.cancelCtx, true        case *valueCtx:            parent = c.Context        default:            return nil, false        }    }}</code></pre><p>这里只会识别三种 Context 类型：<em>cancelCtx，</em>timerCtx，*valueCtx。若是把 Context 内嵌到一个类型里，就识别不出来了。</p><p>由于 context 包的代码并不多，所以我直接把它 copy 出来了，然后在 else 语句里加上了几条打印语句，来验证上面的说法：</p><pre class=" language-golang"><code class="language-golang">type MyContext struct {    // 这里的 Context 是我 copy 出来的，所以前面不用加 context.    Context}func main() {    childCancel := true    parentCtx, parentFunc := WithCancel(Background())    mctx := MyContext{parentCtx}    childCtx, childFun := WithCancel(mctx)    if childCancel {        childFun()    } else {        parentFunc()    }    fmt.Println(parentCtx)    fmt.Println(mctx)    fmt.Println(childCtx)    // 防止主协程退出太快，子协程来不及打印     time.Sleep(10 * time.Second)}</code></pre><p>我自已在 else 里添加的打印语句我就不贴出来了，感兴趣的可以自己动手实验下。我们看下三个 context 的打印结果：</p><pre class=" language-shell"><code class="language-shell">context.Background.WithCancel{context.Background.WithCancel}{context.Background.WithCancel}.WithCancel</code></pre><p>果然，mctx，childCtx 和正常的 parentCtx 不一样，因为它是一个自定义的结构体类型。</p><p><code>else</code> 这段代码说明，如果把 ctx 强行塞进一个结构体，并用它作为父节点，调用 WithCancel 函数构建子节点 context 的时候，Go 会新启动一个协程来监控取消信号，明显有点浪费嘛。</p><p>再来说一下，select 语句里的两个 case 其实都不能删。</p><pre class=" language-golang"><code class="language-golang">select {    case <-parent.Done():        child.cancel(false, parent.Err())    case <-child.Done():}</code></pre><p>第一个 case 说明当父节点取消，则取消子节点。如果去掉这个 case，那么父节点取消的信号就不能传递到子节点。</p><p>第二个 case 是说如果子节点自己取消了，那就退出这个 select，父节点的取消信号就不用管了。如果去掉这个 case，那么很可能父节点一直不取消，这个 goroutine 就泄漏了。当然，如果父节点取消了，就会重复让子节点取消，不过，这也没什么影响嘛。</p><h3 id="timerCtx"><a href="#timerCtx" class="headerlink" title="timerCtx"></a>timerCtx</h3><p>timerCtx 基于 cancelCtx，只是多了一个 time.Timer 和一个 deadline。Timer 会在 deadline 到来时，自动取消 context。</p><pre class=" language-golang"><code class="language-golang">type timerCtx struct {    cancelCtx    timer *time.Timer // Under cancelCtx.mu.    deadline time.Time}</code></pre><p>timerCtx 首先是一个 cancelCtx，所以它能取消。看下 cancel() 方法：</p><pre class=" language-golang"><code class="language-golang">func (c *timerCtx) cancel(removeFromParent bool, err error) {    // 直接调用 cancelCtx 的取消方法    c.cancelCtx.cancel(false, err)    if removeFromParent {        // 从父节点中删除子节点        removeChild(c.cancelCtx.Context, c)    }    c.mu.Lock()    if c.timer != nil {        // 关掉定时器，这样，在deadline 到来时，不会再次取消        c.timer.Stop()        c.timer = nil    }    c.mu.Unlock()}</code></pre><p>创建 timerCtx 的方法：</p><pre class=" language-golang"><code class="language-golang">func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) {    return WithDeadline(parent, time.Now().Add(timeout))}</code></pre><p><code>WithTimeout</code> 函数直接调用了 <code>WithDeadline</code>，传入的 deadline 是当前时间加上 timeout 的时间，也就是从现在开始再经过 timeout 时间就算超时。也就是说，<code>WithDeadline</code> 需要用的是绝对时间。重点来看它：</p><pre class=" language-golang"><code class="language-golang">func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc) {    if cur, ok := parent.Deadline(); ok && cur.Before(deadline) {        // 如果父节点 context 的 deadline 早于指定时间。直接构建一个可取消的 context。        // 原因是一旦父节点超时，自动调用 cancel 函数，子节点也会随之取消。        // 所以不用单独处理子节点的计时器时间到了之后，自动调用 cancel 函数        return WithCancel(parent)    }    // 构建 timerCtx    c := &timerCtx{        cancelCtx: newCancelCtx(parent),        deadline:  deadline,    }    // 挂靠到父节点上    propagateCancel(parent, c)    // 计算当前距离 deadline 的时间    d := time.Until(deadline)    if d <= 0 {        // 直接取消        c.cancel(true, DeadlineExceeded) // deadline has already passed        return c, func() { c.cancel(true, Canceled) }    }    c.mu.Lock()    defer c.mu.Unlock()    if c.err == nil {        // d 时间后，timer 会自动调用 cancel 函数。自动取消        c.timer = time.AfterFunc(d, func() {            c.cancel(true, DeadlineExceeded)        })    }    return c, func() { c.cancel(true, Canceled) }}</code></pre><p>也就是说仍然要把子节点挂靠到父节点，一旦父节点取消了，会把取消信号向下传递到子节点，子节点随之取消。</p><p>有一个特殊情况是，如果要创建的这个子节点的 deadline 比父节点要晚，也就是说如果父节点是时间到自动取消，那么一定会取消这个子节点，导致子节点的 deadline 根本不起作用，因为子节点在 deadline 到来之前就已经被父节点取消了。</p><p>这个函数的最核心的一句是：</p><pre class=" language-golang"><code class="language-golang">c.timer = time.AfterFunc(d, func() {    c.cancel(true, DeadlineExceeded)})</code></pre><p>c.timer 会在 d 时间间隔后，自动调用 cancel 函数，并且传入的错误就是 <code>DeadlineExceeded</code>：</p><pre class=" language-golang"><code class="language-golang">var DeadlineExceeded error = deadlineExceededError{}type deadlineExceededError struct{}func (deadlineExceededError) Error() string   { return "context deadline exceeded" }</code></pre><p>也就是超时错误。</p><h3 id="valueCtx"><a href="#valueCtx" class="headerlink" title="valueCtx"></a>valueCtx</h3><pre class=" language-golang"><code class="language-golang">type valueCtx struct {    Context    key, val interface{}}</code></pre><p>它实现了两个方法：</p><pre class=" language-golang"><code class="language-golang">func (c *valueCtx) String() string {    return fmt.Sprintf("%v.WithValue(%#v, %#v)", c.Context, c.key, c.val)}func (c *valueCtx) Value(key interface{}) interface{} {    if c.key == key {        return c.val    }    return c.Context.Value(key)}</code></pre><p>由于它直接将 Context 作为匿名字段，因此仅管它只实现了 2 个方法，其他方法继承自父 context。但它仍然是一个 Context，这是 Go 语言的一个特点。</p><p>创建 valueCtx 的函数：</p><pre class=" language-golang"><code class="language-golang">func WithValue(parent Context, key, val interface{}) Context {    if key == nil {        panic("nil key")    }    if !reflect.TypeOf(key).Comparable() {        panic("key is not comparable")    }    return &valueCtx{parent, key, val}}</code></pre><p>对 key 的要求是可比较，因为之后需要通过 key 取出 context 中的值，可比较是必须的。</p><p>通过层层传递 context，最终形成这样一棵树：</p><p><img src="https://user-images.githubusercontent.com/7698088/59154893-5e72c300-8aaf-11e9-9b78-3c34b5e73a45.png" alt="valueCtx"></p><p>和链表有点像，只是它的方向相反：Context 指向它的父节点，链表则指向下一个节点。通过 WithValue 函数，可以创建层层的 valueCtx，存储 goroutine 间可以共享的变量。</p><p>取值的过程，实际上是一个递归查找的过程：</p><pre class=" language-golang"><code class="language-golang">func (c *valueCtx) Value(key interface{}) interface{} {    if c.key == key {        return c.val    }    return c.Context.Value(key)}</code></pre><p>它会顺着链路一直往上找，比较当前节点的 key<br>是否是要找的 key，如果是，则直接返回 value。否则，一直顺着 context 往前，最终找到根节点（一般是 emptyCtx），直接返回一个 nil。所以用 Value 方法的时候要判断结果是否为 nil。</p><p>因为查找方向是往上走的，所以，父节点没法获取子节点存储的值，子节点却可以获取父节点的值。</p><p><code>WithValue</code> 创建 context 节点的过程实际上就是创建链表节点的过程。两个节点的 key 值是可以相等的，但它们是两个不同的 context 节点。查找的时候，会向上查找到最后一个挂载的 context 节点，也就是离得比较近的一个父节点 context。所以，整体上而言，用 <code>WithValue</code> 构造的其实是一个低效率的链表。</p><p>如果你接手过项目，肯定经历过这样的窘境：在一个处理过程中，有若干子函数、子协程。各种不同的地方会向 context 里塞入各种不同的 k-v 对，最后在某个地方使用。</p><p>你根本就不知道什么时候什么地方传了什么值？这些值会不会被“覆盖”（底层是两个不同的 context 节点，查找的时候，只会返回一个结果）？你肯定会崩溃的。</p><p>而这也是 <code>context.Value</code> 最受争议的地方。很多人建议尽量不要通过 context 传值。</p><h1 id="如何使用-context"><a href="#如何使用-context" class="headerlink" title="如何使用 context"></a>如何使用 context</h1><p>context 使用起来非常方便。源码里对外提供了一个创建根节点 context 的函数：</p><pre class=" language-golang"><code class="language-golang">func Background() Context</code></pre><p>background 是一个空的 context， 它不能被取消，没有值，也没有超时时间。</p><p>有了根节点 context，又提供了四个函数创建子节点 context：</p><pre class=" language-golang"><code class="language-golang">func WithCancel(parent Context) (ctx Context, cancel CancelFunc)func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)func WithValue(parent Context, key, val interface{}) Context</code></pre><p>context 会在函数传递间传递。只需要在适当的时间调用 cancel 函数向 goroutines 发出取消信号或者调用 Value 函数取出 context 中的值。</p><p>在官方博客里，对于使用 context 提出了几点建议：</p><ol><li>Do not store Contexts inside a struct type; instead, pass a Context explicitly to each function that needs it. The Context should be the first parameter, typically named ctx.</li><li>Do not pass a nil Context, even if a function permits it. Pass context.TODO if you are unsure about which Context to use.</li><li>Use context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.</li><li>The same Context may be passed to functions running in different goroutines; Contexts are safe for simultaneous use by multiple goroutines.</li></ol><p>我翻译一下：</p><ol><li>不要将 Context 塞到结构体里。直接将 Context 类型作为函数的第一参数，而且一般都命名为 ctx。</li><li>不要向函数传入一个 nil 的 context，如果你实在不知道传什么，标准库给你准备好了一个 context：todo。</li><li>不要把本应该作为函数参数的类型塞到 context 中，context 存储的应该是一些共同的数据。例如：登陆的 session、cookie 等。</li><li>同一个 context 可能会被传递到多个 goroutine，别担心，context 是并发安全的。</li></ol><h2 id="传递共享的数据"><a href="#传递共享的数据" class="headerlink" title="传递共享的数据"></a>传递共享的数据</h2><p>对于 Web 服务端开发，往往希望将一个请求处理的整个过程串起来，这就非常依赖于 Thread Local（对于 Go 可理解为单个协程所独有） 的变量，而在 Go 语言中并没有这个概念，因此需要在函数调用的时候传递 context。</p><pre class=" language-golang"><code class="language-golang">package mainimport (    "context"    "fmt")func main() {    ctx := context.Background()    process(ctx)    ctx = context.WithValue(ctx, "traceId", "qcrao-2019")    process(ctx)}func process(ctx context.Context) {    traceId, ok := ctx.Value("traceId").(string)    if ok {        fmt.Printf("process over. trace_id=%s\n", traceId)    } else {        fmt.Printf("process over. no trace_id\n")    }}</code></pre><p>运行结果：</p><pre class=" language-shell"><code class="language-shell">process over. no trace_idprocess over. trace_id=qcrao-2019</code></pre><p>第一次调用 process 函数时，ctx 是一个空的 context，自然取不出来 traceId。第二次，通过 <code>WithValue</code> 函数创建了一个 context，并赋上了 <code>traceId</code> 这个 key，自然就能取出来传入的 value 值。</p><p>当然，现实场景中可能是从一个 HTTP 请求中获取到的 Request-ID。所以，下面这个样例可能更适合：</p><pre class=" language-golang"><code class="language-golang">const requestIDKey int = 0func WithRequestID(next http.Handler) http.Handler {    return http.HandlerFunc(        func(rw http.ResponseWriter, req *http.Request) {            // 从 header 中提取 request-id            reqID := req.Header.Get("X-Request-ID")            // 创建 valueCtx。使用自定义的类型，不容易冲突            ctx := context.WithValue(                req.Context(), requestIDKey, reqID)            // 创建新的请求            req = req.WithContext(ctx)            // 调用 HTTP 处理函数            next.ServeHTTP(rw, req)        }    )}// 获取 request-idfunc GetRequestID(ctx context.Context) string {    ctx.Value(requestIDKey).(string)}func Handle(rw http.ResponseWriter, req *http.Request) {    // 拿到 reqId，后面可以记录日志等等    reqID := GetRequestID(req.Context())    ...}func main() {    handler := WithRequestID(http.HandlerFunc(Handle))    http.ListenAndServe("/", handler)}</code></pre><h2 id="取消-goroutine"><a href="#取消-goroutine" class="headerlink" title="取消 goroutine"></a>取消 goroutine</h2><p>我们先来设想一个场景：打开外卖的订单页，地图上显示外卖小哥的位置，而且是每秒更新 1 次。app 端向后台发起 websocket 连接（现实中可能是轮询）请求后，后台启动一个协程，每隔 1 秒计算 1 次小哥的位置，并发送给端。如果用户退出此页面，则后台需要“取消”此过程，退出 goroutine，系统回收资源。</p><p>后端可能的实现如下：</p><pre class=" language-golang"><code class="language-golang">func Perform() {    for {        calculatePos()        sendResult()        time.Sleep(time.Second)    }}</code></pre><p>如果需要实现“取消”功能，并且在不了解 context 功能的前提下，可能会这样做：给函数增加一个指针型的 bool 变量，在 for 语句的开始处判断 bool 变量是发由 true 变为 false，如果改变，则退出循环。</p><p>上面给出的简单做法，可以实现想要的效果，没有问题，但是并不优雅，并且一旦协程数量多了之后，并且各种嵌套，就会很麻烦。优雅的做法，自然就要用到 context。</p><pre class=" language-golang"><code class="language-golang">func Perform(ctx context.Context) {    for {        calculatePos()        sendResult()        select {        case <-ctx.Done():            // 被取消，直接返回            return        case <-time.After(time.Second):            // block 1 秒钟         }    }}</code></pre><p>主流程可能是这样的：</p><pre class=" language-golang"><code class="language-golang">ctx, cancel := context.WithTimeout(context.Background(), time.Hour)go Perform(ctx)// ……// app 端返回页面，调用cancel 函数cancel()</code></pre><p>注意一个细节，WithTimeOut 函数返回的 context 和 cancelFun 是分开的。context 本身并没有取消函数，这样做的原因是取消函数只能由外层函数调用，防止子节点 context 调用取消函数，从而严格控制信息的流向：由父节点 context 流向子节点 context。</p><h2 id="防止-goroutine-泄漏"><a href="#防止-goroutine-泄漏" class="headerlink" title="防止 goroutine 泄漏"></a>防止 goroutine 泄漏</h2><p>前面那个例子里，goroutine 还是会自己执行完，最后返回，只不过会多浪费一些系统资源。这里改编一个“如果不用 context 取消，goroutine 就会泄漏的例子”，来自参考资料：<code>【避免协程泄漏】</code>。</p><pre class=" language-golang"><code class="language-golang">func gen() <-chan int {    ch := make(chan int)    go func() {        var n int        for {            ch <- n            n++            time.Sleep(time.Second)        }    }()    return ch}</code></pre><p>这是一个可以生成无限整数的协程，但如果我只需要它产生的前 5 个数，那么就会发生 goroutine 泄漏：</p><pre class=" language-golang"><code class="language-golang">func main() {    for n := range gen() {        fmt.Println(n)        if n == 5 {            break        }    }    // ……}</code></pre><p>当 n == 5 的时候，直接 break 掉。那么 gen 函数的协程就会执行无限循环，永远不会停下来。发生了 goroutine 泄漏。</p><p>用 context 改进这个例子：</p><pre class=" language-golang"><code class="language-golang">func gen(ctx context.Context) <-chan int {    ch := make(chan int)    go func() {        var n int        for {            select {            case <-ctx.Done():                return            case ch <- n:                n++                time.Sleep(time.Second)            }        }    }()    return ch}func main() {    ctx, cancel := context.WithCancel(context.Background())    defer cancel() // 避免其他地方忘记 cancel，且重复调用不影响    for n := range gen(ctx) {        fmt.Println(n)        if n == 5 {            cancel()            break        }    }    // ……}</code></pre><p>增加一个 context，在 break 前调用 cancel 函数，取消 goroutine。gen 函数在接收到取消信号后，直接退出，系统回收资源。</p><h1 id="context-真的这么好吗"><a href="#context-真的这么好吗" class="headerlink" title="context 真的这么好吗"></a>context 真的这么好吗</h1><p>读完全文，你一定有这种感觉：context 就是为 server 而设计的。说什么处理一个请求，需要启动多个 goroutine 并行地去处理，并且在这些 goroutine 之间还要传递一些共享的数据等等，这些都是写一个 server 要做的事。</p><p>没错，Go 很适合写 server，但它终归是一门通用的语言。你在用 Go 做 Leetcode 上面的题目的时候，肯定不会认为它和一般的语言有什么差别。所以，很多特性好不好，应该从 <code>Go 只是一门普通的语言，很擅长写 server</code> 的角度来看。</p><p>从这个角度来看，context 并没有那么美好。Go 官方建议我们把 Context 作为函数的第一个参数，甚至连名字都准备好了。这造成一个后果：因为我们想控制所有的协程的取消动作，所以需要在几乎所有的函数里加上一个 Context 参数。很快，我们的代码里，context 将像病毒一样扩散的到处都是。</p><p>在参考资料<code>【Go2 应该去掉 context】</code>这篇英文博客里，作者甚至调侃说：如果要把 Go 标准库的大部分函数都加上 context 参数的话，例如下面这样：</p><pre class=" language-golang"><code class="language-golang">n, err := r.Read(context.TODO(), p)</code></pre><p>就给我来一枪吧！</p><p>原文是这样说的：<code>put a bullet in my head, please.</code>我当时看到这句话的时候，会心一笑。这可能就是陶渊明说的：每有会意，便欣然忘食。当然，我是在晚饭会看到这句话的。</p><p>为了表达自己对 context 并没有什么好感，作者接着又说了一句：If you use ctx.Value in my (non-existent) company, you’re fired. 简直太幽默了，哈哈。</p><p>另外，像 <code>WithCancel</code>、<code>WithDeadline</code>、<code>WithTimeout</code>、<code>WithValue</code> 这些创建函数，实际上是创建了一个个的链表结点而已。我们知道，对链表的操作，通常都是 <code>O(n)</code> 复杂度的，效率不高。</p><p>那么，context 包到底解决了什么问题呢？答案是：<code>cancelation</code>。仅管它并不完美，但它确实很简洁地解决了问题。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里，整个 context 包的内容就全部讲完了。源码非常短，很适合学习，一定要去读一下。</p><p>context 包是 Go 1.7 引入的标准库，主要用于在 goroutine 之间传递取消信号、超时时间、截止时间以及一些共享的值等。它并不是太完美，但几乎成了并发控制和超时控制的标准做法。</p><p>使用上，先创建一个根节点的 context，之后根据库提供的四个函数创建相应功能的子节点 context。由于它是并发安全的，所以可以放心地传递。</p><p>当使用 context 作为函数参数时，直接把它放在第一个参数的位置，并且命名为 ctx。另外，不要把 context 嵌套在自定义的类型里。</p><p>最后，大家下次在看到代码里有用到 context 的，观察下是怎么使用的，肯定逃不出我们讲的几种类型。熟悉之后会发现：context 可能并不完美，但它确实简洁高效地解决了问题。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【context 官方博客】<a href="https://blog.golang.org/context" target="_blank" rel="noopener">https://blog.golang.org/context</a></p><p>【今日头条构建Go的实践】<a href="https://zhuanlan.zhihu.com/p/26695984" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26695984</a></p><p>【飞雪无情的博客】<a href="https://www.flysnow.org/2017/05/12/go-in-action-go-context.html" target="_blank" rel="noopener">https://www.flysnow.org/2017/05/12/go-in-action-go-context.html</a></p><p>【context 源码】<a href="https://juejin.im/post/5a6873fef265da3e317e55b6" target="_blank" rel="noopener">https://juejin.im/post/5a6873fef265da3e317e55b6</a></p><p>【腾讯云源码阅读】<a href="https://cloud.tencent.com/developer/section/1140703" target="_blank" rel="noopener">https://cloud.tencent.com/developer/section/1140703</a></p><p>【更宏观地一些思考，english】<a href="https://siadat.github.io/post/context" target="_blank" rel="noopener">https://siadat.github.io/post/context</a></p><p>【避免协程泄漏】<a href="https://rakyll.org/leakingctx/" target="_blank" rel="noopener">https://rakyll.org/leakingctx/</a></p><p>【应用分类】<a href="https://dreamerjonson.com/2019/05/09/golang-73-context/index.html" target="_blank" rel="noopener">https://dreamerjonson.com/2019/05/09/golang-73-context/index.html</a></p><p>【官方文档示例翻译版】<a href="https://brantou.github.io/2017/05/19/go-concurrency-patterns-context/" target="_blank" rel="noopener">https://brantou.github.io/2017/05/19/go-concurrency-patterns-context/</a></p><p>【例子，english】<a href="http://p.agnihotry.com/post/understanding_the_context_package_in_golang/" target="_blank" rel="noopener">http://p.agnihotry.com/post/understanding_the_context_package_in_golang/</a></p><p>【Go2 应该去掉 context】<a href="https://faiface.github.io/post/context-should-go-away-go2/" target="_blank" rel="noopener">https://faiface.github.io/post/context-should-go-away-go2/</a></p><p>【源码，比较详细】<a href="https://juejin.im/post/5c1514c86fb9a049b82a5acb" target="_blank" rel="noopener">https://juejin.im/post/5c1514c86fb9a049b82a5acb</a></p><p>【Golang Context 是好的设计吗？】<a href="https://segmentfault.com/a/1190000017394302" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017394302</a></p><p>【今日头条的 Go 实践】<a href="https://36kr.com/p/5073181" target="_blank" rel="noopener">https://36kr.com/p/5073181</a></p><p>【实例】<a href="https://zhuanlan.zhihu.com/p/60180409" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/60180409</a></p><p><img src="https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png" alt="QR"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Go 语言的 context 包短小精悍，非常适合新手学习。不论是它的源码还是实际使用，都值得投入时间去学习。&lt;/p&gt;
&lt;p&gt;这篇文章依然想尝试全面、深入地去研究。文章相比往期而言，整体不长，希望你看完可以有所收获！&lt;/p&gt;
&lt;h1 id=&quot;什么是-context&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="编程语言" scheme="https://github.com/qcrao/qcrao.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="golang" scheme="https://github.com/qcrao/qcrao.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>深度解密Go语言之unsafe</title>
    <link href="https://github.com/qcrao/qcrao.github.io/2019/06/03/dive-into-go-unsafe/"/>
    <id>https://github.com/qcrao/qcrao.github.io/2019/06/03/dive-into-go-unsafe/</id>
    <published>2019-06-03T00:25:00.000Z</published>
    <updated>2019-07-24T14:08:31.035Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇<a href="https://mp.weixin.qq.com/s/2CDpE5wfoiNXm1agMAq4wA" target="_blank" rel="noopener">文章</a>我们详细分析了 map 的底层实现，如果你也跟着阅读了源码，那一定对 <code>unsafe.Pointer</code> 不陌生，map 对 key 进行定位的时候，大量使用。</p><p><code>unsafe.Pointer</code> 位于 <code>unsafe 包</code>，这篇文章，我们来深入研究 unsafe 包。先说明一下，本文没有之前那么长了，你可以比较轻松地读完，这样的时候不是太多。</p><p>上次发布文章的时候，包括代码超过 5w 字，后台编辑器的体验非常差，一度让我怀疑人生。我之前说过，像 map 那样的长文，估计能读完的不超过 <code>1 %</code>。像下面这几位同学的评价，并不多见。</p><p><img src="https://user-images.githubusercontent.com/7698088/58759953-7eacfa00-8564-11e9-9d92-9974ffe7f8d7.png" alt="wechat"></p><p>个人认为，学习本身并不是一件轻松愉快的事情，寓教于乐是个美好的愿望。想要深刻地领悟，就得付出别人看不见的努力。学习从来都不会是一件轻松的事情，枯燥是正常的。耐住性子，深入研究某个问题，读书、看文章、写博客都可以，浮躁时代做个专注的人！</p><h1 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h1><p>在正式介绍 unsafe 包之前，需要着重介绍 Go 语言中的指针类型。</p><p>我本科开始学编程的时候，第一门语言就是 C。之后又陆续学过 C++，Java，Python，这些语言都挺强大的，但是没了 C 语言那么“单纯”。直到我开始接触 Go 语言，又找到了那种感觉。Go 语言的作者之一 Ken Thompson 也是 C 语言的作者。所以，Go 可以看作 C 系语言，它的很多特性都和 C 类似，指针就是其中之一。</p><p>然而，Go 语言的指针相比 C 的指针有很多限制。这当然是为了安全考虑，要知道像 Java/Python 这些现代语言，生怕程序员出错，哪有什么指针（这里指的是显式的指针）？更别说像 C/C++ 还需要程序员自己清理“垃圾”。所以对于 Go 来说，有指针已经很不错了，仅管它有很多限制。</p><p>为什么需要指针类型呢？参考文献 go101.org 里举了这样一个例子：</p><pre class=" language-golang"><code class="language-golang">package mainimport "fmt"func double(x int) {    x += x}func main() {    var a = 3    double(a)    fmt.Println(a) // 3}</code></pre><p>非常简单，我想在 double 函数里将 a 翻倍，但是例子中的函数却做不到。为什么？因为 Go 语言的函数传参都是<code>值传递</code>。double 函数里的 x 只是实参 a 的一个拷贝，在函数内部对 x 的操作不能反馈到实参 a。</p><p>如果这时，有一个指针就可以解决问题了！这也是我们常用的“伎俩”。</p><pre class=" language-golang"><code class="language-golang">package mainimport "fmt"func double(x *int) {    *x += *x    x = nil}func main() {    var a = 3    double(&a)    fmt.Println(a) // 6    p := &a    double(p)    fmt.Println(a, p == nil) // 12 false}</code></pre><p>很常规的操作，不用多解释。唯一可能有些疑惑的在这一句：</p><pre class=" language-golang"><code class="language-golang">x = nil</code></pre><p>这得稍微思考一下，才能得出这一行代码根本不影响的结论。因为是值传递，所以 x 也只是对 &amp;a 的一个拷贝。</p><pre class=" language-golang"><code class="language-golang">*x += *x</code></pre><p>这一句把 x 指向的值（也就是 &amp;a 指向的值，即变量 a）变为原来的 2 倍。但是对 x 本身（一个指针）的操作却不会影响外层的 a，所以 <code>x = nil</code> 掀不起任何大风大浪。</p><p>下面的这张图可以“自证清白”：</p><p><img src="https://user-images.githubusercontent.com/7698088/58675362-96c72280-8386-11e9-89a6-f37204648b03.png" alt="pointer copy"></p><p>然而，相比于 C 语言中指针的灵活，Go 的指针多了一些限制。但这也算是 Go 的成功之处：既可以享受指针带来的便利，又避免了指针的危险性。</p><p>限制一：<code>Go 的指针不能进行数学运算</code>。</p><p>来看一个简单的例子：</p><pre class=" language-golang"><code class="language-golang">a := 5p := &ap++p = &a + 3</code></pre><p>上面的代码将不能通过编译，会报编译错误：<code>invalid operation</code>，也就是说不能对指针做数学运算。</p><p>限制二：<code>不同类型的指针不能相互转换</code>。</p><p>例如下面这个简短的例子：</p><pre class=" language-golang"><code class="language-golang">func main() {    a := int(100)    var f *float64    f = &a}</code></pre><p>也会报编译错误：</p><pre class=" language-shell"><code class="language-shell">cannot use &a (type *int) as type *float64 in assignment</code></pre><p>关于两个指针能否相互转换，参考资料中 go 101 相关文章里写得非常细，这里我不想展开。个人认为记住这些没有什么意义，有完美主义的同学可以去阅读原文。当然我也有完美主义，但我有时会克制，嘿嘿。</p><p>限制三：<code>不同类型的指针不能使用 == 或 != 比较</code>。</p><p>只有在两个指针类型相同或者可以相互转换的情况下，才可以对两者进行比较。另外，指针可以通过 <code>==</code> 和 <code>!=</code> 直接和 <code>nil</code> 作比较。</p><p>限制四：<code>不同类型的指针变量不能相互赋值</code>。</p><p>这一点同限制三。</p><h1 id="什么是-unsafe"><a href="#什么是-unsafe" class="headerlink" title="什么是 unsafe"></a>什么是 unsafe</h1><p>前面所说的指针是类型安全的，但它有很多限制。Go 还有非类型安全的指针，这就是 unsafe 包提供的 unsafe.Pointer。在某些情况下，它会使代码更高效，当然，也更危险。</p><p>unsafe 包用于 Go 编译器，在编译阶段使用。从名字就可以看出来，它是不安全的，官方并不建议使用。我在用 unsafe 包的时候会有一种不舒服的感觉，可能这也是语言设计者的意图吧。</p><p>但是高阶的 Gopher，怎么能不会使用 unsafe 包呢？它可以绕过 Go 语言的类型系统，直接操作内存。例如，一般我们不能操作一个结构体的未导出成员，但是通过 unsafe 包就能做到。unsafe 包让我可以直接读写内存，还管你什么导出还是未导出。</p><h1 id="为什么有-unsafe"><a href="#为什么有-unsafe" class="headerlink" title="为什么有 unsafe"></a>为什么有 unsafe</h1><p>Go 语言类型系统是为了安全和效率设计的，有时，安全会导致效率低下。有了 unsafe 包，高阶的程序员就可以利用它绕过类型系统的低效。因此，它就有了存在的意义，阅读 Go 源码，会发现有大量使用 unsafe 包的例子。</p><h1 id="unsafe-实现原理"><a href="#unsafe-实现原理" class="headerlink" title="unsafe 实现原理"></a>unsafe 实现原理</h1><p>我们来看源码：</p><pre class=" language-golang"><code class="language-golang">type ArbitraryType inttype Pointer *ArbitraryType</code></pre><p>从命名来看，<code>Arbitrary</code> 是任意的意思，也就是说 Pointer 可以指向任意类型，实际上它类似于 C 语言里的 <code>void*</code>。</p><p>unsafe 包还有其他三个函数：</p><pre class=" language-golang"><code class="language-golang">func Sizeof(x ArbitraryType) uintptrfunc Offsetof(x ArbitraryType) uintptrfunc Alignof(x ArbitraryType) uintptr</code></pre><p><code>Sizeof</code> 返回类型 x 所占据的字节数，但不包含 x 所指向的内容的大小。例如，对于一个指针，函数返回的大小为 8 字节（64位机上），一个 slice 的大小则为 slice header 的大小。</p><p><code>Offsetof</code> 返回结构体成员在内存中的位置离结构体起始处的字节数，所传参数必须是结构体的成员。</p><p><code>Alignof</code> 返回 m，m 是指当类型进行内存对齐时，它分配到的内存地址能整除 m。</p><p>注意到以上三个函数返回的结果都是 uintptr 类型，这和 unsafe.Pointer 可以相互转换。三个函数都是在编译期间执行，它们的结果可以直接赋给 <code>const 型变量</code>。另外，因为三个函数执行的结果和操作系统、编译器相关，所以是不可移植的。</p><p>综上所述，unsafe 包提供了 2 点重要的能力：</p><blockquote><ol><li>任何类型的指针和 unsafe.Pointer 可以相互转换。</li><li>uintptr 类型和 unsafe.Pointer 可以相互转换。</li></ol></blockquote><p><img src="https://user-images.githubusercontent.com/7698088/58747453-1dbaee80-849e-11e9-8c75-2459f76792d2.png" alt="type pointer uintptr"></p><p>pointer 不能直接进行数学运算，但可以把它转换成 uintptr，对 uintptr 类型进行数学运算，再转换成 pointer 类型。</p><pre class=" language-golang"><code class="language-golang">// uintptr 是一个整数类型，它足够大，可以存储type uintptr uintptr</code></pre><p>还有一点要注意的是，uintptr 并没有指针的语义，意思就是 uintptr 所指向的对象会被 gc 无情地回收。而 unsafe.Pointer 有指针语义，可以保护它所指向的对象在“有用”的时候不会被垃圾回收。</p><p>unsafe 包中的几个函数都是在编译期间执行完毕，毕竟，编译器对内存分配这些操作“了然于胸”。在 <code>/usr/local/go/src/cmd/compile/internal/gc/unsafe.go</code> 路径下，可以看到编译期间 Go 对 unsafe 包中函数的处理。</p><p>更深层的原理需要去研究编译器的源码，这里就不去深究了。我们重点关注它的用法，接着往下看。</p><h1 id="unsafe-如何使用"><a href="#unsafe-如何使用" class="headerlink" title="unsafe 如何使用"></a>unsafe 如何使用</h1><h2 id="获取-slice-长度"><a href="#获取-slice-长度" class="headerlink" title="获取 slice 长度"></a>获取 slice 长度</h2><p>通过前面关于 slice 的<a href="https://mp.weixin.qq.com/s/MTZ0C9zYsNrb8wyIm2D8BA" target="_blank" rel="noopener">文章</a>，我们知道了 slice header 的结构体定义：</p><pre class=" language-golang"><code class="language-golang">// runtime/slice.gotype slice struct {    array unsafe.Pointer // 元素指针    len   int // 长度     cap   int // 容量}</code></pre><p>调用 make 函数新建一个 slice，底层调用的是 makeslice 函数，返回的是 slice 结构体：</p><pre class=" language-golang"><code class="language-golang">func makeslice(et *_type, len, cap int) slice</code></pre><p>因此我们可以通过 unsafe.Pointer 和 uintptr 进行转换，得到 slice 的字段值。</p><pre class=" language-golang"><code class="language-golang">func main() {    s := make([]int, 9, 20)    var Len = *(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&s)) + uintptr(8)))    fmt.Println(Len, len(s)) // 9 9    var Cap = *(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&s)) + uintptr(16)))    fmt.Println(Cap, cap(s)) // 20 20}</code></pre><p>Len，cap 的转换流程如下：</p><pre class=" language-golang"><code class="language-golang">Len: &s => pointer => uintptr => pointer => *int => intCap: &s => pointer => uintptr => pointer => *int => int</code></pre><h2 id="获取-map-长度"><a href="#获取-map-长度" class="headerlink" title="获取 map 长度"></a>获取 map 长度</h2><p>再来看一下上篇文章我们讲到的 map：</p><pre class=" language-golang"><code class="language-golang">type hmap struct {    count     int    flags     uint8    B         uint8    noverflow uint16    hash0     uint32    buckets    unsafe.Pointer    oldbuckets unsafe.Pointer    nevacuate  uintptr    extra *mapextra}</code></pre><p>和 slice 不同的是，makemap 函数返回的是 hmap 的指针，注意是指针：</p><pre class=" language-golang"><code class="language-golang">func makemap(t *maptype, hint int64, h *hmap, bucket unsafe.Pointer) *hmap</code></pre><p>我们依然能通过 unsafe.Pointer 和 uintptr 进行转换，得到 hamp 字段的值，只不过，现在 count 变成二级指针了：</p><pre class=" language-golang"><code class="language-golang">func main() {    mp := make(map[string]int)    mp["qcrao"] = 100    mp["stefno"] = 18    count := **(**int)(unsafe.Pointer(&mp))    fmt.Println(count, len(mp)) // 2 2}</code></pre><p>count 的转换过程：</p><pre class=" language-golang"><code class="language-golang">&mp => pointer => **int => int</code></pre><h2 id="map-源码中的应用"><a href="#map-源码中的应用" class="headerlink" title="map 源码中的应用"></a>map 源码中的应用</h2><p>在 map 源码中，mapaccess1、mapassign、mapdelete 函数中，需要定位 key 的位置，会先对 key 做哈希运算。</p><p>例如：</p><pre class=" language-golang"><code class="language-golang">b := (*bmap)(unsafe.Pointer(uintptr(h.buckets) + (hash&m)*uintptr(t.bucketsize)))</code></pre><p><code>h.buckets</code> 是一个 <code>unsafe.Pointer</code>，将它转换成 <code>uintptr</code>，然后加上 <code>(hash&amp;m)*uintptr(t.bucketsize)</code>，二者相加的结果再次转换成 <code>unsafe.Pointer</code>，最后，转换成 <code>bmap 指针</code>，得到 key 所落入的 bucket 位置。如果不熟悉这个公式，可以看看上一篇文章，浅显易懂。</p><p>上面举的例子相对简单，来看一个关于赋值的更难一点的例子：</p><pre class=" language-golang"><code class="language-golang">// store new key/value at insert positionif t.indirectkey {    kmem := newobject(t.key)    *(*unsafe.Pointer)(insertk) = kmem    insertk = kmem}if t.indirectvalue {    vmem := newobject(t.elem)    *(*unsafe.Pointer)(val) = vmem}typedmemmove(t.key, insertk, key)</code></pre><p>这段代码是在找到了 key 要插入的位置后，进行“赋值”操作。insertk 和 val 分别表示 key 和 value 所要“放置”的地址。如果 t.indirectkey 为真，说明 bucket 中存储的是 key 的指针，因此需要将 insertk 看成<code>指针的指针</code>，这样才能将 bucket 中的相应位置的值设置成指向真实 key 的地址值，也就是说 key 存放的是指针。</p><p>下面这张图展示了设置 key 的全部操作：</p><p><img src="https://user-images.githubusercontent.com/7698088/58756044-c1e67900-8522-11e9-9dda-72ba2a731acf.png" alt="map assign"></p><p>obj 是真实的 key 存放的地方。第 4 号图，obj 表示执行完 <code>typedmemmove</code> 函数后，被成功赋值。</p><h2 id="Offsetof-获取成员偏移量"><a href="#Offsetof-获取成员偏移量" class="headerlink" title="Offsetof 获取成员偏移量"></a>Offsetof 获取成员偏移量</h2><p>对于一个结构体，通过 offset 函数可以获取结构体成员的偏移量，进而获取成员的地址，读写该地址的内存，就可以达到改变成员值的目的。</p><p>这里有一个内存分配相关的事实：结构体会被分配一块连续的内存，结构体的地址也代表了第一个成员的地址。</p><p>我们来看一个例子：</p><pre class=" language-golang"><code class="language-golang">package mainimport (    "fmt"    "unsafe")type Programmer struct {    name string    language string}func main() {    p := Programmer{"stefno", "go"}    fmt.Println(p)    name := (*string)(unsafe.Pointer(&p))    *name = "qcrao"    lang := (*string)(unsafe.Pointer(uintptr(unsafe.Pointer(&p)) + unsafe.Offsetof(p.language)))    *lang = "Golang"    fmt.Println(p)}</code></pre><p>运行代码，输出：</p><pre class=" language-shell"><code class="language-shell">{stefno go}{qcrao Golang}</code></pre><p>name 是结构体的第一个成员，因此可以直接将 &amp;p 解析成 *string。这一点，在前面获取 map 的 count 成员时，用的是同样的原理。</p><p>对于结构体的私有成员，现在有办法可以通过 unsafe.Pointer 改变它的值了。</p><p>我把 Programmer 结构体升级，多加一个字段：</p><pre class=" language-golang"><code class="language-golang">type Programmer struct {    name string    age int    language string}</code></pre><p>并且放在其他包，这样在 main 函数中，它的三个字段都是私有成员变量，不能直接修改。但我通过 unsafe.Sizeof() 函数可以获取成员大小，进而计算出成员的地址，直接修改内存。</p><pre class=" language-golang"><code class="language-golang">func main() {    p := Programmer{"stefno", 18, "go"}    fmt.Println(p)    lang := (*string)(unsafe.Pointer(uintptr(unsafe.Pointer(&p)) + unsafe.Sizeof(int(0)) + unsafe.Sizeof(string(""))))    *lang = "Golang"    fmt.Println(p)}</code></pre><p>输出：</p><pre class=" language-shell"><code class="language-shell">{stefno 18 go}{stefno 18 Golang}</code></pre><h2 id="string-和-slice-的相互转换"><a href="#string-和-slice-的相互转换" class="headerlink" title="string 和 slice 的相互转换"></a>string 和 slice 的相互转换</h2><p>这是一个非常精典的例子。实现字符串和 bytes 切片之间的转换，要求是 <code>zero-copy</code>。想一下，一般的做法，都需要遍历字符串或 bytes 切片，再挨个赋值。</p><p>完成这个任务，我们需要了解 slice 和 string 的底层数据结构：</p><pre class=" language-golang"><code class="language-golang">type StringHeader struct {    Data uintptr    Len  int}type SliceHeader struct {    Data uintptr    Len  int    Cap  int}</code></pre><p>上面是反射包下的结构体，路径：src/reflect/value.go。只需要共享底层 []byte 数组就可以实现 <code>zero-copy</code>。</p><pre class=" language-golang"><code class="language-golang">func string2bytes(s string) []byte {    stringHeader := (*reflect.StringHeader)(unsafe.Pointer(&s))    bh := reflect.SliceHeader{        Data: stringHeader.Data,        Len:  stringHeader.Len,        Cap:  stringHeader.Len,    }    return *(*[]byte)(unsafe.Pointer(&bh))}func bytes2string(b []byte) string{    sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&b))    sh := reflect.StringHeader{        Data: sliceHeader.Data,        Len:  sliceHeader.Len,    }    return *(*string)(unsafe.Pointer(&sh))}</code></pre><p>代码比较简单，不作详细解释。通过构造 slice header 和 string header，来完成 string 和 byte slice 之间的转换。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>unsafe 包绕过了 Go 的类型系统，达到直接操作内存的目的，使用它有一定的风险性。但是在某些场景下，使用 unsafe 包提供的函数会提升代码的效率，Go 源码中也是大量使用 unsafe 包。</p><p>unsafe 包定义了 Pointer 和三个函数：</p><pre class=" language-golang"><code class="language-golang">type ArbitraryType inttype Pointer *ArbitraryTypefunc Sizeof(x ArbitraryType) uintptrfunc Offsetof(x ArbitraryType) uintptrfunc Alignof(x ArbitraryType) uintptr</code></pre><p>通过三个函数可以获取变量的大小、偏移、对齐等信息。</p><p>uintptr 可以和 unsafe.Pointer 进行相互转换，uintptr 可以进行数学运算。这样，通过 uintptr 和 unsafe.Pointer 的结合就解决了 Go 指针不能进行数学运算的限制。</p><p>通过 unsafe 相关函数，可以获取结构体私有成员的地址，进而对其做进一步的读写操作，突破 Go 的类型安全限制。关于 unsafe 包，我们更多关注它的用法。</p><p>顺便说一句，unsafe 包用多了之后，也不觉得它的名字有多么地不“美观”了。相反，因为使用了官方并不提倡的东西，反而觉得有点酷炫。这就是叛逆的感觉吧。</p><p>最后，点击<a href="https://github.com/qcrao/Go-Questions">阅读原文</a>，你将参与见证一个千星项目的成长，你值得拥有！</p><p><img src="https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png" alt="QR"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【飞雪无情的博客】<a href="https://www.flysnow.org/2017/07/06/go-in-action-unsafe-pointer.html" target="_blank" rel="noopener">https://www.flysnow.org/2017/07/06/go-in-action-unsafe-pointer.html</a></p><p>【译文 unsafe包详解】<a href="https://gocn.vip/question/371" target="_blank" rel="noopener">https://gocn.vip/question/371</a></p><p>【官方文档】<a href="https://golang.org/pkg/unsafe/" target="_blank" rel="noopener">https://golang.org/pkg/unsafe/</a></p><p>【例子】<a href="http://www.opscoder.info/golang_unsafe.html" target="_blank" rel="noopener">http://www.opscoder.info/golang_unsafe.html</a></p><p>【煎鱼大佬的博客】<a href="https://segmentfault.com/a/1190000017389782" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017389782</a></p><p>【go语言圣经】<a href="https://www.kancloud.cn/wizardforcel/gopl-zh/106477" target="_blank" rel="noopener">https://www.kancloud.cn/wizardforcel/gopl-zh/106477</a></p><p>【pointer and system calls】<a href="https://blog.gopheracademy.com/advent-2017/unsafe-pointer-and-system-calls/" target="_blank" rel="noopener">https://blog.gopheracademy.com/advent-2017/unsafe-pointer-and-system-calls/</a></p><p>【pointer and uintptr】<a href="https://my.oschina.net/xinxingegeya/blog/729673" target="_blank" rel="noopener">https://my.oschina.net/xinxingegeya/blog/729673</a></p><p>【unsafe.pointer】<a href="https://go101.org/article/unsafe.html" target="_blank" rel="noopener">https://go101.org/article/unsafe.html</a></p><p>【go 指针类型】<a href="https://go101.org/article/pointer.html" target="_blank" rel="noopener">https://go101.org/article/pointer.html</a></p><p>【码洞 快学Go语言 unsafe】<a href="https://juejin.im/post/5c189dce5188256b2e71e79b" target="_blank" rel="noopener">https://juejin.im/post/5c189dce5188256b2e71e79b</a></p><p>【官方文档】<a href="https://golang.org/pkg/unsafe/" target="_blank" rel="noopener">https://golang.org/pkg/unsafe/</a></p><p>【jasper 的小窝】<a href="http://www.opscoder.info/golang_unsafe.html" target="_blank" rel="noopener">http://www.opscoder.info/golang_unsafe.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇&lt;a href=&quot;https://mp.weixin.qq.com/s/2CDpE5wfoiNXm1agMAq4wA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章&lt;/a&gt;我们详细分析了 map 的底层实现，如果你也跟着阅读了源码，那一定对 &lt;c
      
    
    </summary>
    
      <category term="编程语言" scheme="https://github.com/qcrao/qcrao.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="golang" scheme="https://github.com/qcrao/qcrao.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>深度解密Go语言之map</title>
    <link href="https://github.com/qcrao/qcrao.github.io/2019/05/22/dive-into-go-map/"/>
    <id>https://github.com/qcrao/qcrao.github.io/2019/05/22/dive-into-go-map/</id>
    <published>2019-05-22T01:57:00.000Z</published>
    <updated>2019-07-24T13:27:23.780Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要讲 map 的赋值、删除、查询、扩容的具体执行过程，仍然是从底层的角度展开。结合源码，看完本文一定会彻底明白 map 底层原理。</p><p>我要说明的是，这里对 map 的基本用法涉及比较少，我相信可以通过阅读其他入门书籍了解。本文的内容比较深入，但是由于我画了各种图，我相信很容易看懂。</p><h1 id="什么是-map"><a href="#什么是-map" class="headerlink" title="什么是 map"></a>什么是 map</h1><p>维基百科里这样定义 map：</p><blockquote><p>In computer science, an associative array, map, symbol table, or dictionary is an abstract data type composed of a collection of (key, value) pairs, such that each possible key appears at most once in the collection.</p></blockquote><p>简单说明一下：在计算机科学里，被称为相关数组、map、符号表或者字典，是由一组 <code>&lt;key, value&gt;</code> 对组成的抽象数据结构，并且同一个 key 只会出现一次。</p><p>有两个关键点：map 是由 <code>key-value</code> 对组成的；<code>key</code> 只会出现一次。</p><p>和 map 相关的操作主要是：</p><ol><li>增加一个 k-v 对 —— Add or insert；</li><li>删除一个 k-v 对 —— Remove or delete；</li><li>修改某个 k 对应的 v —— Reassign；</li><li>查询某个 k 对应的 v —— Lookup；</li></ol><p>简单说就是最基本的 <code>增删查改</code>。</p><p>map 的设计也被称为 “The dictionary problem”，它的任务是设计一种数据结构用来维护一个集合的数据，并且可以同时对集合进行增删查改的操作。最主要的数据结构有两种：<code>哈希查找表（Hash table）</code>、<code>搜索树（Search tree）</code>。</p><p>哈希查找表用一个哈希函数将 key 分配到不同的桶（bucket，也就是数组的不同 index）。这样，开销主要在哈希函数的计算以及数组的常数访问时间。在很多场景下，哈希查找表的性能很高。</p><p>哈希查找表一般会存在“碰撞”的问题，就是说不同的 key 被哈希到了同一个 bucket。一般有两种应对方法：<code>链表法</code>和<code>开放地址法</code>。<code>链表法</code>将一个 bucket 实现成一个链表，落在同一个 bucket 中的 key 都会插入这个链表。<code>开放地址法</code>则是碰撞发生后，通过一定的规律，在数组的后面挑选“空位”，用来放置新的 key。</p><p>搜索树法一般采用自平衡搜索树，包括：AVL 树，红黑树。面试时经常会被问到，甚至被要求手写红黑树代码，很多时候，面试官自己都写不上来，非常过分。</p><p>自平衡搜索树法的最差搜索效率是 O(logN)，而哈希查找表最差是 O(N)。当然，哈希查找表的平均查找效率是 O(1)，如果哈希函数设计的很好，最坏的情况基本不会出现。还有一点，遍历自平衡搜索树，返回的 key 序列，一般会按照从小到大的顺序；而哈希查找表则是乱序的。</p><h1 id="为什么要用-map"><a href="#为什么要用-map" class="headerlink" title="为什么要用 map"></a>为什么要用 map</h1><p>从 Go 语言官方博客摘录一段话：</p><blockquote><p>One of the most useful data structures in computer science is the hash table. Many hash table implementations exist with varying properties, but in general they offer fast lookups, adds, and deletes. Go provides a built-in map type that implements a hash table.</p></blockquote><p>hash table 是计算机数据结构中一个最重要的设计。大部分 hash table 都实现了快速查找、添加、删除的功能。Go 语言内置的 map 实现了上述所有功能。</p><p>很难想象写一个程序不使用 map，以至于在回答为什么要用 map 这个问题上犯了难。</p><p>所以，到底为什么要用 map 呢？因为它太强大了，各种增删查改的操作效率非常高。</p><h1 id="map-的底层如何实现"><a href="#map-的底层如何实现" class="headerlink" title="map 的底层如何实现"></a>map 的底层如何实现</h1><p>首先声明我用的 Go 版本：</p><pre class=" language-shell"><code class="language-shell">go version go1.9.2 darwin/amd64</code></pre><p>前面说了 map 实现的几种方案，Go 语言采用的是哈希查找表，并且使用链表解决哈希冲突。</p><p>接下来我们要探索 map 的核心原理，一窥它的内部结构。</p><h2 id="map-内存模型"><a href="#map-内存模型" class="headerlink" title="map 内存模型"></a>map 内存模型</h2><p>在源码中，表示 map 的结构体是 hmap，它是 hashmap 的“缩写”：</p><pre class=" language-golang"><code class="language-golang">// A header for a Go map.type hmap struct {    // 元素个数，调用 len(map) 时，直接返回此值    count     int    flags     uint8    // buckets 的对数 log_2    B         uint8    // overflow 的 bucket 近似数    noverflow uint16    // 计算 key 的哈希的时候会传入哈希函数    hash0     uint32    // 指向 buckets 数组，大小为 2^B    // 如果元素个数为0，就为 nil    buckets    unsafe.Pointer    // 扩容的时候，buckets 长度会是 oldbuckets 的两倍    oldbuckets unsafe.Pointer    // 指示扩容进度，小于此地址的 buckets 迁移完成    nevacuate  uintptr    extra *mapextra // optional fields}</code></pre><p>说明一下，<code>B</code> 是 buckets 数组的长度的对数，也就是说 buckets 数组的长度就是 2^B。bucket 里面存储了 key 和 value，后面会再讲。</p><p>buckets 是一个指针，最终它指向的是一个结构体：</p><pre class=" language-golang"><code class="language-golang">type bmap struct {    tophash [bucketCnt]uint8}</code></pre><p>但这只是表面(src/runtime/hashmap.go)的结构，编译期间会给它加料，动态地创建一个新的结构：</p><pre class=" language-golang"><code class="language-golang">type bmap struct {    topbits  [8]uint8    keys     [8]keytype    values   [8]valuetype    pad      uintptr    overflow uintptr}</code></pre><p><code>bmap</code> 就是我们常说的“桶”，桶里面会最多装 8 个 key，这些 key 之所以会落入同一个桶，是因为它们经过哈希计算后，哈希结果是“一类”的。在桶内，又会根据 key 计算出来的 hash 值的高 8 位来决定 key 到底落入桶内的哪个位置（一个桶内最多有8个位置）。</p><p>来一个整体的图：</p><p><img src="https://user-images.githubusercontent.com/7698088/57576986-acd87600-749f-11e9-8710-75e423c7efdb.png" alt="hashmap bmap"></p><p>当 map 的 key 和 value 都不是指针，并且 size 都小于 128 字节的情况下，会把 bmap 标记为不含指针，这样可以避免 gc 时扫描整个 hmap。但是，我们看 bmap 其实有一个 overflow 的字段，是指针类型的，破坏了 bmap 不含指针的设想，这时会把 overflow 移动到 extra 字段来。</p><pre class=" language-golang"><code class="language-golang">type mapextra struct {    // overflow[0] contains overflow buckets for hmap.buckets.    // overflow[1] contains overflow buckets for hmap.oldbuckets.    overflow [2]*[]*bmap    // nextOverflow 包含空闲的 overflow bucket，这是预分配的 bucket    nextOverflow *bmap}</code></pre><p>bmap 是存放 k-v 的地方，我们把视角拉近，仔细看 bmap 的内部组成。</p><p><img src="https://user-images.githubusercontent.com/7698088/57577391-f88f1d80-74a7-11e9-893c-4783dc4fb35e.png" alt="bmap struct"></p><p>上图就是 bucket 的内存模型，<code>HOB Hash</code> 指的就是 top hash。 注意到 key 和 value 是各自放在一起的，并不是 <code>key/value/key/value/...</code> 这样的形式。源码里说明这样的好处是在某些情况下可以省略掉 padding 字段，节省内存空间。</p><p>例如，有这样一个类型的 map：</p><pre class=" language-golang"><code class="language-golang">map[int64]int8</code></pre><p>如果按照 <code>key/value/key/value/...</code> 这样的模式存储，那在每一个 key/value 对之后都要额外 padding 7 个字节；而将所有的 key，value 分别绑定到一起，这种形式 <code>key/key/.../value/value/...</code>，则只需要在最后添加 padding。</p><p>每个 bucket 设计成最多只能放 8 个 key-value 对，如果有第 9 个 key-value 落入当前的 bucket，那就需要再构建一个 bucket ，通过 <code>overflow</code> 指针连接起来。</p><h2 id="创建-map"><a href="#创建-map" class="headerlink" title="创建 map"></a>创建 map</h2><p>从语法层面上来说，创建 map 很简单：</p><pre class=" language-golang"><code class="language-golang">ageMp := make(map[string]int)// 指定 map 长度ageMp := make(map[string]int, 8)// ageMp 为 nil，不能向其添加元素，会直接panicvar ageMp map[string]int</code></pre><p>通过汇编语言可以看到，实际上底层调用的是 <code>makemap</code> 函数，主要做的工作就是初始化 <code>hmap</code> 结构体的各种字段，例如计算 B 的大小，设置哈希种子 hash0 等等。</p><pre class=" language-golang"><code class="language-golang">func makemap(t *maptype, hint int64, h *hmap, bucket unsafe.Pointer) *hmap {    // 省略各种条件检查...    // 找到一个 B，使得 map 的装载因子在正常范围内    B := uint8(0)    for ; overLoadFactor(hint, B); B++ {    }    // 初始化 hash table    // 如果 B 等于 0，那么 buckets 就会在赋值的时候再分配    // 如果长度比较大，分配内存会花费长一点    buckets := bucket    var extra *mapextra    if B != 0 {        var nextOverflow *bmap        buckets, nextOverflow = makeBucketArray(t, B)        if nextOverflow != nil {            extra = new(mapextra)            extra.nextOverflow = nextOverflow        }    }    // 初始化 hamp    if h == nil {        h = (*hmap)(newobject(t.hmap))    }    h.count = 0    h.B = B    h.extra = extra    h.flags = 0    h.hash0 = fastrand()    h.buckets = buckets    h.oldbuckets = nil    h.nevacuate = 0    h.noverflow = 0    return h}</code></pre><p>注意，这个函数返回的结果：<code>*hmap</code>，它是一个指针，而我们之前讲过的 <code>makeslice</code> 函数返回的是 <code>Slice</code> 结构体：</p><pre class=" language-golang"><code class="language-golang">func makeslice(et *_type, len, cap int) slice</code></pre><p>回顾一下 slice 的结构体定义：</p><pre class=" language-golang"><code class="language-golang">// runtime/slice.gotype slice struct {    array unsafe.Pointer // 元素指针    len   int // 长度     cap   int // 容量}</code></pre><p>结构体内部包含底层的数据指针。</p><p>makemap 和 makeslice 的区别，带来一个不同点：当 map 和 slice 作为函数参数时，在函数参数内部对 map 的操作会影响 map 自身；而对 slice 却不会（之前讲 slice 的文章里有讲过）。</p><p>主要原因：一个是指针（<code>*hmap</code>），一个是结构体（<code>slice</code>）。Go 语言中的函数传参都是值传递，在函数内部，参数会被 copy 到本地。<code>*hmap</code>指针 copy 完之后，仍然指向同一个 map，因此函数内部对 map 的操作会影响实参。而 slice 被 copy 后，会成为一个新的 slice，对它进行的操作不会影响到实参。</p><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>map 的一个关键点在于，哈希函数的选择。在程序启动时，会检测 cpu 是否支持 aes，如果支持，则使用 aes hash，否则使用 memhash。这是在函数 <code>alginit()</code> 中完成，位于路径：<code>src/runtime/alg.go</code> 下。</p><blockquote><p>hash 函数，有加密型和非加密型。<br>加密型的一般用于加密数据、数字摘要等，典型代表就是 md5、sha1、sha256、aes256 这种；<br>非加密型的一般就是查找。在 map 的应用场景中，用的是查找。<br>选择 hash 函数主要考察的是两点：性能、碰撞概率。</p></blockquote><p>之前我们讲过，表示类型的结构体：</p><pre class=" language-golang"><code class="language-golang">type _type struct {    size       uintptr    ptrdata    uintptr // size of memory prefix holding all pointers    hash       uint32    tflag      tflag    align      uint8    fieldalign uint8    kind       uint8    alg        *typeAlg    gcdata    *byte    str       nameOff    ptrToThis typeOff}</code></pre><p>其中 <code>alg</code> 字段就和哈希相关，它是指向如下结构体的指针：</p><pre class=" language-golang"><code class="language-golang">// src/runtime/alg.gotype typeAlg struct {    // (ptr to object, seed) -> hash    hash func(unsafe.Pointer, uintptr) uintptr    // (ptr to object A, ptr to object B) -> ==?    equal func(unsafe.Pointer, unsafe.Pointer) bool}</code></pre><p>typeAlg 包含两个函数，hash 函数计算类型的哈希值，而 equal 函数则计算两个类型是否“哈希相等”。</p><p>对于 string 类型，它的 hash、equal 函数如下：</p><pre class=" language-golang"><code class="language-golang">func strhash(a unsafe.Pointer, h uintptr) uintptr {    x := (*stringStruct)(a)    return memhash(x.str, h, uintptr(x.len))}func strequal(p, q unsafe.Pointer) bool {    return *(*string)(p) == *(*string)(q)}</code></pre><p>根据 key 的类型，_type 结构体的 alg 字段会被设置对应类型的 hash 和 equal 函数。</p><h2 id="key-定位过程"><a href="#key-定位过程" class="headerlink" title="key 定位过程"></a>key 定位过程</h2><p>key 经过哈希计算后得到哈希值，共 64 个 bit 位（64位机，32位机就不讨论了，现在主流都是64位机），计算它到底要落在哪个桶时，只会用到最后 B 个 bit 位。还记得前面提到过的 B 吗？如果 B = 5，那么桶的数量，也就是 buckets 数组的长度是 2^5 = 32。</p><p>例如，现在有一个 key 经过哈希函数计算后，得到的哈希结果是：</p><pre class=" language-shell"><code class="language-shell"> 10010111 | 000011110110110010001111001010100010010110010101010 │ 01010</code></pre><p>用最后的 5 个 bit 位，也就是 <code>01010</code>，值为 10，也就是 10 号桶。这个操作实际上就是取余操作，但是取余开销太大，所以代码实现上用的位操作代替。</p><p>再用哈希值的高 8 位，找到此 key 在 bucket 中的位置，这是在寻找已有的 key。最开始桶内还没有 key，新加入的 key 会找到第一个空位，放入。</p><p>buckets 编号就是桶编号，当两个不同的 key 落在同一个桶中，也就是发生了哈希冲突。冲突的解决手段是用链表法：在 bucket 中，从前往后找到第一个空位。这样，在查找某个 key 时，先找到对应的桶，再去遍历 bucket 中的 key。</p><p>这里参考曹大 github 博客里的一张图，原图是 ascii 图，geek 味十足，可以从参考资料找到曹大的博客，推荐大家去看看。</p><p><img src="https://user-images.githubusercontent.com/7698088/57577721-faf57580-74af-11e9-8826-aacdb34a1d2b.png" alt="mapacess"></p><p>上图中，假定 B = 5，所以 bucket 总数就是 2^5 = 32。首先计算出待查找 key 的哈希，使用低 5 位 <code>00110</code>，找到对应的 6 号 bucket，使用高 8 位 <code>10010111</code>，对应十进制 151，在 6 号 bucket 中寻找 tophash 值（HOB hash）为 151 的 key，找到了 2 号槽位，这样整个查找过程就结束了。</p><p>如果在 bucket 中没找到，并且 overflow 不为空，还要继续去 overflow bucket 中寻找，直到找到或是所有的 key 槽位都找遍了，包括所有的 overflow bucket。</p><p>我们来看下源码吧，哈哈！通过汇编语言可以看到，查找某个 key 的底层函数是 <code>mapacess</code> 系列函数，函数的作用类似，区别在下一节会讲到。这里我们直接看 <code>mapacess1</code> 函数：</p><pre class=" language-golang"><code class="language-golang">func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {    // ……    // 如果 h 什么都没有，返回零值    if h == nil || h.count == 0 {        return unsafe.Pointer(&zeroVal[0])    }    // 写和读冲突    if h.flags&hashWriting != 0 {        throw("concurrent map read and map write")    }    // 不同类型 key 使用的 hash 算法在编译期确定    alg := t.key.alg    // 计算哈希值，并且加入 hash0 引入随机性    hash := alg.hash(key, uintptr(h.hash0))    // 比如 B=5，那 m 就是31，二进制是全 1    // 求 bucket num 时，将 hash 与 m 相与，    // 达到 bucket num 由 hash 的低 8 位决定的效果    m := uintptr(1)<<h.B - 1    // b 就是 bucket 的地址    b := (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))    // oldbuckets 不为 nil，说明发生了扩容    if c := h.oldbuckets; c != nil {        // 如果不是同 size 扩容（看后面扩容的内容）        // 对应条件 1 的解决方案        if !h.sameSizeGrow() {            // 新 bucket 数量是老的 2 倍            m >>= 1        }        // 求出 key 在老的 map 中的 bucket 位置        oldb := (*bmap)(add(c, (hash&m)*uintptr(t.bucketsize)))        // 如果 oldb 没有搬迁到新的 bucket        // 那就在老的 bucket 中寻找        if !evacuated(oldb) {            b = oldb        }    }    // 计算出高 8 位的 hash    // 相当于右移 56 位，只取高8位    top := uint8(hash >> (sys.PtrSize*8 - 8))    // 增加一个 minTopHash    if top < minTopHash {        top += minTopHash    }    for {        // 遍历 8 个 bucket        for i := uintptr(0); i < bucketCnt; i++ {            // tophash 不匹配，继续            if b.tophash[i] != top {                continue            }            // tophash 匹配，定位到 key 的位置            k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))            // key 是指针            if t.indirectkey {                // 解引用                k = *((*unsafe.Pointer)(k))            }            // 如果 key 相等            if alg.equal(key, k) {                // 定位到 value 的位置                v := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))                // value 解引用                if t.indirectvalue {                    v = *((*unsafe.Pointer)(v))                }                return v            }        }        // bucket 找完（还没找到），继续到 overflow bucket 里找        b = b.overflow(t)        // overflow bucket 也找完了，说明没有目标 key        // 返回零值        if b == nil {            return unsafe.Pointer(&zeroVal[0])        }    }}</code></pre><p>函数返回 h[key] 的指针，如果 h 中没有此 key，那就会返回一个 key 相应类型的零值，不会返回 nil。</p><p>代码整体比较直接，没什么难懂的地方。跟着上面的注释一步步理解就好了。</p><p>这里，说一下定位 key 和 value 的方法以及整个循环的写法。</p><pre class=" language-golang"><code class="language-golang">// key 定位公式k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))// value 定位公式v := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))</code></pre><p>b 是 bmap 的地址，这里 bmap 还是源码里定义的结构体，只包含一个 tophash 数组，经编译器扩充之后的结构体才包含 key，value，overflow 这些字段。dataOffset 是 key 相对于 bmap 起始地址的偏移：</p><pre class=" language-golang"><code class="language-golang">dataOffset = unsafe.Offsetof(struct {        b bmap        v int64    }{}.v)</code></pre><p>因此 bucket 里 key 的起始地址就是 unsafe.Pointer(b)+dataOffset。第 i 个 key 的地址就要在此基础上跨过 i 个 key 的大小；而我们又知道，value 的地址是在所有 key 之后，因此第 i 个 value 的地址还需要加上所有 key 的偏移。理解了这些，上面 key 和 value 的定位公式就很好理解了。</p><p>再说整个大循环的写法，最外层是一个无限循环，通过 </p><pre class=" language-golang"><code class="language-golang">b = b.overflow(t)</code></pre><p>遍历所有的 bucket，这相当于是一个 bucket 链表。</p><p>当定位到一个具体的 bucket 时，里层循环就是遍历这个 bucket 里所有的 cell，或者说所有的槽位，也就是 bucketCnt=8 个槽位。整个循环过程：</p><p><img src="https://user-images.githubusercontent.com/7698088/57581783-fe5c2180-74ee-11e9-99c9-5a226216e1af.png" alt="mapacess loop"></p><p>再说一下 minTopHash，当一个 cell 的 tophash 值小于 minTopHash 时，标志这个 cell 的迁移状态。因为这个状态值是放在 tophash 数组里，为了和正常的哈希值区分开，会给 key 计算出来的哈希值一个增量：minTopHash。这样就能区分正常的 top hash 值和表示状态的哈希值。</p><p>下面的这几种状态就表征了 bucket 的情况：</p><pre class=" language-golang"><code class="language-golang">// 空的 cell，也是初始时 bucket 的状态empty          = 0// 空的 cell，表示 cell 已经被迁移到新的 bucketevacuatedEmpty = 1// key,value 已经搬迁完毕，但是 key 都在新 bucket 前半部分，// 后面扩容部分会再讲到。evacuatedX     = 2// 同上，key 在后半部分evacuatedY     = 3// tophash 的最小正常值minTopHash     = 4</code></pre><p>源码里判断这个 bucket 是否已经搬迁完毕，用到的函数：</p><pre class=" language-golang"><code class="language-golang">func evacuated(b *bmap) bool {    h := b.tophash[0]    return h > empty && h < minTopHash}</code></pre><p>只取了 tophash 数组的第一个值，判断它是否在 0-4 之间。对比上面的常量，当 top hash 是 <code>evacuatedEmpty</code>、<code>evacuatedX</code>、<code>evacuatedY</code> 这三个值之一，说明此 bucket 中的 key 全部被搬迁到了新 bucket。</p><h2 id="map-的两种-get-操作"><a href="#map-的两种-get-操作" class="headerlink" title="map 的两种 get 操作"></a>map 的两种 get 操作</h2><p>Go 语言中读取 map 有两种语法：带 comma 和 不带 comma。当要查询的 key 不在 map 里，带 comma 的用法会返回一个 bool 型变量提示 key 是否在 map 中；而不带 comma 的语句则会返回一个 value 类型的零值。如果 value 是 int 型就会返回 0，如果 value 是 string 类型，就会返回空字符串。</p><pre class=" language-golang"><code class="language-golang">package mainimport "fmt"func main() {    ageMap := make(map[string]int)    ageMap["qcrao"] = 18    // 不带 comma 用法    age1 := ageMap["stefno"]    fmt.Println(age1)    // 带 comma 用法    age2, ok := ageMap["stefno"]    fmt.Println(age2, ok)}</code></pre><p>运行结果：</p><pre class=" language-shell"><code class="language-shell">00 false</code></pre><p>以前一直觉得好神奇，怎么实现的？这其实是编译器在背后做的工作：分析代码后，将两种语法对应到底层两个不同的函数。</p><pre class=" language-golang"><code class="language-golang">// src/runtime/hashmap.gofunc mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointerfunc mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool)</code></pre><p>源码里，函数命名不拘小节，直接带上后缀 1，2，完全不理会《代码大全》里的那一套命名的做法。从上面两个函数的声明也可以看出差别了，<code>mapaccess2</code> 函数返回值多了一个 bool 型变量，两者的代码也是完全一样的，只是在返回值后面多加了一个 false 或者 true。</p><p>另外，根据 key 的不同类型，编译器还会将查找、插入、删除的函数用更具体的函数替换，以优化效率：</p><table><thead><tr><th>key 类型</th><th>查找</th></tr></thead><tbody><tr><td>uint32</td><td>mapaccess1_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer</td></tr><tr><td>uint32</td><td>mapaccess2_fast32(t *maptype, h *hmap, key uint32) (unsafe.Pointer, bool)</td></tr><tr><td>uint64</td><td>mapaccess1_fast64(t *maptype, h *hmap, key uint64) unsafe.Pointer</td></tr><tr><td>uint64</td><td>mapaccess2_fast64(t *maptype, h *hmap, key uint64) (unsafe.Pointer, bool)</td></tr><tr><td>string</td><td>mapaccess1_faststr(t *maptype, h *hmap, ky string) unsafe.Pointer</td></tr><tr><td>string</td><td>mapaccess2_faststr(t *maptype, h *hmap, ky string) (unsafe.Pointer, bool)</td></tr></tbody></table><p>这些函数的参数类型直接是具体的 uint32、unt64、string，在函数内部由于提前知晓了 key 的类型，所以内存布局是很清楚的，因此能节省很多操作，提高效率。</p><p>上面这些函数都是在文件 <code>src/runtime/hashmap_fast.go</code> 里。</p><h2 id="如何进行扩容"><a href="#如何进行扩容" class="headerlink" title="如何进行扩容"></a>如何进行扩容</h2><p>使用哈希表的目的就是要快速查找到目标 key，然而，随着向 map 中添加的 key 越来越多，key 发生碰撞的概率也越来越大。bucket 中的 8 个 cell 会被逐渐塞满，查找、插入、删除 key 的效率也会越来越低。最理想的情况是一个 bucket 只装一个 key，这样，就能达到 <code>O(1)</code> 的效率，但这样空间消耗太大，用空间换时间的代价太高。</p><p>Go 语言采用一个 bucket 里装载 8 个 key，定位到某个 bucket 后，还需要再定位到具体的 key，这实际上又用了时间换空间。</p><p>当然，这样做，要有一个度，不然所有的 key 都落在了同一个 bucket 里，直接退化成了链表，各种操作的效率直接降为 O(n)，是不行的。</p><p>因此，需要有一个指标来衡量前面描述的情况，这就是<code>装载因子</code>。Go 源码里这样定义 <code>装载因子</code>：</p><pre class=" language-golang"><code class="language-golang">loadFactor := count / (2^B)</code></pre><p>count 就是 map 的元素个数，2^B 表示 bucket 数量。</p><p>再来说触发 map 扩容的时机：在向 map 插入新 key 的时候，会进行条件检测，符合下面这 2 个条件，就会触发扩容：</p><ol><li>装载因子超过阈值，源码里定义的阈值是 6.5。</li><li>overflow 的 bucket 数量过多：当 B 小于 15，也就是 bucket 总数 2^B 小于 2^15 时，如果 overflow 的 bucket 数量超过 2^B；当 B &gt;= 15，也就是 bucket 总数 2^B 大于等于 2^15，如果 overflow 的 bucket 数量超过 2^15。</li></ol><p>通过汇编语言可以找到赋值操作对应源码中的函数是 <code>mapassign</code>，对应扩容条件的源码如下：</p><pre class=" language-golang"><code class="language-golang">// src/runtime/hashmap.go/mapassign// 触发扩容时机if !h.growing() && (overLoadFactor(int64(h.count), h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {        hashGrow(t, h)    }// 装载因子超过 6.5func overLoadFactor(count int64, B uint8) bool {    return count >= bucketCnt && float32(count) >= loadFactor*float32((uint64(1)<<B))}// overflow buckets 太多func tooManyOverflowBuckets(noverflow uint16, B uint8) bool {    if B < 16 {        return noverflow >= uint16(1)<<B    }    return noverflow >= 1<<15}</code></pre><p>解释一下：</p><p>第 1 点：我们知道，每个 bucket 有 8 个空位，在没有溢出，且所有的桶都装满了的情况下，装载因子算出来的结果是 8。因此当装载因子超过 6.5 时，表明很多 bucket 都快要装满了，查找效率和插入效率都变低了。在这个时候进行扩容是有必要的。</p><p>第 2 点：是对第 1 点的补充。就是说在装载因子比较小的情况下，这时候 map 的查找和插入效率也很低，而第 1 点识别不出来这种情况。表面现象就是计算装载因子的分子比较小，即 map 里元素总数少，但是 bucket 数量多（真实分配的 bucket 数量多，包括大量的 overflow bucket）。</p><p>不难想像造成这种情况的原因：不停地插入、删除元素。先插入很多元素，导致创建了很多 bucket，但是装载因子达不到第 1 点的临界值，未触发扩容来缓解这种情况。之后，删除元素降低元素总数量，再插入很多元素，导致创建很多的 overflow bucket，但就是不会触犯第 1 点的规定，你能拿我怎么办？overflow bucket 数量太多，导致 key 会很分散，查找插入效率低得吓人，因此出台第 2 点规定。这就像是一座空城，房子很多，但是住户很少，都分散了，找起人来很困难。</p><p>对于命中条件 1，2 的限制，都会发生扩容。但是扩容的策略并不相同，毕竟两种条件应对的场景不同。</p><p>对于条件 1，元素太多，而 bucket 数量太少，很简单：将 B 加 1，bucket 最大数量（2^B）直接变成原来 bucket 数量的 2 倍。于是，就有新老 bucket 了。注意，这时候元素都在老 bucket 里，还没迁移到新的 bucket 来。而且，新 bucket 只是最大数量变为原来最大数量（2^B）的 2 倍（2^B * 2）。</p><p>对于条件 2，其实元素没那么多，但是 overflow bucket 数特别多，说明很多 bucket 都没装满。解决办法就是开辟一个新 bucket 空间，将老 bucket 中的元素移动到新 bucket，使得同一个 bucket 中的 key 排列地更紧密。这样，原来，在 overflow bucket 中的 key 可以移动到 bucket 中来。结果是节省空间，提高 bucket 利用率，map 的查找和插入效率自然就会提升。</p><p>对于条件 2 的解决方案，曹大的博客里还提出了一个极端的情况：如果插入 map 的 key 哈希都一样，就会落到同一个 bucket 里，超过 8 个就会产生 overflow bucket，结果也会造成 overflow bucket 数过多。移动元素其实解决不了问题，因为这时整个哈希表已经退化成了一个链表，操作效率变成了 <code>O(n)</code>。</p><p>再来看一下扩容具体是怎么做的。由于 map 扩容需要将原有的 key/value 重新搬迁到新的内存地址，如果有大量的 key/value 需要搬迁，会非常影响性能。因此 Go map 的扩容采取了一种称为“渐进式”地方式，原有的 key 并不会一次性搬迁完毕，每次最多只会搬迁 2 个 bucket。</p><p>上面说的 <code>hashGrow()</code> 函数实际上并没有真正地“搬迁”，它只是分配好了新的 buckets，并将老的 buckets 挂到了 oldbuckets 字段上。真正搬迁 buckets 的动作在 <code>growWork()</code> 函数中，而调用 <code>growWork()</code> 函数的动作是在 mapassign 和 mapdelete 函数中。也就是插入或修改、删除 key 的时候，都会尝试进行搬迁 buckets 的工作。先检查 oldbuckets 是否搬迁完毕，具体来说就是检查 oldbuckets 是否为 nil。</p><p>我们先看 <code>hashGrow()</code> 函数所做的工作，再来看具体的搬迁 buckets 是如何进行的。</p><pre class=" language-golang"><code class="language-golang">func hashGrow(t *maptype, h *hmap) {    // B+1 相当于是原来 2 倍的空间    bigger := uint8(1)    // 对应条件 2    if !overLoadFactor(int64(h.count), h.B) {        // 进行等量的内存扩容，所以 B 不变        bigger = 0        h.flags |= sameSizeGrow    }    // 将老 buckets 挂到 buckets 上    oldbuckets := h.buckets    // 申请新的 buckets 空间    newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger)    flags := h.flags &^ (iterator | oldIterator)    if h.flags&iterator != 0 {        flags |= oldIterator    }    // 提交 grow 的动作    h.B += bigger    h.flags = flags    h.oldbuckets = oldbuckets    h.buckets = newbuckets    // 搬迁进度为 0    h.nevacuate = 0    // overflow buckets 数为 0    h.noverflow = 0    // ……}</code></pre><p>主要是申请到了新的 buckets 空间，把相关的标志位都进行了处理：例如标志 nevacuate 被置为 0， 表示当前搬迁进度为 0。</p><p>值得一说的是对 <code>h.flags</code> 的处理：</p><pre class=" language-golang"><code class="language-golang">flags := h.flags &^ (iterator | oldIterator)if h.flags&iterator != 0 {    flags |= oldIterator}</code></pre><p>这里得先说下运算符：&amp;^。这叫<code>按位置 0</code>运算符。例如：</p><pre class=" language-golang"><code class="language-golang">x = 01010011y = 01010100z = x &^ y = 00000011</code></pre><p>如果 y bit 位为 1，那么结果 z 对应 bit 位就为 0，否则 z 对应 bit 位就和 x 对应 bit 位的值相同。</p><p>所以上面那段对 flags 一顿操作的代码的意思是：先把 h.flags 中 iterator 和 oldIterator 对应位清 0，然后如果发现 iterator 位为 1，那就把它转接到 oldIterator 位，使得 oldIterator 标志位变成 1。潜台词就是：buckets 现在挂到了 oldBuckets 名下了，对应的标志位也转接过去吧。</p><p>几个标志位如下：</p><pre class=" language-golang"><code class="language-golang">// 可能有迭代器使用 bucketsiterator     = 1// 可能有迭代器使用 oldbucketsoldIterator  = 2// 有协程正在向 map 中写入 keyhashWriting  = 4// 等量扩容（对应条件 2）sameSizeGrow = 8</code></pre><p>再来看看真正执行搬迁工作的 growWork() 函数。</p><pre class=" language-golang"><code class="language-golang">func growWork(t *maptype, h *hmap, bucket uintptr) {    // 确认搬迁老的 bucket 对应正在使用的 bucket    evacuate(t, h, bucket&h.oldbucketmask())    // 再搬迁一个 bucket，以加快搬迁进程    if h.growing() {        evacuate(t, h, h.nevacuate)    }}</code></pre><p>h.growing() 函数非常简单：</p><pre class=" language-golang"><code class="language-golang">func (h *hmap) growing() bool {    return h.oldbuckets != nil}</code></pre><p>如果 <code>oldbuckets</code> 不为空，说明还没有搬迁完毕，还得继续搬。</p><p><code>bucket&amp;h.oldbucketmask()</code> 这行代码，如源码注释里说的，是为了确认搬迁的 bucket 是我们正在使用的 bucket。<code>oldbucketmask()</code> 函数返回扩容前的 map 的 bucketmask。</p><p>所谓的 bucketmask，作用就是将 key 计算出来的哈希值与 bucketmask 相与，得到的结果就是 key 应该落入的桶。比如 B = 5，那么 bucketmask 的低 5 位是 <code>11111</code>，其余位是 <code>0</code>，hash 值与其相与的意思是，只有 hash 值的低 5 位决策 key 到底落入哪个 bucket。</p><p>接下来，我们集中所有的精力在搬迁的关键函数 evacuate。源码贴在下面，不要紧张，我会加上大面积的注释，通过注释绝对是能看懂的。之后，我会再对搬迁过程作详细说明。</p><p>源码如下：</p><pre class=" language-golang"><code class="language-golang">func evacuate(t *maptype, h *hmap, oldbucket uintptr) {    // 定位老的 bucket 地址    b := (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize)))    // 结果是 2^B，如 B = 5，结果为32    newbit := h.noldbuckets()    // key 的哈希函数    alg := t.key.alg    // 如果 b 没有被搬迁过    if !evacuated(b) {        var (            // 表示bucket 移动的目标地址            x, y   *bmap            // 指向 x,y 中的 key/val            xi, yi int            // 指向 x，y 中的 key            xk, yk unsafe.Pointer            // 指向 x，y 中的 value            xv, yv unsafe.Pointer        )        // 默认是等 size 扩容，前后 bucket 序号不变        // 使用 x 来进行搬迁        x = (*bmap)(add(h.buckets, oldbucket*uintptr(t.bucketsize)))        xi = 0        xk = add(unsafe.Pointer(x), dataOffset)        xv = add(xk, bucketCnt*uintptr(t.keysize))、        // 如果不是等 size 扩容，前后 bucket 序号有变        // 使用 y 来进行搬迁        if !h.sameSizeGrow() {            // y 代表的 bucket 序号增加了 2^B            y = (*bmap)(add(h.buckets, (oldbucket+newbit)*uintptr(t.bucketsize)))            yi = 0            yk = add(unsafe.Pointer(y), dataOffset)            yv = add(yk, bucketCnt*uintptr(t.keysize))        }        // 遍历所有的 bucket，包括 overflow buckets        // b 是老的 bucket 地址        for ; b != nil; b = b.overflow(t) {            k := add(unsafe.Pointer(b), dataOffset)            v := add(k, bucketCnt*uintptr(t.keysize))            // 遍历 bucket 中的所有 cell            for i := 0; i < bucketCnt; i, k, v = i+1, add(k, uintptr(t.keysize)), add(v, uintptr(t.valuesize)) {                // 当前 cell 的 top hash 值                top := b.tophash[i]                // 如果 cell 为空，即没有 key                if top == empty {                    // 那就标志它被"搬迁"过                    b.tophash[i] = evacuatedEmpty                    // 继续下个 cell                    continue                }                // 正常不会出现这种情况                // 未被搬迁的 cell 只可能是 empty 或是                // 正常的 top hash（大于 minTopHash）                if top < minTopHash {                    throw("bad map state")                }                k2 := k                // 如果 key 是指针，则解引用                if t.indirectkey {                    k2 = *((*unsafe.Pointer)(k2))                }                // 默认使用 X，等量扩容                useX := true                // 如果不是等量扩容                if !h.sameSizeGrow() {                    // 计算 hash 值，和 key 第一次写入时一样                    hash := alg.hash(k2, uintptr(h.hash0))                    // 如果有协程正在遍历 map                    if h.flags&iterator != 0 {                        // 如果出现 相同的 key 值，算出来的 hash 值不同                        if !t.reflexivekey && !alg.equal(k2, k2) {                            // 只有在 float 变量的 NaN() 情况下会出现                            if top&1 != 0 {                                // 第 B 位置 1                                hash |= newbit                            } else {                                // 第 B 位置 0                                hash &^= newbit                            }                            // 取高 8 位作为 top hash 值                            top = uint8(hash >> (sys.PtrSize*8 - 8))                            if top < minTopHash {                                top += minTopHash                            }                        }                    }                    // 取决于新哈希值的 oldB+1 位是 0 还是 1                    // 详细看后面的文章                    useX = hash&newbit == 0                }                // 如果 key 搬到 X 部分                if useX {                    // 标志老的 cell 的 top hash 值，表示搬移到 X 部分                    b.tophash[i] = evacuatedX                    // 如果 xi 等于 8，说明要溢出了                    if xi == bucketCnt {                        // 新建一个 bucket                        newx := h.newoverflow(t, x)                        x = newx                        // xi 从 0 开始计数                        xi = 0                        // xk 表示 key 要移动到的位置                        xk = add(unsafe.Pointer(x), dataOffset)                        // xv 表示 value 要移动到的位置                        xv = add(xk, bucketCnt*uintptr(t.keysize))                    }                    // 设置 top hash 值                    x.tophash[xi] = top                    // key 是指针                    if t.indirectkey {                        // 将原 key（是指针）复制到新位置                        *(*unsafe.Pointer)(xk) = k2 // copy pointer                    } else {                        // 将原 key（是值）复制到新位置                        typedmemmove(t.key, xk, k) // copy value                    }                    // value 是指针，操作同 key                    if t.indirectvalue {                        *(*unsafe.Pointer)(xv) = *(*unsafe.Pointer)(v)                    } else {                        typedmemmove(t.elem, xv, v)                    }                    // 定位到下一个 cell                    xi++                    xk = add(xk, uintptr(t.keysize))                    xv = add(xv, uintptr(t.valuesize))                } else { // key 搬到 Y 部分，操作同 X 部分                    // ……                    // 省略了这部分，操作和 X 部分相同                }            }        }        // 如果没有协程在使用老的 buckets，就把老 buckets 清除掉，帮助gc        if h.flags&oldIterator == 0 {            b = (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize)))            // 只清除bucket 的 key,value 部分，保留 top hash 部分，指示搬迁状态            if t.bucket.kind&kindNoPointers == 0 {                memclrHasPointers(add(unsafe.Pointer(b), dataOffset), uintptr(t.bucketsize)-dataOffset)            } else {                memclrNoHeapPointers(add(unsafe.Pointer(b), dataOffset), uintptr(t.bucketsize)-dataOffset)            }        }    }    // 更新搬迁进度    // 如果此次搬迁的 bucket 等于当前进度    if oldbucket == h.nevacuate {        // 进度加 1        h.nevacuate = oldbucket + 1        // Experiments suggest that 1024 is overkill by at least an order of magnitude.        // Put it in there as a safeguard anyway, to ensure O(1) behavior.        // 尝试往后看 1024 个 bucket        stop := h.nevacuate + 1024        if stop > newbit {            stop = newbit        }        // 寻找没有搬迁的 bucket        for h.nevacuate != stop && bucketEvacuated(t, h, h.nevacuate) {            h.nevacuate++        }        // 现在 h.nevacuate 之前的 bucket 都被搬迁完毕        // 所有的 buckets 搬迁完毕        if h.nevacuate == newbit {            // 清除老的 buckets            h.oldbuckets = nil            // 清除老的 overflow bucket            // 回忆一下：[0] 表示当前 overflow bucket            // [1] 表示 old overflow bucket            if h.extra != nil {                h.extra.overflow[1] = nil            }            // 清除正在扩容的标志位            h.flags &^= sameSizeGrow        }    }}</code></pre><p>evacuate 函数的代码注释非常清晰，对着代码和注释是很容易看懂整个的搬迁过程的，耐心点。</p><p>搬迁的目的就是将老的 buckets 搬迁到新的 buckets。而通过前面的说明我们知道，应对条件 1，新的 buckets 数量是之前的一倍，应对条件 2，新的 buckets 数量和之前相等。</p><p>对于条件 1，从老的 buckets 搬迁到新的 buckets，由于 bucktes 数量不变，因此可以按序号来搬，比如原来在 0 号 bucktes，到新的地方后，仍然放在 0 号 buckets。</p><p>对于条件 2，就没这么简单了。要重新计算 key 的哈希，才能决定它到底落在哪个 bucket。例如，原来 B = 5，计算出 key 的哈希后，只用看它的低 5 位，就能决定它落在哪个 bucket。扩容后，B 变成了 6，因此需要多看一位，它的低 6 位决定 key 落在哪个 bucket。这称为 <code>rehash</code>。</p><p><img src="https://user-images.githubusercontent.com/7698088/57740474-af7adb80-76ea-11e9-8409-4af0ce1a814a.png" alt="map rehash"></p><p>因此，某个 key 在搬迁前后 bucket 序号可能和原来相等，也可能是相比原来加上 2^B（原来的 B 值），取决于 hash 值 第 6 bit 位是 0  还是 1。</p><p>理解了上面 bucket 序号的变化，我们就可以回答另一个问题了：为什么遍历 map 是无序的？</p><p>map 在扩容后，会发生 key 的搬迁，原来落在同一个 bucket 中的 key，搬迁后，有些 key 就要远走高飞了（bucket 序号加上了 2^B）。而遍历的过程，就是按顺序遍历 bucket，同时按顺序遍历 bucket 中的 key。搬迁后，key 的位置发生了重大的变化，有些 key 飞上高枝，有些 key 则原地不动。这样，遍历 map 的结果就不可能按原来的顺序了。</p><p>当然，如果我就一个 hard code 的 map，我也不会向 map 进行插入删除的操作，按理说每次遍历这样的 map 都会返回一个固定顺序的 key/value 序列吧。的确是这样，但是 Go 杜绝了这种做法，因为这样会给新手程序员带来误解，以为这是一定会发生的事情，在某些情况下，可能会酿成大错。</p><p>当然，Go 做得更绝，当我们在遍历 map 时，并不是固定地从 0 号 bucket 开始遍历，每次都是从一个随机值序号的 bucket 开始遍历，并且是从这个 bucket 的一个随机序号的 cell 开始遍历。这样，即使你是一个写死的 map，仅仅只是遍历它，也不太可能会返回一个固定序列的 key/value 对了。</p><p>多说一句，“迭代 map 的结果是无序的”这个特性是从 go 1.0 开始加入的。</p><p>再明确一个问题：如果扩容后，B 增加了 1，意味着 buckets 总数是原来的 2 倍，原来 1 号的桶“裂变”到两个桶。</p><p>例如，原始 B = 2，1号 bucket 中有 2 个 key 的哈希值低 3 位分别为：010，110。由于原来 B = 2，所以低 2 位 <code>10</code> 决定它们落在 2 号桶，现在 B 变成 3，所以 <code>010</code>、<code>110</code> 分别落入 2、6 号桶。</p><p><img src="https://user-images.githubusercontent.com/7698088/57818861-74df7480-77b8-11e9-8104-2a58dc006660.png" alt="bucket split"></p><p>理解了这个，后面讲 map 迭代的时候会用到。</p><p>再来讲搬迁函数中的几个关键点：</p><p>evacuate 函数每次只完成一个 bucket 的搬迁工作，因此要遍历完此 bucket 的所有的 cell，将有值的 cell copy 到新的地方。bucket 还会链接 overflow bucket，它们同样需要搬迁。因此会有 2 层循环，外层遍历 bucket 和 overflow bucket，内层遍历 bucket 的所有 cell。这样的循环在 map 的源码里到处都是，要理解透了。</p><p>源码里提到 X, Y part，其实就是我们说的如果是扩容到原来的 2 倍，桶的数量是原来的 2 倍，前一半桶被称为 X part，后一半桶被称为 Y part。一个 bucket 中的 key 可能会分裂落到 2 个桶，一个位于 X part，一个位于 Y part。所以在搬迁一个 cell 之前，需要知道这个 cell 中的 key 是落到哪个 Part。很简单，重新计算 cell 中 key 的 hash，并向前“多看”一位，决定落入哪个 Part，这个前面也说得很详细了。</p><p>有一个特殊情况是：有一种 key，每次对它计算 hash，得到的结果都不一样。这个 key 就是 <code>math.NaN()</code> 的结果，它的含义是 <code>not a number</code>，类型是 float64。当它作为 map 的 key，在搬迁的时候，会遇到一个问题：再次计算它的哈希值和它当初插入 map 时的计算出来的哈希值不一样！</p><p>你可能想到了，这样带来的一个后果是，这个 key 是永远不会被 Get 操作获取的！当我使用 <code>m[math.NaN()]</code> 语句的时候，是查不出来结果的。这个 key 只有在遍历整个 map 的时候，才有机会现身。所以，可以向一个 map 插入任意数量的 <code>math.NaN()</code> 作为 key。</p><p>当搬迁碰到 <code>math.NaN()</code> 的 key 时，只通过 tophash 的最低位决定分配到 X part 还是 Y part（如果扩容后是原来 buckets 数量的 2 倍）。如果 tophash 的最低位是 0 ，分配到 X part；如果是 1 ，则分配到 Y part。</p><p>这是通过 tophash 值与新算出来的哈希值进行运算得到的：</p><pre class=" language-golang"><code class="language-golang">if top&1 != 0 {    // top hash 最低位为 1    // 新算出来的 hash 值的 B 位置 1    hash |= newbit} else {    // 新算出来的 hash 值的 B 位置 0    hash &^= newbit}// hash 值的 B 位为 0，则搬迁到 x part// 当 B = 5时，newbit = 32，二进制低 6 位为 10 0000useX = hash&newbit == 0</code></pre><p>其实这样的 key 我随便搬迁到哪个 bucket 都行，当然，还是要搬迁到上面裂变那张图中的两个 bucket 中去。但这样做是有好处的，在后面讲 map 迭代的时候会再详细解释，暂时知道是这样分配的就行。</p><p>确定了要搬迁到的目标 bucket 后，搬迁操作就比较好进行了。将源 key/value 值 copy 到目的地相应的位置。</p><p>设置 key 在原始 buckets 的 tophash 为 <code>evacuatedX</code> 或是 <code>evacuatedY</code>，表示已经搬迁到了新 map 的 x part 或是 y part。新 map 的 tophash 则正常取 key 哈希值的高 8 位。</p><p>下面通过图来宏观地看一下扩容前后的变化。</p><p>扩容前，B = 2，共有 4 个 buckets，lowbits 表示 hash 值的低位。假设我们不关注其他 buckets 情况，专注在 2 号 bucket。并且假设 overflow 太多，触发了等量扩容（对应于前面的条件 2）。</p><p><img src="https://user-images.githubusercontent.com/7698088/57963483-5b286380-7957-11e9-852a-8296c6c16daa.png" alt="扩容前"></p><p>扩容完成后，overflow bucket 消失了，key 都集中到了一个 bucket，更为紧凑了，提高了查找的效率。</p><p><img src="https://user-images.githubusercontent.com/7698088/57963519-dc7ff600-7957-11e9-9877-36c3f4bc3526.png" alt="same size 扩容"></p><p>假设触发了 2 倍的扩容，那么扩容完成后，老 buckets 中的 key 分裂到了 2 个 新的 bucket。一个在 x part，一个在 y 的 part。依据是 hash 的 lowbits。新 map 中 <code>0-3</code> 称为 x part，<code>4-7</code> 称为 y part。</p><p><img src="https://user-images.githubusercontent.com/7698088/57963651-04705900-795a-11e9-9801-e3dc475d4782.png" alt="2倍扩容"></p><p>注意，上面的两张图忽略了其他 buckets 的搬迁情况，表示所有的 bucket 都搬迁完毕后的情形。实际上，我们知道，搬迁是一个“渐进”的过程，并不会一下子就全部搬迁完毕。所以在搬迁过程中，oldbuckets 指针还会指向原来老的 []bmap，并且已经搬迁完毕的 key 的 tophash 值会是一个状态值，表示 key 的搬迁去向。</p><h2 id="map-的遍历"><a href="#map-的遍历" class="headerlink" title="map 的遍历"></a>map 的遍历</h2><p>本来 map 的遍历过程比较简单：遍历所有的 bucket 以及它后面挂的 overflow bucket，然后挨个遍历 bucket 中的所有 cell。每个 bucket 中包含 8 个 cell，从有 key 的 cell 中取出 key 和 value，这个过程就完成了。</p><p>但是，现实并没有这么简单。还记得前面讲过的扩容过程吗？扩容过程不是一个原子的操作，它每次最多只搬运 2 个 bucket，所以如果触发了扩容操作，那么在很长时间里，map 的状态都是处于一个中间态：有些 bucket 已经搬迁到新家，而有些 bucket 还待在老地方。</p><p>因此，遍历如果发生在扩容的过程中，就会涉及到遍历新老 bucket 的过程，这是难点所在。</p><p>我先写一个简单的代码样例，假装不知道遍历过程具体调用的是什么函数：</p><pre class=" language-golang"><code class="language-golang">package mainimport "fmt"func main() {    ageMp := make(map[string]int)    ageMp["qcrao"] = 18    for name, age := range ageMp {        fmt.Println(name, age)    }}</code></pre><p>执行命令：</p><pre class=" language-shell"><code class="language-shell">go tool compile -S main.go</code></pre><p>得到汇编命令。这里就不逐行讲解了，可以去看之前的几篇文章，说得很详细。</p><p>关键的几行汇编代码如下：</p><pre class=" language-golang"><code class="language-golang">// ......0x0124 00292 (test16.go:9)      CALL    runtime.mapiterinit(SB)// ......0x01fb 00507 (test16.go:9)      CALL    runtime.mapiternext(SB)0x0200 00512 (test16.go:9)      MOVQ    ""..autotmp_4+160(SP), AX0x0208 00520 (test16.go:9)      TESTQ   AX, AX0x020b 00523 (test16.go:9)      JNE     302// ......</code></pre><p>这样，关于 map 迭代，底层的函数调用关系一目了然。先是调用 <code>mapiterinit</code> 函数初始化迭代器，然后循环调用 <code>mapiternext</code> 函数进行 map 迭代。</p><p><img src="https://user-images.githubusercontent.com/7698088/57976471-ad2ebf00-7a13-11e9-8dd8-d7be54f96440.png" alt="map iter loop"></p><p>迭代器的结构体定义：</p><pre class=" language-golang"><code class="language-golang">type hiter struct {    // key 指针    key         unsafe.Pointer    // value 指针    value       unsafe.Pointer    // map 类型，包含如 key size 大小等    t           *maptype    // map header    h           *hmap    // 初始化时指向的 bucket    buckets     unsafe.Pointer    // 当前遍历到的 bmap    bptr        *bmap    overflow    [2]*[]*bmap    // 起始遍历的 bucet 编号    startBucket uintptr    // 遍历开始时 cell 的编号（每个 bucket 中有 8 个 cell）    offset      uint8    // 是否从头遍历了    wrapped     bool    // B 的大小    B           uint8    // 指示当前 cell 序号    i           uint8    // 指向当前的 bucket    bucket      uintptr    // 因为扩容，需要检查的 bucket    checkBucket uintptr}</code></pre><p><code>mapiterinit</code> 就是对 hiter 结构体里的字段进行初始化赋值操作。</p><p>前面已经提到过，即使是对一个写死的 map 进行遍历，每次出来的结果也是无序的。下面我们就可以近距离地观察他们的实现了。</p><pre class=" language-golang"><code class="language-golang">// 生成随机数 rr := uintptr(fastrand())if h.B > 31-bucketCntBits {    r += uintptr(fastrand()) << 31}// 从哪个 bucket 开始遍历it.startBucket = r & (uintptr(1)<<h.B - 1)// 从 bucket 的哪个 cell 开始遍历it.offset = uint8(r >> h.B & (bucketCnt - 1))</code></pre><p>例如，B = 2，那 <code>uintptr(1)&lt;&lt;h.B - 1</code> 结果就是 3，低 8 位为 <code>0000 0011</code>，将 r 与之相与，就可以得到一个 <code>0~3</code> 的 bucket 序号；bucketCnt - 1 等于 7，低 8 位为 <code>0000 0111</code>，将 r 右移 2 位后，与 7 相与，就可以得到一个 <code>0~7</code> 号的 cell。</p><p>于是，在 <code>mapiternext</code> 函数中就会从 it.startBucket 的 it.offset 号的 cell 开始遍历，取出其中的 key 和 value，直到又回到起点 bucket，完成遍历过程。</p><p>源码部分比较好看懂，尤其是理解了前面注释的几段代码后，再看这部分代码就没什么压力了。所以，接下来，我将通过图形化的方式讲解整个遍历过程，希望能够清晰易懂。</p><p>假设我们有下图所示的一个 map，起始时 B = 1，有两个 bucket，后来触发了扩容（这里不要深究扩容条件，只是一个设定），B 变成 2。并且， 1 号 bucket 中的内容搬迁到了新的 bucket，<code>1 号</code>裂变成 <code>1 号</code>和 <code>3 号</code>；<code>0 号</code> bucket 暂未搬迁。老的 bucket 挂在在 <code>*oldbuckets</code> 指针上面，新的 bucket 则挂在 <code>*buckets</code> 指针上面。</p><p><img src="https://user-images.githubusercontent.com/7698088/57978113-f8a79400-7a38-11e9-8e27-3f3ba4fa557f.png" alt="map origin"></p><p>这时，我们对此 map 进行遍历。假设经过初始化后，startBucket = 3，offset = 2。于是，遍历的起点将是 3 号 bucket 的 2 号 cell，下面这张图就是开始遍历时的状态：</p><p><img src="https://user-images.githubusercontent.com/7698088/57980268-a4fa7200-7a5b-11e9-9ad1-fb2b64fe3159.png" alt="map init"></p><p>标红的表示起始位置，bucket 遍历顺序为：3 -&gt; 0 -&gt; 1 -&gt; 2。</p><p>因为 3 号 bucket 对应老的 1 号 bucket，因此先检查老 1 号 bucket 是否已经被搬迁过。判断方法就是：</p><pre class=" language-golang"><code class="language-golang">func evacuated(b *bmap) bool {    h := b.tophash[0]    return h > empty && h < minTopHash}</code></pre><p>如果 b.tophash[0] 的值在标志值范围内，即在 (0,4) 区间里，说明已经被搬迁过了。</p><pre class=" language-golang"><code class="language-golang">empty = 0evacuatedEmpty = 1evacuatedX = 2evacuatedY = 3minTopHash = 4</code></pre><p>在本例中，老 1 号 bucket 已经被搬迁过了。所以它的 tophash[0] 值在 (0,4) 范围内，因此只用遍历新的 3 号 bucket。</p><p>依次遍历 3 号 bucket 的 cell，这时候会找到第一个非空的 key：元素 e。到这里，mapiternext 函数返回，这时我们的遍历结果仅有一个元素：</p><p><img src="https://user-images.githubusercontent.com/7698088/57980302-56010c80-7a5c-11e9-8263-c11ddcec2ecc.png" alt="iter res"></p><p>由于返回的 key 不为空，所以会继续调用 mapiternext 函数。</p><p>继续从上次遍历到的地方往后遍历，从新 3 号 overflow bucket 中找到了元素 f 和 元素 g。</p><p>遍历结果集也因此壮大：</p><p><img src="https://user-images.githubusercontent.com/7698088/57980349-2d2d4700-7a5d-11e9-819a-a59964f70a7c.png" alt="iter res"></p><p>新 3 号 bucket 遍历完之后，回到了新 0 号 bucket。0 号 bucket 对应老的 0 号 bucket，经检查，老 0 号 bucket 并未搬迁，因此对新 0 号 bucket 的遍历就改为遍历老 0 号 bucket。那是不是把老 0 号 bucket 中的所有 key 都取出来呢？</p><p>并没有这么简单，回忆一下，老 0 号 bucket 在搬迁后将裂变成 2 个 bucket：新 0 号、新 2 号。而我们此时正在遍历的只是新 0 号 bucket（注意，遍历都是遍历的 <code>*bucket</code> 指针，也就是所谓的新 buckets）。所以，我们只会取出老 0 号 bucket 中那些在裂变之后，分配到新 0 号 bucket 中的那些 key。</p><p>因此，<code>lowbits == 00</code> 的将进入遍历结果集：</p><p><img src="https://user-images.githubusercontent.com/7698088/57980449-6fa35380-7a5e-11e9-9dbf-86332ea0e215.png" alt="iter res"></p><p>和之前的流程一样，继续遍历新 1 号 bucket，发现老 1 号 bucket 已经搬迁，只用遍历新 1 号 bucket 中现有的元素就可以了。结果集变成：</p><p><img src="https://user-images.githubusercontent.com/7698088/57980487-e8a2ab00-7a5e-11e9-8e47-050437a099fc.png" alt="iter res"></p><p>继续遍历新 2 号 bucket，它来自老 0 号 bucket，因此需要在老 0 号 bucket 中那些会裂变到新 2 号 bucket 中的 key，也就是 <code>lowbit == 10</code> 的那些 key。</p><p>这样，遍历结果集变成：</p><p><img src="https://user-images.githubusercontent.com/7698088/57980574-ae85d900-7a5f-11e9-8050-ae314a90ee05.png" alt="iter res"></p><p>最后，继续遍历到新 3 号 bucket 时，发现所有的 bucket 都已经遍历完毕，整个迭代过程执行完毕。</p><p>顺便说一下，如果碰到 key 是 <code>math.NaN()</code> 这种的，处理方式类似。核心还是要看它被分裂后具体落入哪个 bucket。只不过只用看它 top hash 的最低位。如果 top hash 的最低位是 0 ，分配到 X part；如果是 1 ，则分配到 Y part。据此决定是否取出 key，放到遍历结果集里。</p><p>map 遍历的核心在于理解 2 倍扩容时，老 bucket 会分裂到 2 个新 bucket 中去。而遍历操作，会按照新 bucket 的序号顺序进行，碰到老 bucket 未搬迁的情况时，要在老 bucket 中找到将来要搬迁到新 bucket 来的 key。</p><h2 id="map-的赋值"><a href="#map-的赋值" class="headerlink" title="map 的赋值"></a>map 的赋值</h2><p>通过汇编语言可以看到，向 map 中插入或者修改 key，最终调用的是 <code>mapassign</code> 函数。</p><p>实际上插入或修改 key 的语法是一样的，只不过前者操作的 key 在 map 中不存在，而后者操作的 key 存在 map 中。</p><p>mapassign 有一个系列的函数，根据 key 类型的不同，编译器会将其优化为相应的“快速函数”。</p><table><thead><tr><th>key 类型</th><th>插入</th></tr></thead><tbody><tr><td>uint32</td><td>mapassign_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer</td></tr><tr><td>uint64</td><td>mapassign_fast64(t *maptype, h *hmap, key uint64) unsafe.Pointer</td></tr><tr><td>string</td><td>mapassign_faststr(t *maptype, h *hmap, ky string) unsafe.Pointer</td></tr></tbody></table><p>我们只用研究最一般的赋值函数 <code>mapassign</code>。</p><p>整体来看，流程非常得简单：对 key 计算 hash 值，根据 hash 值按照之前的流程，找到要赋值的位置（可能是插入新 key，也可能是更新老 key），对相应位置进行赋值。</p><p>源码大体和之前讲的类似，核心还是一个双层循环，外层遍历 bucket 和它的 overflow bucket，内层遍历整个 bucket 的各个 cell。限于篇幅，这部分代码的注释我也不展示了，有兴趣的可以去看，保证理解了这篇文章内容后，能够看懂。</p><p>我这里会针对这个过程提几点重要的。</p><p>函数首先会检查 map 的标志位 flags。如果 flags 的写标志位此时被置 1 了，说明有其他协程在执行“写”操作，进而导致程序 panic。这也说明了 map 对协程是不安全的。</p><p>通过前文我们知道扩容是渐进式的，如果 map 处在扩容的过程中，那么当 key 定位到了某个 bucket 后，需要确保这个 bucket 对应的老 bucket 完成了迁移过程。即老 bucket 里的 key 都要迁移到新的 bucket 中来（分裂到 2 个新 bucket），才能在新的 bucket 中进行插入或者更新的操作。</p><p>上面说的操作是在函数靠前的位置进行的，只有进行完了这个搬迁操作后，我们才能放心地在新 bucket 里定位 key 要安置的地址，再进行之后的操作。</p><p>现在到了定位 key 应该放置的位置了，所谓找准自己的位置很重要。准备两个指针，一个（<code>inserti</code>）指向 key 的 hash 值在 tophash 数组所处的位置，另一个(<code>insertk</code>)指向 cell 的位置（也就是 key 最终放置的地址），当然，对应 value 的位置就很容易定位出来了。这三者实际上都是关联的，在 tophash 数组中的索引位置决定了 key 在整个 bucket 中的位置（共 8 个 key），而 value 的位置需要“跨过” 8 个 key 的长度。</p><p>在循环的过程中，inserti 和 insertk 分别指向第一个找到的空闲的 cell。如果之后在 map 没有找到 key 的存在，也就是说原来 map 中没有此 key，这意味着插入新 key。那最终 key 的安置地址就是第一次发现的“空位”（tophash 是 empty）。</p><p>如果这个 bucket 的 8 个 key 都已经放置满了，那在跳出循环后，发现 inserti 和 insertk 都是空，这时候需要在 bucket 后面挂上 overflow bucket。当然，也有可能是在 overflow bucket 后面再挂上一个 overflow bucket。这就说明，太多 key hash 到了此 bucket。</p><p>在正式安置 key 之前，还要检查 map 的状态，看它是否需要进行扩容。如果满足扩容的条件，就主动触发一次扩容操作。</p><p>这之后，整个之前的查找定位 key 的过程，还得再重新走一次。因为扩容之后，key 的分布都发生了变化。</p><p>最后，会更新 map 相关的值，如果是插入新 key，map 的元素数量字段 count 值会加 1；在函数之初设置的 <code>hashWriting</code> 写标志出会清零。</p><p>另外，有一个重要的点要说一下。前面说的找到 key 的位置，进行赋值操作，实际上并不准确。我们看 <code>mapassign</code> 函数的原型就知道，函数并没有传入 value 值，所以赋值操作是什么时候执行的呢？</p><pre class=" language-golang"><code class="language-golang">func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer</code></pre><p>答案还得从汇编语言中寻找。我直接揭晓答案，有兴趣可以私下去研究一下。<code>mapassign</code> 函数返回的指针就是指向的 key 所对应的 value 值位置，有了地址，就很好操作赋值了。</p><h2 id="map-的删除"><a href="#map-的删除" class="headerlink" title="map 的删除"></a>map 的删除</h2><p>写操作底层的执行函数是 <code>mapdelete</code>：</p><pre class=" language-golang"><code class="language-golang">func mapdelete(t *maptype, h *hmap, key unsafe.Pointer) </code></pre><p>根据 key 类型的不同，删除操作会被优化成更具体的函数：</p><table><thead><tr><th>key 类型</th><th>删除</th></tr></thead><tbody><tr><td>uint32</td><td>mapdelete_fast32(t *maptype, h *hmap, key uint32)</td></tr><tr><td>uint64</td><td>mapdelete_fast64(t *maptype, h *hmap, key uint64)</td></tr><tr><td>string</td><td>mapdelete_faststr(t *maptype, h *hmap, ky string)</td></tr></tbody></table><p>当然，我们只关心 <code>mapdelete</code> 函数。它首先会检查 h.flags 标志，如果发现写标位是 1，直接 panic，因为这表明有其他协程同时在进行写操作。</p><p>计算 key 的哈希，找到落入的 bucket。检查此 map 如果正在扩容的过程中，直接触发一次搬迁操作。</p><p>删除操作同样是两层循环，核心还是找到 key 的具体位置。寻找过程都是类似的，在 bucket 中挨个 cell 寻找。</p><p>找到对应位置后，对 key 或者 value 进行“清零”操作：</p><pre class=" language-golang"><code class="language-golang">// 对 key 清零if t.indirectkey {    *(*unsafe.Pointer)(k) = nil} else {    typedmemclr(t.key, k)}// 对 value 清零if t.indirectvalue {    *(*unsafe.Pointer)(v) = nil} else {    typedmemclr(t.elem, v)}</code></pre><p>最后，将 count 值减 1，将对应位置的 tophash 值置成 <code>Empty</code>。</p><p>这块源码同样比较简单，感兴起直接去看代码。</p><h1 id="map-进阶"><a href="#map-进阶" class="headerlink" title="map 进阶"></a>map 进阶</h1><h2 id="可以边遍历边删除吗"><a href="#可以边遍历边删除吗" class="headerlink" title="可以边遍历边删除吗"></a>可以边遍历边删除吗</h2><p>map 并不是一个线程安全的数据结构。同时读写一个 map 是未定义的行为，如果被检测到，会直接 panic。</p><p>一般而言，这可以通过读写锁来解决：<code>sync.RWMutex</code>。</p><p>读之前调用 <code>RLock()</code> 函数，读完之后调用 <code>RUnlock()</code> 函数解锁；写之前调用 <code>Lock()</code> 函数，写完之后，调用 <code>Unlock()</code> 解锁。</p><p>另外，<code>sync.Map</code> 是线程安全的 map，也可以使用。它的实现原理，这次先不说了。</p><h2 id="key-可以是-float-型吗？"><a href="#key-可以是-float-型吗？" class="headerlink" title="key 可以是 float 型吗？"></a>key 可以是 float 型吗？</h2><p>从语法上看，是可以的。Go 语言中只要是可比较的类型都可以作为 key。除开 slice，map，functions 这几种类型，其他类型都是 OK 的。具体包括：布尔值、数字、字符串、指针、通道、接口类型、结构体、只包含上述类型的数组。这些类型的共同特征是支持 <code>==</code> 和 <code>!=</code> 操作符，<code>k1 == k2</code> 时，可认为 k1 和 k2 是同一个 key。如果是结构体，则需要它们的字段值都相等，才被认为是相同的 key。</p><p>顺便说一句，任何类型都可以作为 value，包括 map 类型。</p><p>来看个例子：</p><pre class=" language-golang"><code class="language-golang">func main() {    m := make(map[float64]int)    m[1.4] = 1    m[2.4] = 2    m[math.NaN()] = 3    m[math.NaN()] = 3    for k, v := range m {        fmt.Printf("[%v, %d] ", k, v)    }    fmt.Printf("\nk: %v, v: %d\n", math.NaN(), m[math.NaN()])    fmt.Printf("k: %v, v: %d\n", 2.400000000001, m[2.400000000001])    fmt.Printf("k: %v, v: %d\n", 2.4000000000000000000000001, m[2.4000000000000000000000001])    fmt.Println(math.NaN() == math.NaN())}</code></pre><p>程序的输出：</p><pre class=" language-shell"><code class="language-shell">[2.4, 2] [NaN, 3] [NaN, 3] [1.4, 1] k: NaN, v: 0k: 2.400000000001, v: 0k: 2.4, v: 2false</code></pre><p>例子中定义了一个 key 类型是 float 型的 map，并向其中插入了 4 个 key：1.4， 2.4， NAN，NAN。</p><p>打印的时候也打印出了 4 个 key，如果你知道 NAN != NAN，也就不奇怪了。因为他们比较的结果不相等，自然，在 map 看来就是两个不同的 key 了。</p><p>接着，我们查询了几个 key，发现 NAN 不存在，2.400000000001 也不存在，而 2.4000000000000000000000001 却存在。</p><p>有点诡异，不是吗？</p><p>接着，我通过汇编发现了如下的事实：</p><p>当用 float64 作为 key 的时候，先要将其转成 unit64 类型，再插入 key 中。</p><p>具体是通过 <code>Float64frombits</code> 函数完成：</p><pre class=" language-golang"><code class="language-golang">// Float64frombits returns the floating point number corresponding// the IEEE 754 binary representation b.func Float64frombits(b uint64) float64 { return *(*float64)(unsafe.Pointer(&b)) }</code></pre><p>也就是将浮点数表示成 IEEE 754 规定的格式。如赋值语句：</p><pre class=" language-asm"><code class="language-asm">0x00bd 00189 (test18.go:9)      LEAQ    "".statictmp_0(SB), DX0x00c4 00196 (test18.go:9)      MOVQ    DX, 16(SP)0x00c9 00201 (test18.go:9)      PCDATA  $0, $20x00c9 00201 (test18.go:9)      CALL    runtime.mapassign(SB)</code></pre><p><code>&quot;&quot;.statictmp_0(SB)</code> 变量是这样的：</p><pre class=" language-asm"><code class="language-asm">"".statictmp_0 SRODATA size=8        0x0000 33 33 33 33 33 33 03 40"".statictmp_1 SRODATA size=8        0x0000 ff 3b 33 33 33 33 03 40"".statictmp_2 SRODATA size=8        0x0000 33 33 33 33 33 33 03 40</code></pre><p>我们再来输出点东西：</p><pre class=" language-golang"><code class="language-golang">package mainimport (    "fmt"    "math")func main() {    m := make(map[float64]int)    m[2.4] = 2    fmt.Println(math.Float64bits(2.4))    fmt.Println(math.Float64bits(2.400000000001))    fmt.Println(math.Float64bits(2.4000000000000000000000001))}</code></pre><pre class=" language-shell"><code class="language-shell">461258673835286425546125867383528620034612586738352862003</code></pre><p>转成十六进制为：</p><pre class=" language-shell"><code class="language-shell">0x40033333333333330x4003333333333BFF0x4003333333333333</code></pre><p>和前面的 <code>&quot;&quot;.statictmp_0</code> 比较一下，很清晰了吧。<code>2.4</code> 和 <code>2.4000000000000000000000001</code> 经过 <code>math.Float64bits()</code> 函数转换后的结果是一样的。自然，二者在 map 看来，就是同一个 key 了。</p><p>再来看一下 NAN（not a number）：</p><pre class=" language-golang"><code class="language-golang">// NaN returns an IEEE 754 ``not-a-number'' value.func NaN() float64 { return Float64frombits(uvnan) }</code></pre><p>uvan 的定义为：</p><pre class=" language-golang"><code class="language-golang">uvnan    = 0x7FF8000000000001</code></pre><p>NAN() 直接调用 <code>Float64frombits</code>，传入写死的 const 型变量 <code>0x7FF8000000000001</code>，得到 NAN 型值。既然，NAN 是从一个常量解析得来的，为什么插入 map 时，会被认为是不同的 key？</p><p>这是由类型的哈希函数决定的，例如，对于 64 位的浮点数，它的哈希函数如下：</p><pre class=" language-golang"><code class="language-golang">func f64hash(p unsafe.Pointer, h uintptr) uintptr {    f := *(*float64)(p)    switch {    case f == 0:        return c1 * (c0 ^ h) // +0, -0    case f != f:        return c1 * (c0 ^ h ^ uintptr(fastrand())) // any kind of NaN    default:        return memhash(p, h, 8)    }}</code></pre><p>第二个 case，<code>f != f</code> 就是针对 <code>NAN</code>，这里会再加一个随机数。</p><p>这样，所有的谜题都解开了。</p><p>由于 NAN 的特性：</p><pre class=" language-shell"><code class="language-shell">NAN != NANhash(NAN) != hash(NAN)</code></pre><p>因此向 map 中查找的 key 为 NAN 时，什么也查不到；如果向其中增加了 4 次 NAN，遍历会得到 4 个 NAN。</p><p>最后说结论：float 型可以作为 key，但是由于精度的问题，会导致一些诡异的问题，慎用之。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在写作本文时，有些问题看遍了中文世界的博客都没能找到解答。当然，源码可以解答任何问题。但是，你不能一下子跳进源码的细节，你得先有一个整体的认识才好。</p><p>所以，我开始搜索英文相关讲源码的文章，没有太多这方面的。但是我发现了一篇质量很高的文章，放在了参考资料第一条，它带领读者一步步优化，最终实现了从 map 中随机取出一个 key。推荐你去阅读，非常精彩。尤其是你知道了 map 的底层遍历、扩容的具体过程后更是如此。</p><p>总结一下，Go 语言中，通过哈希查找表实现 map，用链表法解决哈希冲突。</p><p>通过 key 的哈希值将 key 散落到不同的桶中，每个桶中有 8 个 cell。哈希值的低位决定桶序号，高位标识同一个桶中的不同 key。</p><p>当向桶中添加了很多 key，造成元素过多，或者溢出桶太多，就会触发扩容。扩容分为等量扩容和 2 倍容量扩容。扩容后，原来一个 bucket 中的 key 一分为二，会被重新分配到两个桶中。</p><p>扩容过程是渐进的，主要是防止一次扩容需要搬迁的 key 数量过多，引发性能问题。触发扩容的时机是增加了新元素，bucket 搬迁的时机则发生在赋值、删除期间，每次最多搬迁两个 bucket。</p><p>查找、赋值、删除的一个很核心的内容是如何定位到 key 所在的位置，需要重点理解。一旦理解，关于 map 的源码就可以看懂了。</p><p>最后，如果文章对你有帮助，恳请你帮我分享一下，或者点一下在看，谢谢！</p><p>最后的最后，点击<a href="https://github.com/qcrao/Go-Questions">阅读原文</a>，你可能会参与见证一个从零开始的千星项目。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【english 如何实现随机取一个map的key，非常精彩】<a href="https://lukechampine.com/hackmap.html" target="_blank" rel="noopener">https://lukechampine.com/hackmap.html</a></p><p>【map 的维基百科】<a href="https://en.wikipedia.org/wiki/Associative_array" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Associative_array</a></p><p>【sync.map 源码分析】<a href="https://github.com/Chasiny/Blog/blob/master/blog/go/sync.Map%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md">https://github.com/Chasiny/Blog/blob/master/blog/go/sync.Map%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md</a></p><p>【各种 map 相关操作的流程图】<a href="https://www.jianshu.com/p/aa0d4808cbb8" target="_blank" rel="noopener">https://www.jianshu.com/p/aa0d4808cbb8</a></p><p>【map 源码分析】<a href="https://www.twblogs.net/a/5bd78d5d2b71777ac86b541f" target="_blank" rel="noopener">https://www.twblogs.net/a/5bd78d5d2b71777ac86b541f</a></p><p>【曹大关于map的文章 不用解释】<a href="https://github.com/cch123/golang-notes/blob/master/map.md">https://github.com/cch123/golang-notes/blob/master/map.md</a></p><p>【english 有图】<a href="https://www.ardanlabs.com/blog/2013/12/macro-view-of-map-internals-in-go.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2013/12/macro-view-of-map-internals-in-go.html</a></p><p>【english 对比了 java, c++ 的 map 实现】<a href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics" target="_blank" rel="noopener">https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics</a></p><p>【english 为什么 go map 对竞争敏感】<a href="https://dave.cheney.net/2015/12/07/are-go-maps-sensitive-to-data-races" target="_blank" rel="noopener">https://dave.cheney.net/2015/12/07/are-go-maps-sensitive-to-data-races</a></p><p>【golang blog map】<a href="https://blog.golang.org/go-maps-in-action" target="_blank" rel="noopener">https://blog.golang.org/go-maps-in-action</a></p><p>【randommap 开源代码】<a href="https://github.com/lukechampine/randmap">https://github.com/lukechampine/randmap</a></p><p>【图不错】<a href="https://hacpai.com/article/1533916370874" target="_blank" rel="noopener">https://hacpai.com/article/1533916370874</a></p><p>【夜读issue】<a href="https://github.com/developer-learning/reading-go/issues/332">https://github.com/developer-learning/reading-go/issues/332</a></p><p>【新发现的博客，很有深度】<a href="https://draveness.me/golang-hashmap" target="_blank" rel="noopener">https://draveness.me/golang-hashmap</a></p><p>【扩容过程+图】<a href="https://my.oschina.net/renhc/blog/2208417" target="_blank" rel="noopener">https://my.oschina.net/renhc/blog/2208417</a></p><p>【运算符】<a href="https://juejin.im/post/5c0e572fe51d4522ad6e59d5" target="_blank" rel="noopener">https://juejin.im/post/5c0e572fe51d4522ad6e59d5</a></p><p>【english】<a href="https://www.digitalocean.com/community/tutorials/understanding-maps-in-go" target="_blank" rel="noopener">https://www.digitalocean.com/community/tutorials/understanding-maps-in-go</a></p><p>【map 遍历 源码简单阐述】<a href="https://gocn.vip/article/1704" target="_blank" rel="noopener">https://gocn.vip/article/1704</a></p><p>【短文，同时遍历、删除key是可以的】<a href="https://cloud.tencent.com/developer/article/1065474" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1065474</a></p><p>【面向信仰编程，golang range】<a href="https://draveness.me/golang-for-range" target="_blank" rel="noopener">https://draveness.me/golang-for-range</a></p><p>【slice 和 map 作为参数的区别】<a href="https://stackoverflow.com/questions/47590444/slice-vs-map-to-be-used-in-parameter/47590531#47590531" target="_blank" rel="noopener">https://stackoverflow.com/questions/47590444/slice-vs-map-to-be-used-in-parameter/47590531#47590531</a></p><p>【Go官方博客关于 map】<a href="https://blog.golang.org/go-maps-in-action" target="_blank" rel="noopener">https://blog.golang.org/go-maps-in-action</a></p><p>【Go 语言可比较类型】<a href="https://golang.org/ref/spec#Comparison_operators" target="_blank" rel="noopener">https://golang.org/ref/spec#Comparison_operators</a></p><p>【key 类型】<a href="http://lanlingzi.cn/post/technical/2016/0904_go_map/" target="_blank" rel="noopener">http://lanlingzi.cn/post/technical/2016/0904_go_map/</a></p><p>【哈希函数性能比较】<a href="http://aras-p.info/blog/2016/08/09/More-Hash-Function-Tests/" target="_blank" rel="noopener">http://aras-p.info/blog/2016/08/09/More-Hash-Function-Tests/</a></p><p>【哈希函数选择，C++/Java 对比】<a href="https://studygolang.com/articles/15839" target="_blank" rel="noopener">https://studygolang.com/articles/15839</a></p><p>【slice 和 map 作为函数参数】<a href="https://stackoverflow.com/questions/47590444/slice-vs-map-to-be-used-in-parameter/47590531#47590531" target="_blank" rel="noopener">https://stackoverflow.com/questions/47590444/slice-vs-map-to-be-used-in-parameter/47590531#47590531</a></p><p>【煎鱼大佬博客 map1】<a href="https://github.com/EDDYCJY/blog/blob/master/golang/pkg/2019-03-04-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go-map-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0.md">https://github.com/EDDYCJY/blog/blob/master/golang/pkg/2019-03-04-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go-map-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0.md</a></p><p>【煎鱼大佬博客 map2】<a href="https://github.com/EDDYCJY/blog/blob/master/golang/pkg/2019-03-24-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go-map-%E8%B5%8B%E5%80%BC%E5%92%8C%E6%89%A9%E5%AE%B9%E8%BF%81%E7%A7%BB.md">https://github.com/EDDYCJY/blog/blob/master/golang/pkg/2019-03-24-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go-map-%E8%B5%8B%E5%80%BC%E5%92%8C%E6%89%A9%E5%AE%B9%E8%BF%81%E7%A7%BB.md</a></p><p>【哈希函数的定义】<a href="http://zhangshuai.ren/2018/05/16/%E6%95%A3%E5%88%97%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0Go%E8%AF%AD%E8%A8%80Map%E5%87%BD%E6%95%B0/" target="_blank" rel="noopener">http://zhangshuai.ren/2018/05/16/%E6%95%A3%E5%88%97%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0Go%E8%AF%AD%E8%A8%80Map%E5%87%BD%E6%95%B0/</a></p><p>【如何比较两个 map 相等】<a href="https://golangbot.com/maps/" target="_blank" rel="noopener">https://golangbot.com/maps/</a></p><p>【NAN hash】<a href="https://research.swtch.com/randhash" target="_blank" rel="noopener">https://research.swtch.com/randhash</a></p><p>【并发安全阐述】<a href="http://zjykzk.github.io/post/cs/golang/map/" target="_blank" rel="noopener">http://zjykzk.github.io/post/cs/golang/map/</a></p><p><img src="https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png" alt="QR"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇文章主要讲 map 的赋值、删除、查询、扩容的具体执行过程，仍然是从底层的角度展开。结合源码，看完本文一定会彻底明白 map 底层原理。&lt;/p&gt;
&lt;p&gt;我要说明的是，这里对 map 的基本用法涉及比较少，我相信可以通过阅读其他入门书籍了解。本文的内容比较深入，但是由于我
      
    
    </summary>
    
      <category term="编程语言" scheme="https://github.com/qcrao/qcrao.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="golang" scheme="https://github.com/qcrao/qcrao.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>深度解密Go语言之反射</title>
    <link href="https://github.com/qcrao/qcrao.github.io/2019/05/07/dive-into-go-reflection/"/>
    <id>https://github.com/qcrao/qcrao.github.io/2019/05/07/dive-into-go-reflection/</id>
    <published>2019-05-07T00:35:00.000Z</published>
    <updated>2019-07-24T14:09:18.477Z</updated>
    
    <content type="html"><![CDATA[<p>反射和 Interface 息息相关，而 Interface 是我们<a href="https://mp.weixin.qq.com/s/EbxkBokYBajkCR-MazL0ZA" target="_blank" rel="noopener">上一篇文章</a>的内容。在开始正文前，和大家说点题外话。</p><p>上一篇关于 Interface 的文章发出后，获得了很多的关注和阅读。比如，登上了 GoCN 的每日新闻第一条：</p><p><img src="https://user-images.githubusercontent.com/7698088/57132448-3c13c880-6dd2-11e9-91b0-4d6b846a605e.png" alt="gocn"></p><p>可能是编辑者觉得这篇文章称不上“深度解密”，把标题给小小地改动了下，哈哈~~</p><p>在博客园登上了 48 小时阅读排行榜：</p><p><img src="https://user-images.githubusercontent.com/7698088/57132468-4a61e480-6dd2-11e9-953c-a981ed048dae.png" alt="博客园"></p><p>在开发者头条 APP （类似于今日头条，不过内容都是技术相关的，还挺有意思的）上收获了 150 收藏，并被推荐到首页最显眼的 banner 位置，阅读量达到了 1w 多，只是不知道这个数字是否是真实的，有点难以相信。</p><p><img src="https://user-images.githubusercontent.com/7698088/57132395-0e2e8400-6dd2-11e9-88e7-f71605c3bb66.png" alt="开发者头条"></p><p>很多同学在后台向我反映文章太长了，不利于阅读，建议拆分一下。我非常理解，读屏时代，大家需要快速地读完全文，拿到收益。而码农桃花源的文章都非常长，读者很难在短时间内读完，并且获得相应的收益。</p><p>首先非常感谢大家的建议！其实我的想法是这样的：大家都在说，现在是一个信息严重过载的时代，信息多得看不完，不免产生很多焦虑。但是，我想说，优质的信息真有那么多吗？在我看来，文章的水平都是参差不齐，很多毫无内容和价值，大家把时间浪费在这些信息上面是很不值得的。因为你读了这些文章，就没有了读其他好的文章的精力。</p><p>所以，码农桃花源想做一个优质信息源，提供优质的内容。每一篇文章都是有深度，有内容，有收获。一篇文章，我一般得花费 2 周左右，算是半月更，和那些日更的没法比。当然，只是在数量上没法比。而这个时代，最不缺的就是数量。</p><p>另外，文章长也算是我的一个特色。我完全可以拆分成上、中、下等等，但我希望一次性交付给我的读者所有有价值的内容。这样，你可以集中一个小时或是更长时间，精读完一篇文章。</p><p>闲话结束，今天要讲的内容是反射，进入正题。</p><h1 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h1><p>直接看维基百科上的定义：</p><blockquote><p>在计算机科学中，反射是指计算机程序在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。</p></blockquote><p>那我就要问个问题了：不用反射就不能在运行时访问、检测和修改它本身的状态和行为吗？</p><p>问题的回答，其实要首先理解什么叫访问、检测和修改它本身状态或行为，它的本质是什么？</p><p>实际上，它的本质是程序在运行期探知对象的类型信息和内存结构，不用反射能行吗？可以的！使用汇编语言，直接和内层打交道，什么信息不能获取？但是，当编程迁移到高级语言上来之后，就不行了！就只能通过<code>反射</code>来达到此项技能。</p><p>不同语言的反射模型不尽相同，有些语言还不支持反射。《Go 语言圣经》中是这样定义反射的：</p><blockquote><p>Go 语言提供了一种机制在运行时更新变量和检查它们的值、调用它们的方法，但是在编译时并不知道这些变量的具体类型，这称为反射机制。</p></blockquote><h1 id="为什么要用反射"><a href="#为什么要用反射" class="headerlink" title="为什么要用反射"></a>为什么要用反射</h1><p>需要反射的 2 个常见场景：</p><ol><li>有时你需要编写一个函数，但是并不知道传给你的参数类型是什么，可能是没约定好；也可能是传入的类型很多，这些类型并不能统一表示。这时反射就会用的上了。</li><li>有时候需要根据某些条件决定调用哪个函数，比如根据用户的输入来决定。这时就需要对函数和函数的参数进行反射，在运行期间动态地执行函数。</li></ol><p>在讲反射的原理以及如何用之前，还是说几点不使用反射的理由：</p><ol><li>与反射相关的代码，经常是难以阅读的。在软件工程中，代码可读性也是一个非常重要的指标。</li><li>Go 语言作为一门静态语言，编码过程中，编译器能提前发现一些类型错误，但是对于反射代码是无能为力的。所以包含反射相关的代码，很可能会运行很久，才会出错，这时候经常是直接 panic，可能会造成严重的后果。</li><li>反射对性能影响还是比较大的，比正常代码运行速度慢一到两个数量级。所以，对于一个项目中处于运行效率关键位置的代码，尽量避免使用反射特性。 </li></ol><h1 id="反射是如何实现的"><a href="#反射是如何实现的" class="headerlink" title="反射是如何实现的"></a>反射是如何实现的</h1><p>上一篇文章讲到了 <code>interface</code>，它是 Go 语言实现抽象的一个非常强大的工具。当向接口变量赋予一个实体类型的时候，接口会存储实体的类型信息，反射就是通过接口的类型信息实现的，反射建立在类型的基础上。</p><p>Go 语言在 reflect 包里定义了各种类型，实现了反射的各种函数，通过它们可以在运行时检测类型的信息、改变类型的值。</p><h2 id="types-和-interface"><a href="#types-和-interface" class="headerlink" title="types 和 interface"></a>types 和 interface</h2><p>Go 语言中，每个变量都有一个静态类型，在编译阶段就确定了的，比如 <code>int, float64, []int</code> 等等。注意，这个类型是声明时候的类型，不是底层数据类型。</p><p>Go 官方博客里就举了一个例子：</p><pre class=" language-golang"><code class="language-golang">type MyInt intvar i intvar j MyInt</code></pre><p>尽管 i，j 的底层类型都是 int，但我们知道，他们是不同的静态类型，除非进行类型转换，否则，i 和 j 不能同时出现在等号两侧。j 的静态类型就是 <code>MyInt</code>。</p><p>反射主要与 interface{} 类型相关。前面一篇关于 interface 相关的文章已经探讨过 interface 的底层结构，这里再来复习一下。</p><pre class=" language-golang"><code class="language-golang">type iface struct {    tab  *itab    data unsafe.Pointer}type itab struct {    inter  *interfacetype    _type  *_type    link   *itab    hash   uint32    bad    bool    inhash bool    unused [2]byte    fun    [1]uintptr}</code></pre><p>其中 <code>itab</code> 由具体类型 <code>_type</code> 以及 <code>interfacetype</code> 组成。<code>_type</code> 表示具体类型，而 <code>interfacetype</code> 则表示具体类型实现的接口类型。</p><p><img src="https://user-images.githubusercontent.com/7698088/56564826-82527600-65e1-11e9-956d-d98a212bc863.png" alt="iface 结构体全景"></p><p>实际上，iface 描述的是非空接口，它包含方法；与之相对的是 <code>eface</code>，描述的是空接口，不包含任何方法，Go 语言里有的类型都 <code>“实现了”</code> 空接口。</p><pre class=" language-golang"><code class="language-golang">type eface struct {    _type *_type    data  unsafe.Pointer}</code></pre><p>相比 <code>iface</code>，<code>eface</code> 就比较简单了。只维护了一个 <code>_type</code> 字段，表示空接口所承载的具体的实体类型。<code>data</code> 描述了具体的值。</p><p><img src="https://user-images.githubusercontent.com/7698088/56565105-318f4d00-65e2-11e9-96bd-4b2e192791dc.png" alt="eface 结构体全景"></p><p>还是用 Go 官方关于反射的博客里的例子，当然，我会用图形来详细解释，结合两者来看会更清楚。顺便提一下，搞技术的不要害怕英文资料，要想成为技术专家，读英文原始资料是技术提高的一条必经之路。</p><p>先明确一点：接口变量可以存储任何实现了接口定义的所有方法的变量。</p><p>Go 语言中最常见的就是 <code>Reader</code> 和 <code>Writer</code> 接口：</p><pre class=" language-golang"><code class="language-golang">type Reader interface {    Read(p []byte) (n int, err error)}type Writer interface {    Write(p []byte) (n int, err error)}</code></pre><p>接下来，就是接口之间的各种转换和赋值了：</p><pre class=" language-golang"><code class="language-golang">var r io.Readertty, err := os.OpenFile("/Users/qcrao/Desktop/test", os.O_RDWR, 0)if err != nil {    return nil, err}r = tty</code></pre><p>首先声明 <code>r</code> 的类型是 <code>io.Reader</code>，注意，这是 <code>r</code> 的静态类型，此时它的动态类型为 <code>nil</code>，并且它的动态值也是 <code>nil</code>。</p><p>之后，<code>r = tty</code> 这一语句，将 <code>r</code> 的动态类型变成 <code>*os.File</code>，动态值则变成非空，表示打开的文件对象。这时，r 可以用<code>&lt;value, type&gt;</code>对来表示为： <code>&lt;tty, *os.File&gt;</code>。</p><p><img src="https://user-images.githubusercontent.com/7698088/56844299-b29b5c80-68e0-11e9-8211-d227448806b7.png" alt="r=tty"></p><p>注意看上图，此时虽然 <code>fun</code> 所指向的函数只有一个 <code>Read</code> 函数，其实 <code>*os.File</code> 还包含 <code>Write</code> 函数，也就是说 <code>*os.File</code> 其实还实现了 <code>io.Writer</code> 接口。因此下面的断言语句可以执行：</p><pre class=" language-golang"><code class="language-golang">var w io.Writerw = r.(io.Writer)</code></pre><p>之所以用断言，而不能直接赋值，是因为 <code>r</code> 的静态类型是 <code>io.Reader</code>，并没有实现 <code>io.Writer</code> 接口。断言能否成功，看 <code>r</code> 的动态类型是否符合要求。</p><p>这样，w 也可以表示成 <code>&lt;tty, *os.File&gt;</code>，仅管它和 <code>r</code> 一样，但是 w 可调用的函数取决于它的静态类型 <code>io.Writer</code>，也就是说它只能有这样的调用形式： <code>w.Write()</code> 。<code>w</code> 的内存形式如下图：</p><p><img src="https://user-images.githubusercontent.com/7698088/57341967-09215a00-716f-11e9-99cc-cfaa0f312b54.png" alt="w = r.(io.Writer)"></p><p>和 <code>r</code> 相比，仅仅是 <code>fun</code> 对应的函数变了：<code>Read -&gt; Write</code>。</p><p>最后，再来一个赋值：</p><pre class=" language-golang"><code class="language-golang">var empty interface{}empty = w</code></pre><p>由于 <code>empty</code> 是一个空接口，因此所有的类型都实现了它，w 可以直接赋给它，不需要执行断言操作。</p><p><img src="https://user-images.githubusercontent.com/7698088/56844669-9b5f6d80-68e6-11e9-8a31-8d38951c7742.png" alt="empty=w"></p><p>从上面的三张图可以看到，interface 包含三部分信息：<code>_type</code> 是类型信息，<code>*data</code> 指向实际类型的实际值，<code>itab</code> 包含实际类型的信息，包括大小、包路径，还包含绑定在类型上的各种方法（图上没有画出方法），补充一下关于 os.File 结构体的图：</p><p><img src="https://user-images.githubusercontent.com/7698088/56946658-4bd6a700-6b5d-11e9-9a3d-0e781957be31.png" alt="struct_type"></p><p>这一节的最后，复习一下上一篇关于 interface 的文章，提到的一个技巧，这里再展示一下：</p><p>先参考源码，分别定义一个<code>“伪装”</code>的 iface 和 eface 结构体。</p><pre class=" language-golang"><code class="language-golang">type iface struct {    tab  *itab    data unsafe.Pointer}type itab struct {    inter uintptr    _type uintptr    link uintptr    hash  uint32    _     [4]byte    fun   [1]uintptr}type eface struct {    _type uintptr    data unsafe.Pointer}</code></pre><p>接着，将接口变量占据的内存内容强制解释成上面定义的类型，再打印出来：</p><pre class=" language-golang"><code class="language-golang">package mainimport (    "os"    "fmt"    "io"    "unsafe")func main() {    var r io.Reader    fmt.Printf("initial r: %T, %v\n", r, r)    tty, _ := os.OpenFile("/Users/qcrao/Desktop/test", os.O_RDWR, 0)    fmt.Printf("tty: %T, %v\n", tty, tty)    // 给 r 赋值    r = tty    fmt.Printf("r: %T, %v\n", r, r)    rIface := (*iface)(unsafe.Pointer(&r))    fmt.Printf("r: iface.tab._type = %#x, iface.data = %#x\n", rIface.tab._type, rIface.data)    // 给 w 赋值    var w io.Writer    w = r.(io.Writer)    fmt.Printf("w: %T, %v\n", w, w)    wIface := (*iface)(unsafe.Pointer(&w))    fmt.Printf("w: iface.tab._type = %#x, iface.data = %#x\n", wIface.tab._type, wIface.data)    // 给 empty 赋值    var empty interface{}    empty = w    fmt.Printf("empty: %T, %v\n", empty, empty)    emptyEface := (*eface)(unsafe.Pointer(&empty))    fmt.Printf("empty: eface._type = %#x, eface.data = %#x\n", emptyEface._type, emptyEface.data)}</code></pre><p>运行结果：</p><pre class=" language-golang"><code class="language-golang">initial r: <nil>, <nil>tty: *os.File, &{0xc4200820f0}r: *os.File, &{0xc4200820f0}r: iface.tab._type = 0x10bfcc0, iface.data = 0xc420080020w: *os.File, &{0xc4200820f0}w: iface.tab._type = 0x10bfcc0, iface.data = 0xc420080020empty: *os.File, &{0xc4200820f0}empty: eface._type = 0x10bfcc0, eface.data = 0xc420080020</code></pre><p><code>r，w，empty</code> 的动态类型和动态值都一样。不再详细解释了，结合前面的图可以看得非常清晰。</p><h2 id="反射的基本函数"><a href="#反射的基本函数" class="headerlink" title="反射的基本函数"></a>反射的基本函数</h2><p>reflect 包里定义了一个接口和一个结构体，即 <code>reflect.Type</code> 和 <code>reflect.Value</code>，它们提供很多函数来获取存储在接口里的类型信息。</p><p><code>reflect.Type</code> 主要提供关于类型相关的信息，所以它和 <code>_type</code> 关联比较紧密；<code>reflect.Value</code> 则结合 <code>_type</code> 和 <code>data</code> 两者，因此程序员可以获取甚至改变类型的值。</p><p>reflect 包中提供了两个基础的关于反射的函数来获取上述的接口和结构体：</p><pre class=" language-golang"><code class="language-golang">func TypeOf(i interface{}) Type func ValueOf(i interface{}) Value</code></pre><p><code>TypeOf</code> 函数用来提取一个接口中值的类型信息。由于它的输入参数是一个空的 <code>interface{}</code>，调用此函数时，实参会先被转化为 <code>interface{}</code>类型。这样，实参的类型信息、方法集、值信息都存储到 <code>interface{}</code> 变量里了。</p><p>看下源码：</p><pre class=" language-golang"><code class="language-golang">func TypeOf(i interface{}) Type {    eface := *(*emptyInterface)(unsafe.Pointer(&i))    return toType(eface.typ)}</code></pre><p>这里的 <code>emptyInterface</code> 和上面提到的 <code>eface</code> 是一回事（字段名略有差异，字段是相同的），且在不同的源码包：前者在 <code>reflect</code> 包，后者在 <code>runtime</code> 包。 <code>eface.typ</code> 就是动态类型。</p><pre class=" language-golang"><code class="language-golang">type emptyInterface struct {    typ  *rtype    word unsafe.Pointer}</code></pre><p>至于 <code>toType</code> 函数，只是做了一个类型转换：</p><pre class=" language-golang"><code class="language-golang">func toType(t *rtype) Type {    if t == nil {        return nil    }    return t}</code></pre><p>注意，返回值 <code>Type</code> 实际上是一个接口，定义了很多方法，用来获取类型相关的各种信息，而 <code>*rtype</code> 实现了 <code>Type</code> 接口。</p><pre class=" language-golang"><code class="language-golang">type Type interface {    // 所有的类型都可以调用下面这些函数    // 此类型的变量对齐后所占用的字节数    Align() int    // 如果是 struct 的字段，对齐后占用的字节数    FieldAlign() int    // 返回类型方法集里的第 `i` (传入的参数)个方法    Method(int) Method    // 通过名称获取方法    MethodByName(string) (Method, bool)    // 获取类型方法集里导出的方法个数    NumMethod() int    // 类型名称    Name() string    // 返回类型所在的路径，如：encoding/base64    PkgPath() string    // 返回类型的大小，和 unsafe.Sizeof 功能类似    Size() uintptr    // 返回类型的字符串表示形式    String() string    // 返回类型的类型值    Kind() Kind    // 类型是否实现了接口 u    Implements(u Type) bool    // 是否可以赋值给 u    AssignableTo(u Type) bool    // 是否可以类型转换成 u    ConvertibleTo(u Type) bool    // 类型是否可以比较    Comparable() bool    // 下面这些函数只有特定类型可以调用    // 如：Key, Elem 两个方法就只能是 Map 类型才能调用    // 类型所占据的位数    Bits() int    // 返回通道的方向，只能是 chan 类型调用    ChanDir() ChanDir    // 返回类型是否是可变参数，只能是 func 类型调用    // 比如 t 是类型 func(x int, y ... float64)    // 那么 t.IsVariadic() == true    IsVariadic() bool    // 返回内部子元素类型，只能由类型 Array, Chan, Map, Ptr, or Slice 调用    Elem() Type    // 返回结构体类型的第 i 个字段，只能是结构体类型调用    // 如果 i 超过了总字段数，就会 panic    Field(i int) StructField    // 返回嵌套的结构体的字段    FieldByIndex(index []int) StructField    // 通过字段名称获取字段    FieldByName(name string) (StructField, bool)    // FieldByNameFunc returns the struct field with a name    // 返回名称符合 func 函数的字段    FieldByNameFunc(match func(string) bool) (StructField, bool)    // 获取函数类型的第 i 个参数的类型    In(i int) Type    // 返回 map 的 key 类型，只能由类型 map 调用    Key() Type    // 返回 Array 的长度，只能由类型 Array 调用    Len() int    // 返回类型字段的数量，只能由类型 Struct 调用    NumField() int    // 返回函数类型的输入参数个数    NumIn() int    // 返回函数类型的返回值个数    NumOut() int    // 返回函数类型的第 i 个值的类型    Out(i int) Type    // 返回类型结构体的相同部分    common() *rtype    // 返回类型结构体的不同部分    uncommon() *uncommonType}</code></pre><p>可见 <code>Type</code> 定义了非常多的方法，通过它们可以获取类型的一切信息，大家一定要完整的过一遍上面所有的方法。</p><p>注意到 <code>Type</code> 方法集的倒数第二个方法 <code>common</code><br> 返回的 <code>rtype</code>类型，它和上一篇文章讲到的 <code>_type</code> 是一回事，而且源代码里也注释了：两边要保持同步：</p><pre class=" language-golang"><code class="language-golang"> // rtype must be kept in sync with ../runtime/type.go:/^type._type.</code></pre><pre class=" language-golang"><code class="language-golang">type rtype struct {    size       uintptr    ptrdata    uintptr    hash       uint32    tflag      tflag    align      uint8    fieldAlign uint8    kind       uint8    alg        *typeAlg    gcdata     *byte    str        nameOff    ptrToThis  typeOff}</code></pre><p>所有的类型都会包含 <code>rtype</code> 这个字段，表示各种类型的公共信息；另外，不同类型包含自己的一些独特的部分。</p><p>比如下面的 <code>arrayType</code> 和 <code>chanType</code> 都包含 <code>rytpe</code>，而前者还包含 slice，len 等和数组相关的信息；后者则包含 <code>dir</code> 表示通道方向的信息。</p><pre class=" language-golang"><code class="language-golang">// arrayType represents a fixed array type.type arrayType struct {    rtype `reflect:"array"`    elem  *rtype // array element type    slice *rtype // slice type    len   uintptr}// chanType represents a channel type.type chanType struct {    rtype `reflect:"chan"`    elem  *rtype  // channel element type    dir   uintptr // channel direction (ChanDir)}</code></pre><p>注意到，<code>Type</code> 接口实现了 <code>String()</code> 函数，满足 <code>fmt.Stringer</code> 接口，因此使用 <code>fmt.Println</code> 打印的时候，输出的是 <code>String()</code> 的结果。另外，<code>fmt.Printf()</code> 函数，如果使用 <code>%T</code> 来作为格式参数，输出的是 <code>reflect.TypeOf</code> 的结果，也就是动态类型。例如：</p><pre class=" language-golang"><code class="language-golang">fmt.Printf("%T", 3) // int</code></pre><hr><p>讲完了 <code>TypeOf</code> 函数，再来看一下 <code>ValueOf</code> 函数。返回值 <code>reflect.Value</code> 表示 <code>interface{}</code> 里存储的实际变量，它能提供实际变量的各种信息。相关的方法常常是需要结合类型信息和值信息。例如，如果要提取一个结构体的字段信息，那就需要用到 _type (具体到这里是指 structType) 类型持有的关于结构体的字段信息、偏移信息，以及 <code>*data</code> 所指向的内容 —— 结构体的实际值。</p><p>源码如下：</p><pre class=" language-golang"><code class="language-golang">func ValueOf(i interface{}) Value {    if i == nil {        return Value{}    }   // ……    return unpackEface(i)}// 分解 efacefunc unpackEface(i interface{}) Value {    e := (*emptyInterface)(unsafe.Pointer(&i))    t := e.typ    if t == nil {        return Value{}    }    f := flag(t.Kind())    if ifaceIndir(t) {        f |= flagIndir    }    return Value{t, e.word, f}}</code></pre><p>从源码看，比较简单：将先将 <code>i</code> 转换成 <code>*emptyInterface</code> 类型， 再将它的 <code>typ</code> 字段和 <code>word</code> 字段以及一个标志位字段组装成一个 <code>Value</code> 结构体，而这就是 <code>ValueOf</code> 函数的返回值，它包含类型结构体指针、真实数据的地址、标志位。</p><p>Value 结构体定义了很多方法，通过这些方法可以直接操作 Value 字段 ptr 所指向的实际数据：</p><pre class=" language-golang"><code class="language-golang">// 设置切片的 len 字段，如果类型不是切片，就会panic func (v Value) SetLen(n int) // 设置切片的 cap 字段 func (v Value) SetCap(n int) // 设置字典的 kv func (v Value) SetMapIndex(key, val Value) // 返回切片、字符串、数组的索引 i 处的值 func (v Value) Index(i int) Value // 根据名称获取结构体的内部字段值 func (v Value) FieldByName(name string) Value // ……</code></pre><p><code>Value</code> 字段还有很多其他的方法。例如：</p><pre class=" language-golang"><code class="language-golang">// 用来获取 int 类型的值func (v Value) Int() int64// 用来获取结构体字段（成员）数量func (v Value) NumField() int// 尝试向通道发送数据（不会阻塞）func (v Value) TrySend(x reflect.Value) bool// 通过参数列表 in 调用 v 值所代表的函数（或方法func (v Value) Call(in []Value) (r []Value) // 调用变参长度可变的函数func (v Value) CallSlice(in []Value) []Value </code></pre><p>不一一列举了，反正是非常多。可以去 <code>src/reflect/value.go</code> 去看看源码，搜索 <code>func (v Value)</code> 就能看到。</p><p>另外，通过 <code>Type()</code> 方法和 <code>Interface()</code> 方法可以打通 <code>interface</code>、<code>Type</code>、<code>Value</code> 三者。Type() 方法也可以返回变量的类型信息，与 reflect.TypeOf() 函数等价。Interface() 方法可以将 Value 还原成原来的 interface。</p><p>这里引用老钱《快学Go语言第十五课——反射》的一张图：</p><p><img src="https://user-images.githubusercontent.com/7698088/57130652-bb060280-6dcc-11e9-9c63-6e2bc4e33509.png" alt="三者关系"><br>总结一下：<code>TypeOf()</code> 函数返回一个接口，这个接口定义了一系列方法，利用这些方法可以获取关于类型的所有信息； <code>ValueOf()</code> 函数返回一个结构体变量，包含类型信息以及实际值。</p><p>用一张图来串一下：</p><p><img src="https://user-images.githubusercontent.com/7698088/56848267-6f111480-6919-11e9-826f-a809093d17ea.png" alt="value rtype"></p><p>上图中，<code>rtye</code> 实现了 <code>Type</code> 接口，是所有类型的公共部分。emptyface 结构体和 eface 其实是一个东西，而 rtype 其实和 _type 是一个东西，只是一些字段稍微有点差别，比如 emptyface 的 word 字段和 eface 的 data 字段名称不同，但是数据型是一样的。</p><h2 id="反射的三大定律"><a href="#反射的三大定律" class="headerlink" title="反射的三大定律"></a>反射的三大定律</h2><p>根据 Go 官方关于反射的博客，反射有三大定律：</p><blockquote><ol><li>Reflection goes from interface value to reflection object.</li></ol></blockquote><blockquote><ol start="2"><li>Reflection goes from reflection object to interface value.</li></ol></blockquote><blockquote><ol start="3"><li>To modify a reflection object, the value must be settable.</li></ol></blockquote><p>第一条是最基本的：反射是一种检测存储在 <code>interface</code> 中的类型和值机制。这可以通过 <code>TypeOf</code> 函数和 <code>ValueOf</code> 函数得到。</p><p>第二条实际上和第一条是相反的机制，它将 <code>ValueOf</code> 的返回值通过 <code>Interface()</code> 函数反向转变成 <code>interface</code> 变量。</p><p>前两条就是说 <code>接口型变量</code> 和 <code>反射类型对象</code> 可以相互转化，反射类型对象实际上就是指的前面说的 <code>reflect.Type</code> 和 <code>reflect.Value</code>。</p><p>第三条不太好懂：如果需要操作一个反射变量，那么它必须是可设置的。反射变量可设置的本质是它存储了原变量本身，这样对反射变量的操作，就会反映到原变量本身；反之，如果反射变量不能代表原变量，那么操作了反射变量，不会对原变量产生任何影响，这会给使用者带来疑惑。所以第二种情况在语言层面是不被允许的。</p><p>举一个经典例子：</p><pre class=" language-golang"><code class="language-golang">var x float64 = 3.4v := reflect.ValueOf(x)v.SetFloat(7.1) // Error: will panic.</code></pre><p>执行上面的代码会产生 panic，原因是反射变量 <code>v</code> 不能代表 <code>x</code> 本身，为什么？因为调用 <code>reflect.ValueOf(x)</code> 这一行代码的时候，传入的参数在函数内部只是一个拷贝，是值传递，所以 <code>v</code> 代表的只是 <code>x</code> 的一个拷贝，因此对 <code>v</code> 进行操作是被禁止的。</p><p>可设置是反射变量 <code>Value</code> 的一个性质，但不是所有的 <code>Value</code> 都是可被设置的。</p><p>就像在一般的函数里那样，当我们想改变传入的变量时，使用指针就可以解决了。</p><pre class=" language-golang"><code class="language-golang">var x float64 = 3.4p := reflect.ValueOf(&x)fmt.Println("type of p:", p.Type())fmt.Println("settability of p:", p.CanSet())</code></pre><p>输出是这样的：</p><pre class=" language-golang"><code class="language-golang">type of p: *float64settability of p: false</code></pre><p><code>p</code> 还不是代表 <code>x</code>，<code>p.Elem()</code> 才真正代表 <code>x</code>，这样就可以真正操作 <code>x</code> 了：</p><pre class=" language-golang"><code class="language-golang">v := p.Elem()v.SetFloat(7.1)fmt.Println(v.Interface()) // 7.1fmt.Println(x) // 7.1</code></pre><p>关于第三条，记住一句话：如果想要操作原变量，反射变量 <code>Value</code> 必须要 hold 住原变量的地址才行。</p><h1 id="反射相关函数的使用"><a href="#反射相关函数的使用" class="headerlink" title="反射相关函数的使用"></a>反射相关函数的使用</h1><h2 id="代码样例"><a href="#代码样例" class="headerlink" title="代码样例"></a>代码样例</h2><p>网络上各种博客文章里使用反射的样例代码非常多，读过这篇文章后，基本没有看不懂的，哈哈！不过，我这里还是举一个例子，并讲解一番：</p><pre class=" language-golang"><code class="language-golang">package mainimport (    "reflect"    "fmt")type Child struct {    Name     string    Grade    int    Handsome bool}type Adult struct {    ID         string `qson:"Name"`    Occupation string    Handsome   bool}// 如果输入参数 i 是 Slice，元素是结构体，有一个字段名为 `Handsome`，// 并且有一个字段的 tag 或者字段名是 `Name` ，// 如果该 `Name` 字段的值是 `qcrao`，// 就把结构体中名为 `Handsome` 的字段值设置为 true。func handsome(i interface{}) {    // 获取 i 的反射变量 Value    v := reflect.ValueOf(i)    // 确定 v 是一个 Slice    if v.Kind() != reflect.Slice {        return    }    // 确定 v 是的元素为结构体    if e := v.Type().Elem(); e.Kind() != reflect.Struct {        return    }    // 确定结构体的字段名含有 "ID" 或者 json tag 标签为 `name`    // 确定结构体的字段名 "Handsome"    st := v.Type().Elem()    // 寻找字段名为 Name 或者 tag 的值为 Name 的字段    foundName := false    for i := 0; i < st.NumField(); i++ {        f := st.Field(i)        tag := f.Tag.Get("qson")        if (tag == "Name" || f.Name == "Name") && f.Type.Kind() == reflect.String {            foundName = true            break        }    }    if !foundName {        return    }    if niceField, foundHandsome := st.FieldByName("Handsome"); foundHandsome == false || niceField.Type.Kind() != reflect.Bool {        return    }    // 设置名字为 "qcrao" 的对象的 "Handsome" 字段为 true    for i := 0; i < v.Len(); i++ {        e := v.Index(i)        handsome := e.FieldByName("Handsome")        // 寻找字段名为 Name 或者 tag 的值为 Name 的字段        var name reflect.Value        for j := 0; j < st.NumField(); j++ {            f := st.Field(j)            tag := f.Tag.Get("qson")            if tag == "Name" || f.Name == "Name" {                name = v.Index(i).Field(j)            }        }        if name.String() == "qcrao" {            handsome.SetBool(true)        }    }}func main() {    children := []Child{        {Name: "Ava", Grade: 3, Handsome: true},        {Name: "qcrao", Grade: 6, Handsome: false},    }    adults := []Adult{        {ID: "Steve", Occupation: "Clerk", Handsome: true},        {ID: "qcrao", Occupation: "Go Programmer", Handsome: false},    }    fmt.Printf("adults before handsome: %v\n", adults)    handsome(adults)    fmt.Printf("adults after handsome: %v\n", adults)    fmt.Println("-------------")    fmt.Printf("children before handsome: %v\n", children)    handsome(children)    fmt.Printf("children after handsome: %v\n", children)}</code></pre><p>代码运行结果：</p><pre class=" language-shell"><code class="language-shell">adults before handsome: [{Steve Clerk true} {qcrao Go Programmer false}]adults after handsome: [{Steve Clerk true} {qcrao Go Programmer true}]-------------children before handsome: [{Ava 3 true} {qcrao 6 false}]children after handsome: [{Ava 3 true} {qcrao 6 true}]</code></pre><p>代码主要做的事情是：找出传入的参数为 Slice，并且 Slice 的元素为结构体，如果其中有一个字段名是 <code>Name</code> 或者是 标签名称为 <code>Name</code>，并且还有一个字段名是 <code>Handsome</code> 的情形。如果找到，并且字段名称为 <code>Name</code> 的实际值是 <code>qcrao</code> 的话，就把另一个字段 <code>Handsome</code> 的值置为 true。</p><p>程序并不关心传入的结构体到底是什么，只要它的字段名包含 <code>Name</code> 和 <code>Handsome</code>，都是 handsome 函数要工作的对象。</p><p>注意一点，<code>Adult</code> 结构体的标签 <code>qson:&quot;Name&quot;</code>，中间是没有空格的，否则 <code>Tag.Get(&quot;qson&quot;)</code> 识别不出来。</p><h2 id="未导出成员"><a href="#未导出成员" class="headerlink" title="未导出成员"></a>未导出成员</h2><p>利用反射机制，对于结构体中未导出成员，可以读取，但不能修改其值。</p><p>注意，正常情况下，代码是不能读取结构体未导出成员的，但通过反射可以越过这层限制。另外，通过反射，结构体中可以被修改的成员只有是导出成员，也就是字段名的首字母是大写的。</p><blockquote><p>一个可取地址的 reflect.Value 变量会记录一个结构体成员是否是未导出成员，如果是的话则拒绝修改操作。<br>CanAddr 不能说明一个变量是否可以被修改。<br>CanSet 则可以检查对应的 reflect.Value 是否可取地址并可被修改。</p></blockquote><pre class=" language-golang"><code class="language-golang">package mainimport (    "reflect"    "fmt")type Child struct {    Name     string    handsome bool}func main() {    qcrao := Child{Name: "qcrao", handsome: true}    v := reflect.ValueOf(&qcrao)    f := v.Elem().FieldByName("Name")    fmt.Println(f.String())    f.SetString("stefno")    fmt.Println(f.String())    f = v.Elem().FieldByName("handsome")    // 这一句会导致 panic，因为 handsome 字段未导出    //f.SetBool(true)    fmt.Println(f.Bool())}</code></pre><p>执行结果：</p><pre class=" language-shell"><code class="language-shell">qcraostefnotrue</code></pre><p>上面的例子中，handsome 字段未导出，可以读取，但不能调用相关 set 方法，否则会 panic。反射用起来一定要小心，调用类型不匹配的方法，会导致各种 panic。</p><h1 id="反射的实际应用"><a href="#反射的实际应用" class="headerlink" title="反射的实际应用"></a>反射的实际应用</h1><p>反射的实际应用非常广：IDE 中的代码自动补全功能、对象序列化（json 函数库）、fmt 相关函数的实现、ORM（全称是：Object Relational Mapping，对象关系映射）……</p><p>这里举 2 个例子：json 序列化和 DeepEqual 函数。</p><h2 id="json-序列化"><a href="#json-序列化" class="headerlink" title="json 序列化"></a>json 序列化</h2><p>开发过 web 服务的同学，一定用过 <code>json</code> 数据格式。<code>json</code> 是一种独立于语言的数据格式。最早用于浏览器和服务器之间的实时无状态的数据交换，并由此发展起来。</p><p>Go 语言中，主要提供 2 个函数用于序列化和反序列化：</p><pre class=" language-golang"><code class="language-golang">func Marshal(v interface{}) ([]byte, error)func Unmarshal(data []byte, v interface{}) error</code></pre><p>两个函数的参数都包含 <code>interface</code>，具体实现的时候，都会用到反射相关的特性。</p><p>对于序列化和反序列化函数，均需要知道参数的所有字段，包括字段类型和值，再调用相关的 get 函数或者 set 函数进行实际的操作。</p><h2 id="DeepEqual-的作用及原理"><a href="#DeepEqual-的作用及原理" class="headerlink" title="DeepEqual 的作用及原理"></a>DeepEqual 的作用及原理</h2><p>在测试函数中，经常会需要这样的函数：判断两个变量的实际内容完全一致。</p><p>例如：如何判断两个 slice 所有的元素完全相同；如何判断两个 map 的 key 和 value 完全相同等等。</p><p>上述问题，可以通过 <code>DeepEqual</code> 函数实现。</p><pre class=" language-golang"><code class="language-golang">func DeepEqual(x, y interface{}) bool</code></pre><p><code>DeepEqual</code> 函数的参数是两个 <code>interface</code>，实际上也就是可以输入任意类型，输出 true 或者 flase 表示输入的两个变量是否是“深度”相等。</p><p>先明白一点，如果是不同的类型，即使是底层类型相同，相应的值也相同，那么两者也不是“深度”相等。</p><pre class=" language-golang"><code class="language-golang">type MyInt inttype YourInt intfunc main() {    m := MyInt(1)    y := YourInt(1)    fmt.Println(reflect.DeepEqual(m, y)) // false}</code></pre><p>上面的代码中，m, y 底层都是 int，而且值都是 1，但是两者静态类型不同，前者是 <code>MyInt</code>，后者是 <code>YourInt</code>，因此两者不是“深度”相等。</p><p>在源码里，有对 DeepEqual 函数的非常清楚地注释，列举了不同类型，DeepEqual 的比较情形，这里做一个总结：</p><table><thead><tr><th>类型</th><th>深度相等情形</th></tr></thead><tbody><tr><td>Array</td><td>相同索引处的元素“深度”相等</td></tr><tr><td>Struct</td><td>相应字段，包含导出和不导出，“深度”相等</td></tr><tr><td>Func</td><td>只有两者都是 nil 时</td></tr><tr><td>Interface</td><td>两者存储的具体值“深度”相等</td></tr><tr><td>Map</td><td>1、都为 nil；2、非空、长度相等，指向同一个 map 实体对象，或者相应的 key 指向的 value “深度”相等</td></tr><tr><td>Pointer</td><td>1、使用 == 比较的结果相等；2、指向的实体“深度”相等</td></tr><tr><td>Slice</td><td>1、都为 nil；2、非空、长度相等，首元素指向同一个底层数组的相同元素，即 &amp;x[0] == &amp;y[0] 或者 相同索引处的元素“深度”相等</td></tr><tr><td>numbers, bools, strings, and channels</td><td>使用 == 比较的结果为真</td></tr></tbody></table><p>一般情况下，DeepEqual 的实现只需要递归地调用 == 就可以比较两个变量是否是真的“深度”相等。</p><p>但是，有一些异常情况：比如 func 类型是不可比较的类型，只有在两个 func 类型都是 nil 的情况下，才是“深度”相等；float 类型，由于精度的原因，也是不能使用 == 比较的；包含 func 类型或者 float 类型的 struct， interface， array 等。</p><p>对于指针而言，当两个值相等的指针就是“深度”相等，因为两者指向的内容是相等的，即使两者指向的是 func 类型或者 float 类型，这种情况下不关心指针所指向的内容。</p><p>同样，对于指向相同 slice， map 的两个变量也是“深度”相等的，不关心 slice， map 具体的内容。</p><p>对于“有环”的类型，比如循环链表，比较两者是否“深度”相等的过程中，需要对已比较的内容作一个标记，一旦发现两个指针之前比较过，立即停止比较，并判定二者是深度相等的。这样做的原因是，及时停止比较，避免陷入无限循环。</p><p>来看源码：</p><pre class=" language-golang"><code class="language-golang">func DeepEqual(x, y interface{}) bool {    if x == nil || y == nil {        return x == y    }    v1 := ValueOf(x)    v2 := ValueOf(y)    if v1.Type() != v2.Type() {        return false    }    return deepValueEqual(v1, v2, make(map[visit]bool), 0)}</code></pre><p>首先查看两者是否有一个是 nil 的情况，这种情况下，只有两者都是 nil，函数才会返回 true。</p><p>接着，使用反射，获取x，y 的反射对象，并且立即比较两者的类型，根据前面的内容，这里实际上是动态类型，如果类型不同，直接返回 false。</p><p>最后，最核心的内容在子函数 <code>deepValueEqual</code> 中。</p><p>代码比较长，思路却比较简单清晰：核心是一个 switch 语句，识别输入参数的不同类型，分别递归调用 deepValueEqual 函数，一直递归到最基本的数据类型，比较 int，string 等可以直接得出 true 或者 false，再一层层地返回，最终得到“深度”相等的比较结果。</p><p>实际上，各种类型的比较套路比较相似，这里就直接节选一个稍微复杂一点的 <code>map</code> 类型的比较：</p><pre class=" language-golang"><code class="language-golang">// deepValueEqual 函数// ……case Map:    if v1.IsNil() != v2.IsNil() {        return false    }    if v1.Len() != v2.Len() {        return false    }    if v1.Pointer() == v2.Pointer() {        return true    }    for _, k := range v1.MapKeys() {        val1 := v1.MapIndex(k)        val2 := v2.MapIndex(k)        if !val1.IsValid() || !val2.IsValid() || !deepValueEqual(v1.MapIndex(k), v2.MapIndex(k), visited, depth+1) {            return false        }    }    return true// ……    </code></pre><p>和前文总结的表格里，比较 map 是否相等的思路比较一致，也不需要多说什么。说明一点，<code>visited</code> 是一个 map，记录递归过程中，比较过的“对”：</p><pre class=" language-golang"><code class="language-golang">type visit struct {    a1  unsafe.Pointer    a2  unsafe.Pointer    typ Type}map[visit]bool</code></pre><p>比较过程中，一旦发现比较的“对”，已经在 map 里出现过的话，直接判定“深度”比较结果的是 <code>true</code>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Go 作为一门静态语言，相比 Python 等动态语言，在编写过程中灵活性会受到一定的限制。但是通过接口加反射实现了类似于动态语言的能力：可以在程序运行时动态地捕获甚至改变类型的信息和值。</p><p>Go 语言的反射实现的基础是类型，或者说是 interface，当我们使用反射特性时，实际上用到的就是存储在 interface 变量中的和类型相关的信息，也就是常说的 <code>&lt;type, value&gt;</code> 对。</p><p>只有 interface 才有反射的说法。</p><p>反射在 reflect 包中实现，涉及到两个相关函数：</p><pre class=" language-golang"><code class="language-golang">func TypeOf ( i interface{} ) Typefunc ValueOf ( i interface{} ) Value</code></pre><p>Type 是一个接口，定义了很多相关方法，用于获取类型信息。Value 则持有类型的具体值。Type、Value、Interface 三者间通过函数 TypeOf，ValueOf，Interface 进行相互转换。</p><p>最后温习一下反射三大定律：</p><blockquote><ol><li>Reflection goes from interface value to reflection object.</li><li>Reflection goes from reflection object to interface value.</li><li>To modify a reflection object, the value must be settable.</li></ol></blockquote><p>翻译一下：</p><blockquote><ol><li>反射将接口变量转换成反射对象 Type 和 Value；</li><li>反射可以通过反射对象 Value 还原成原先的接口变量；</li><li>反射可以用来修改一个变量的值，前提是这个值可以被修改。</li></ol></blockquote><p><img src="https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png" alt="QR"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【维基百科中文】<a href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%B0%84_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%B0%84_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)</a></p><p>【码洞老钱 反射】<a href="https://juejin.im/post/5c2040d76fb9a049c643d9bd" target="_blank" rel="noopener">https://juejin.im/post/5c2040d76fb9a049c643d9bd</a></p><p>【Go官方博客 reflection】<a href="https://blog.golang.org/laws-of-reflection" target="_blank" rel="noopener">https://blog.golang.org/laws-of-reflection</a></p><p>【GCTT译文，不错】<a href="https://mp.weixin.qq.com/s/dkgJ_fA0smvpv69t5Nv-7A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/dkgJ_fA0smvpv69t5Nv-7A</a></p><p>【json库 源码分析】<a href="https://zhuanlan.zhihu.com/p/37165706" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/37165706</a></p><p>【reflect 代码例子和图比较好】<a href="https://blog.gopheracademy.com/advent-2018/interfaces-and-reflect/" target="_blank" rel="noopener">https://blog.gopheracademy.com/advent-2018/interfaces-and-reflect/</a></p><p>【反射使用讲得不错】<a href="https://juejin.im/post/5a75a4fb5188257a82110544" target="_blank" rel="noopener">https://juejin.im/post/5a75a4fb5188257a82110544</a></p><p>【接口和反射的关系 ，english】<a href="https://blog.gopheracademy.com/advent-2018/interfaces-and-reflect/" target="_blank" rel="noopener">https://blog.gopheracademy.com/advent-2018/interfaces-and-reflect/</a></p><p>【总结成知识点】<a href="http://www.cnblogs.com/susufufu/p/7653579.html" target="_blank" rel="noopener">http://www.cnblogs.com/susufufu/p/7653579.html</a></p><p>【Type Value】<a href="https://colobu.com/2016/07/09/dive-into-go-13/" target="_blank" rel="noopener">https://colobu.com/2016/07/09/dive-into-go-13/</a></p><p>【讲得比较清晰简单】<a href="https://www.lijiaocn.com/%E7%BC%96%E7%A8%8B/2017/11/06/golang-reflection.html" target="_blank" rel="noopener">https://www.lijiaocn.com/%E7%BC%96%E7%A8%8B/2017/11/06/golang-reflection.html</a></p><p>【DeepEqual】<a href="https://github.com/Chasiny/Blog/blob/master/blog/go/package/go-reflect-deepequal.md">https://github.com/Chasiny/Blog/blob/master/blog/go/package/go-reflect-deepequal.md</a></p><p>【反射使用场景】<a href="https://yq.aliyun.com/articles/599584" target="_blank" rel="noopener">https://yq.aliyun.com/articles/599584</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;反射和 Interface 息息相关，而 Interface 是我们&lt;a href=&quot;https://mp.weixin.qq.com/s/EbxkBokYBajkCR-MazL0ZA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上一篇文章&lt;/a&gt;的内容
      
    
    </summary>
    
      <category term="编程语言" scheme="https://github.com/qcrao/qcrao.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="golang" scheme="https://github.com/qcrao/qcrao.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>深度解密Go语言之关于interface的 10 个问题</title>
    <link href="https://github.com/qcrao/qcrao.github.io/2019/04/25/dive-into-go-interface/"/>
    <id>https://github.com/qcrao/qcrao.github.io/2019/04/25/dive-into-go-interface/</id>
    <published>2019-04-25T00:25:00.000Z</published>
    <updated>2019-07-24T14:06:45.681Z</updated>
    
    <content type="html"><![CDATA[<p>这次文章依然很长，基本上涵盖了 <code>interface</code> 的方方面面，有例子，有源码分析，有汇编分析，前前后后写了 20 多天。洋洋洒洒，长篇大论，依然有些东西没有涉及到，比如文章里没有写到<code>反射</code>，当然，后面会单独写一篇关于<code>反射</code>的文章，这是后话。</p><p>还是希望看你在看完文章后能有所收获，有任何问题或意见建议，欢迎在文章后面留言。</p><p>这篇文章的架构比较简单，直接抛出 10 个问题，一一解答。</p><h1 id="1-Go-语言与鸭子类型的关系"><a href="#1-Go-语言与鸭子类型的关系" class="headerlink" title="1. Go 语言与鸭子类型的关系"></a>1. Go 语言与鸭子类型的关系</h1><p>先直接来看维基百科里的定义：</p><blockquote><p>If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.</p></blockquote><p>翻译过来就是：如果某个东西长得像鸭子，像鸭子一样游泳，像鸭子一样嘎嘎叫，那它就可以被看成是一只鸭子。</p><p><code>Duck Typing</code>，鸭子类型，是动态编程语言的一种对象推断策略，它更关注对象能如何被使用，而不是对象的类型本身。Go 语言作为一门静态语言，它通过通过接口的方式完美支持鸭子类型。</p><p>例如，在动态语言 python 中，定义一个这样的函数：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">hello_world</span><span class="token punctuation">(</span>coder<span class="token punctuation">)</span><span class="token punctuation">:</span>    coder<span class="token punctuation">.</span>say_hello<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>当调用此函数的时候，可以传入任意类型，只要它实现了 <code>say_hello()</code> 函数就可以。如果没有实现，运行过程中会出现错误。</p><p>而在静态语言如 Java, C++ 中，必须要显示地声明实现了某个接口，之后，才能用在任何需要这个接口的地方。如果你在程序中调用 <code>hello_world</code> 函数，却传入了一个根本就没有实现 <code>say_hello()</code> 的类型，那在编译阶段就不会通过。这也是静态语言比动态语言更安全的原因。</p><p>动态语言和静态语言的差别在此就有所体现。静态语言在编译期间就能发现类型不匹配的错误，不像动态语言，必须要运行到那一行代码才会报错。插一句，这也是我不喜欢用 <code>python</code> 的一个原因。当然，静态语言要求程序员在编码阶段就要按照规定来编写程序，为每个变量规定数据类型，这在某种程度上，加大了工作量，也加长了代码量。动态语言则没有这些要求，可以让人更专注在业务上，代码也更短，写起来更快，这一点，写 python 的同学比较清楚。</p><p>Go 语言作为一门现代静态语言，是有后发优势的。它引入了动态语言的便利，同时又会进行静态语言的类型检查，写起来是非常 Happy 的。Go 采用了折中的做法：不要求类型显示地声明实现了某个接口，只要实现了相关的方法即可，编译器就能检测到。</p><p>来看个例子：</p><p>先定义一个接口，和使用此接口作为参数的函数：</p><pre class=" language-golang"><code class="language-golang">type IGreeting interface {    sayHello()}func sayHello(i IGreeting) {    i.sayHello()}</code></pre><p>再来定义两个结构体：</p><pre class=" language-golang"><code class="language-golang">type Go struct {}func (g Go) sayHello() {    fmt.Println("Hi, I am GO!")}type PHP struct {}func (p PHP) sayHello() {    fmt.Println("Hi, I am PHP!")}</code></pre><p>最后，在 main 函数里调用 sayHello() 函数：</p><pre class=" language-golang"><code class="language-golang">func main() {    golang := Go{}    php := PHP{}    sayHello(golang)    sayHello(php)}</code></pre><p>程序输出：</p><pre class=" language-shell"><code class="language-shell">Hi, I am GO!Hi, I am PHP!</code></pre><p>在 main 函数中，调用调用 sayHello() 函数时，传入了 <code>golang, php</code> 对象，它们并没有显式地声明实现了 IGreeting 类型，只是实现了接口所规定的 sayHello() 函数。实际上，编译器在调用 sayHello() 函数时，会隐式地将 <code>golang, php</code> 对象转换成 IGreeting 类型，这也是静态语言的类型检查功能。</p><p>顺带再提一下动态语言的特点：</p><blockquote><p>变量绑定的类型是不确定的，在运行期间才能确定<br>函数和方法可以接收任何类型的参数，且调用时不检查参数类型<br>不需要实现接口</p></blockquote><p>总结一下，鸭子类型是一种动态语言的风格，在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由它”当前方法和属性的集合”决定。Go 作为一种静态语言，通过接口实现了 <code>鸭子类型</code>，实际上是 Go 的编译器在其中作了隐匿的转换工作。</p><h1 id="2-值接收者和指针接收者的区别"><a href="#2-值接收者和指针接收者的区别" class="headerlink" title="2. 值接收者和指针接收者的区别"></a>2. 值接收者和指针接收者的区别</h1><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法能给用户自定义的类型添加新的行为。它和函数的区别在于方法有一个接收者，给一个函数添加一个接收者，那么它就变成了方法。接收者可以是<code>值接收者</code>，也可以是<code>指针接收者</code>。</p><p>在调用方法的时候，值类型既可以调用<code>值接收者</code>的方法，也可以调用<code>指针接收者</code>的方法；指针类型既可以调用<code>指针接收者</code>的方法，也可以调用<code>值接收者</code>的方法。</p><p>也就是说，不管方法的接收者是什么类型，该类型的值和指针都可以调用，不必严格符合接收者的类型。</p><p>来看个例子：</p><pre class=" language-golang"><code class="language-golang">package mainimport "fmt"type Person struct {    age int}func (p Person) howOld() int {    return p.age}func (p *Person) growUp() {    p.age += 1}func main() {    // qcrao 是值类型    qcrao := Person{age: 18}    // 值类型 调用接收者也是值类型的方法    fmt.Println(qcrao.howOld())    // 值类型 调用接收者是指针类型的方法    qcrao.growUp()    fmt.Println(qcrao.howOld())    // ----------------------    // stefno 是指针类型    stefno := &Person{age: 100}    // 指针类型 调用接收者是值类型的方法    fmt.Println(stefno.howOld())    // 指针类型 调用接收者也是指针类型的方法    stefno.growUp()    fmt.Println(stefno.howOld())}</code></pre><p>上例子的输出结果是：</p><pre class=" language-shell"><code class="language-shell">1819100101</code></pre><p>调用了 <code>growUp</code> 函数后，不管调用者是值类型还是指针类型，它的 <code>Age</code> 值都改变了。</p><p>实际上，当类型和方法的接收者类型不同时，其实是编译器在背后做了一些工作，用一个表格来呈现：</p><table><thead><tr><th>-</th><th>值接收者</th><th>指针接收者</th></tr></thead><tbody><tr><td>值类型调用者</td><td>方法会使用调用者的一个副本，类似于“传值”</td><td>使用值的引用来调用方法，上例中，<code>qcrao.growUp()</code> 实际上是 <code>(&amp;qcrao).growUp()</code></td></tr><tr><td>指针类型调用者</td><td>指针被解引用为值，上例中，<code>stefno.howOld()</code> 实际上是 <code>(*stefno).howOld()</code></td><td>实际上也是“传值”，方法里的操作会影响到调用者，类似于指针传参，拷贝了一份指针</td></tr></tbody></table><h2 id="值接收者和指针接收者"><a href="#值接收者和指针接收者" class="headerlink" title="值接收者和指针接收者"></a>值接收者和指针接收者</h2><p>前面说过，不管接收者类型是值类型还是指针类型，都可以通过值类型或指针类型调用，这里面实际上通过语法糖起作用的。</p><p>先说结论：实现了接收者是值类型的方法，相当于自动实现了接收者是指针类型的方法；而实现了接收者是指针类型的方法，不会自动生成对应接收者是值类型的方法。</p><p>来看一个例子，就会完全明白：</p><pre class=" language-golang"><code class="language-golang">package mainimport "fmt"type coder interface {    code()    debug()}type Gopher struct {    language string}func (p Gopher) code() {    fmt.Printf("I am coding %s language\n", p.language)}func (p *Gopher) debug() {    fmt.Printf("I am debuging %s language\n", p.language)}func main() {    var c coder = &Gopher{"Go"}    c.code()    c.debug()}</code></pre><p>上述代码里定义了一个接口 <code>coder</code>，接口定义了两个函数：</p><pre class=" language-golang"><code class="language-golang">code()debug()</code></pre><p>接着定义了一个结构体 <code>Gopher</code>，它实现了两个方法，一个值接收者，一个指针接收者。</p><p>最后，我们在 <code>main</code> 函数里通过接口类型的变量调用了定义的两个函数。</p><p>运行一下，结果：</p><pre class=" language-shell"><code class="language-shell">I am coding Go languageI am debuging Go language</code></pre><p>但是如果我们把 <code>main</code> 函数的第一条语句换一下：</p><pre class=" language-golang"><code class="language-golang">func main() {    var c coder = Gopher{"Go"}    c.code()    c.debug()}</code></pre><p>运行一下，报错：</p><pre class=" language-shell"><code class="language-shell">./main.go:23:6: cannot use Gopher literal (type Gopher) as type coder in assignment:    Gopher does not implement coder (debug method has pointer receiver)</code></pre><p>看出这两处代码的差别了吗？第一次是将 <code>&amp;Gopher</code> 赋给了 <code>coder</code>；第二次则是将 <code>Gopher</code> 赋给了 <code>coder</code>。</p><p>第二次报错是说，<code>Gopher</code> 没有实现 <code>coder</code>。很明显了吧，因为 <code>Gopher</code> 类型并没有实现 <code>debug</code> 方法；表面上看， <code>*Gopher</code> 类型也没有实现 <code>code</code> 方法，但是因为 <code>Gopher</code> 类型实现了 <code>code</code> 方法，所以让 <code>*Gopher</code> 类型自动拥有了 <code>code</code> 方法。</p><p>当然，上面的说法有一个简单的解释：接收者是指针类型的方法，很可能在方法中会对接收者的属性进行更改操作，从而影响接收者；而对于接收者是值类型的方法，在方法中不会对接收者本身产生影响。</p><p>所以，当实现了一个接收者是值类型的方法，就可以自动生成一个接收者是对应指针类型的方法，因为两者都不会影响接收者。但是，当实现了一个接收者是指针类型的方法，如果此时自动生成一个接收者是值类型的方法，原本期望对接收者的改变（通过指针实现），现在无法实现，因为值类型会产生一个拷贝，不会真正影响调用者。</p><p>最后，只要记住下面这点就可以了：</p><blockquote><p>如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法。</p></blockquote><h2 id="两者分别在何时使用"><a href="#两者分别在何时使用" class="headerlink" title="两者分别在何时使用"></a>两者分别在何时使用</h2><p>如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者；如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身。</p><p>使用指针作为方法的接收者的理由：</p><ul><li>方法能够修改接收者指向的值。</li><li>避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。</li></ul><p>是使用值接收者还是指针接收者，不是由该方法是否修改了调用者（也就是接收者）来决定，而是应该基于该类型的<code>本质</code>。</p><p>如果类型具备“原始的本质”，也就是说它的成员都是由 Go 语言里内置的原始类型，如字符串，整型值等，那就定义值接收者类型的方法。像内置的引用类型，如 slice，map，interface，channel，这些类型比较特殊，声明他们的时候，实际上是创建了一个 <code>header</code>， 对于他们也是直接定义值接收者类型的方法。这样，调用函数时，是直接 copy 了这些类型的 <code>header</code>，而 <code>header</code> 本身就是为复制设计的。</p><p>如果类型具备非原始的本质，不能被安全地复制，这种类型总是应该被共享，那就定义指针接收者的方法。比如 go 源码里的文件结构体（struct File）就不应该被复制，应该只有一份<code>实体</code>。</p><p>这一段说的比较绕，大家可以去看《Go 语言实战》5.3 那一节。</p><h1 id="3-iface-和-eface-的区别是什么"><a href="#3-iface-和-eface-的区别是什么" class="headerlink" title="3. iface 和 eface 的区别是什么"></a>3. iface 和 eface 的区别是什么</h1><p><code>iface</code> 和 <code>eface</code> 都是 Go 中描述接口的底层结构体，区别在于 <code>iface</code> 描述的接口包含方法，而 <code>eface</code> 则是不包含任何方法的空接口：<code>interface{}</code>。</p><p>从源码层面看一下：</p><pre class=" language-golang"><code class="language-golang">type iface struct {    tab  *itab    data unsafe.Pointer}type itab struct {    inter  *interfacetype    _type  *_type    link   *itab    hash   uint32 // copy of _type.hash. Used for type switches.    bad    bool   // type does not implement interface    inhash bool   // has this itab been added to hash?    unused [2]byte    fun    [1]uintptr // variable sized}</code></pre><p><code>iface</code> 内部维护两个指针，<code>tab</code> 指向一个 <code>itab</code> 实体， 它表示接口的类型以及赋给这个接口的实体类型。<code>data</code> 则指向接口具体的值，一般而言是一个指向堆内存的指针。</p><p>再来仔细看一下 <code>itab</code> 结构体：<code>_type</code> 字段描述了实体的类型，包括内存对齐方式，大小等；<code>inter</code> 字段则描述了接口的类型。<code>fun</code> 字段放置和接口方法对应的具体数据类型的方法地址，实现接口调用方法的动态分派，一般在每次给接口赋值发生转换时会更新此表，或者直接拿缓存的 itab。</p><p>这里只会列出实体类型和接口相关的方法，实体类型的其他方法并不会出现在这里。如果你学过 C++ 的话，这里可以类比虚函数的概念。</p><p>另外，你可能会觉得奇怪，为什么 <code>fun</code> 数组的大小为 1，要是接口定义了多个方法可怎么办？实际上，这里存储的是第一个方法的函数指针，如果有更多的方法，在它之后的内存空间里继续存储。从汇编角度来看，通过增加地址就能获取到这些函数指针，没什么影响。顺便提一句，这些方法是按照函数名称的字典序进行排列的。</p><p>再看一下 <code>interfacetype</code> 类型，它描述的是接口的类型：</p><pre class=" language-golang"><code class="language-golang">type interfacetype struct {    typ     _type    pkgpath name    mhdr    []imethod}</code></pre><p>可以看到，它包装了 <code>_type</code> 类型，<code>_type</code> 实际上是描述 Go 语言中各种数据类型的结构体。我们注意到，这里还包含一个 <code>mhdr</code> 字段，表示接口所定义的函数列表， <code>pkgpath</code> 记录定义了接口的包名。</p><p>这里通过一张图来看下 <code>iface</code> 结构体的全貌：</p><p><img src="https://user-images.githubusercontent.com/7698088/56564826-82527600-65e1-11e9-956d-d98a212bc863.png" alt="iface 结构体全景"></p><p>接着来看一下 <code>eface</code> 的源码：</p><pre class=" language-golang"><code class="language-golang">type eface struct {    _type *_type    data  unsafe.Pointer}</code></pre><p>相比 <code>iface</code>，<code>eface</code> 就比较简单了。只维护了一个 <code>_type</code> 字段，表示空接口所承载的具体的实体类型。<code>data</code> 描述了具体的值。</p><p><img src="https://user-images.githubusercontent.com/7698088/56565105-318f4d00-65e2-11e9-96bd-4b2e192791dc.png" alt="eface 结构体全景"></p><p>我们来看个例子：</p><pre class=" language-golang"><code class="language-golang">package mainimport "fmt"func main() {    x := 200    var any interface{} = x    fmt.Println(any)    g := Gopher{"Go"}    var c coder = g    fmt.Println(c)}type coder interface {    code()    debug()}type Gopher struct {    language string}func (p Gopher) code() {    fmt.Printf("I am coding %s language\n", p.language)}func (p Gopher) debug() {    fmt.Printf("I am debuging %s language\n", p.language)}</code></pre><p>执行命令，打印出汇编语言：</p><pre class=" language-shell"><code class="language-shell">go tool compile -S ./src/main.go</code></pre><p>可以看到，main 函数里调用了两个函数：</p><pre class=" language-shell"><code class="language-shell">func convT2E64(t *_type, elem unsafe.Pointer) (e eface)func convT2I(tab *itab, elem unsafe.Pointer) (i iface)</code></pre><p>上面两个函数的参数和 <code>iface</code> 及 <code>eface</code> 结构体的字段是可以联系起来的：两个函数都是将参数<code>组装</code>一下，形成最终的接口。</p><p>作为补充，我们最后再来看下 <code>_type</code> 结构体：</p><pre class=" language-golang"><code class="language-golang">type _type struct {    // 类型大小    size       uintptr    ptrdata    uintptr    // 类型的 hash 值    hash       uint32    // 类型的 flag，和反射相关    tflag      tflag    // 内存对齐相关    align      uint8    fieldalign uint8    // 类型的编号，有bool, slice, struct 等等等等    kind       uint8    alg        *typeAlg    // gc 相关    gcdata    *byte    str       nameOff    ptrToThis typeOff}</code></pre><p>Go 语言各种数据类型都是在 <code>_type</code> 字段的基础上，增加一些额外的字段来进行管理的：</p><pre class=" language-golang"><code class="language-golang">type arraytype struct {    typ   _type    elem  *_type    slice *_type    len   uintptr}type chantype struct {    typ  _type    elem *_type    dir  uintptr}type slicetype struct {    typ  _type    elem *_type}type structtype struct {    typ     _type    pkgPath name    fields  []structfield}</code></pre><p>这些数据类型的结构体定义，是反射实现的基础。</p><h1 id="4-接口的动态类型和动态值"><a href="#4-接口的动态类型和动态值" class="headerlink" title="4. 接口的动态类型和动态值"></a>4. 接口的动态类型和动态值</h1><p>从源码里可以看到：<code>iface</code>包含两个字段：<code>tab</code> 是接口表指针，指向类型信息；<code>data</code> 是数据指针，则指向具体的数据。它们分别被称为<code>动态类型</code>和<code>动态值</code>。而接口值包括<code>动态类型</code>和<code>动态值</code>。</p><p>【引申1】接口类型和 <code>nil</code> 作比较</p><p>接口值的零值是指<code>动态类型</code>和<code>动态值</code>都为 <code>nil</code>。当仅且当这两部分的值都为 <code>nil</code> 的情况下，这个接口值就才会被认为 <code>接口值 == nil</code>。</p><p>来看个例子：</p><pre class=" language-golang"><code class="language-golang">package mainimport "fmt"type Coder interface {    code()}type Gopher struct {    name string}func (g Gopher) code() {    fmt.Printf("%s is coding\n", g.name)}func main() {    var c Coder    fmt.Println(c == nil)    fmt.Printf("c: %T, %v\n", c, c)    var g *Gopher    fmt.Println(g == nil)    c = g    fmt.Println(c == nil)    fmt.Printf("c: %T, %v\n", c, c)}</code></pre><p>输出：</p><pre class=" language-shell"><code class="language-shell">truec: <nil>, <nil>truefalsec: *main.Gopher, <nil></code></pre><p>一开始，<code>c</code> 的 动态类型和动态值都为 <code>nil</code>，<code>g</code> 也为 <code>nil</code>，当把 <code>g</code> 赋值给 <code>c</code> 后，<code>c</code> 的动态类型变成了 <code>*main.Gopher</code>，仅管 <code>c</code> 的动态值仍为 <code>nil</code>，但是当 <code>c</code> 和 <code>nil</code> 作比较的时候，结果就是 <code>false</code> 了。</p><p>【引申2】<br>来看一个例子，看一下它的输出：</p><pre class=" language-golang"><code class="language-golang">package mainimport "fmt"type MyError struct {}func (i MyError) Error() string {    return "MyError"}func main() {    err := Process()    fmt.Println(err)    fmt.Println(err == nil)}func Process() error {    var err *MyError = nil    return err}</code></pre><p>函数运行结果：</p><pre class=" language-shell"><code class="language-shell"><nil>false</code></pre><p>这里先定义了一个 <code>MyError</code> 结构体，实现了 <code>Error</code> 函数，也就实现了 <code>error</code> 接口。<code>Process</code> 函数返回了一个 <code>error</code> 接口，这块隐含了类型转换。所以，虽然它的值是 <code>nil</code>，其实它的类型是 <code>*MyError</code>，最后和 <code>nil</code> 比较的时候，结果为 <code>false</code>。</p><p>【引申3】如何打印出接口的动态类型和值？</p><p>直接看代码：</p><pre class=" language-golang"><code class="language-golang">package mainimport (    "unsafe"    "fmt")type iface struct {    itab, data uintptr}func main() {    var a interface{} = nil    var b interface{} = (*int)(nil)    x := 5    var c interface{} = (*int)(&x)    ia := *(*iface)(unsafe.Pointer(&a))    ib := *(*iface)(unsafe.Pointer(&b))    ic := *(*iface)(unsafe.Pointer(&c))    fmt.Println(ia, ib, ic)    fmt.Println(*(*int)(unsafe.Pointer(ic.data)))}</code></pre><p>代码里直接定义了一个 <code>iface</code> 结构体，用两个指针来描述 <code>itab</code> 和 <code>data</code>，之后将 a, b, c 在内存中的内容强制解释成我们自定义的 <code>iface</code>。最后就可以打印出动态类型和动态值的地址。</p><p>运行结果如下：</p><pre class=" language-shell"><code class="language-shell">{0 0} {17426912 0} {17426912 842350714568}5</code></pre><p>a 的动态类型和动态值的地址均为 0，也就是 nil；b 的动态类型和 c 的动态类型一致，都是 <code>*int</code>；最后，c 的动态值为 5。</p><h1 id="5-编译器自动检测类型是否实现接口"><a href="#5-编译器自动检测类型是否实现接口" class="headerlink" title="5. 编译器自动检测类型是否实现接口"></a>5. 编译器自动检测类型是否实现接口</h1><p>经常看到一些开源库里会有一些类似下面这种奇怪的用法：</p><pre class=" language-golang"><code class="language-golang">var _ io.Writer = (*myWriter)(nil)</code></pre><p>这时候会有点懵，不知道作者想要干什么，实际上这就是此问题的答案。编译器会由此检查 <code>*myWriter</code> 类型是否实现了 <code>io.Writer</code> 接口。</p><p>来看一个例子：</p><pre class=" language-golang"><code class="language-golang">package mainimport "io"type myWriter struct {}/*func (w myWriter) Write(p []byte) (n int, err error) {    return}*/func main() {    // 检查 *myWriter 类型是否实现了 io.Writer 接口    var _ io.Writer = (*myWriter)(nil)    // 检查 myWriter 类型是否实现了 io.Writer 接口    var _ io.Writer = myWriter{}}</code></pre><p>注释掉为 myWriter 定义的 Write 函数后，运行程序：</p><pre class=" language-golang"><code class="language-golang">src/main.go:14:6: cannot use (*myWriter)(nil) (type *myWriter) as type io.Writer in assignment:    *myWriter does not implement io.Writer (missing Write method)src/main.go:15:6: cannot use myWriter literal (type myWriter) as type io.Writer in assignment:    myWriter does not implement io.Writer (missing Write method)</code></pre><p>报错信息：*myWriter/myWriter 未实现 io.Writer 接口，也就是未实现 Write 方法。</p><p>解除注释后，运行程序不报错。</p><p>实际上，上述赋值语句会发生隐式地类型转换，在转换的过程中，编译器会检测等号右边的类型是否实现了等号左边接口所规定的函数。</p><p>总结一下，可通过在代码中添加类似如下的代码，用来检测类型是否实现了接口：</p><pre class=" language-golang"><code class="language-golang">var _ io.Writer = (*myWriter)(nil)var _ io.Writer = myWriter{}</code></pre><h1 id="6-接口的构造过程是怎样的"><a href="#6-接口的构造过程是怎样的" class="headerlink" title="6. 接口的构造过程是怎样的"></a>6. 接口的构造过程是怎样的</h1><p>我们已经看过了 <code>iface</code> 和 <code>eface</code> 的源码，知道 <code>iface</code> 最重要的是 <code>itab</code> 和 <code>_type</code>。</p><p>为了研究清楚接口是如何构造的，接下来我会拿起汇编的武器，还原背后的真相。</p><p>来看一个示例代码：</p><pre class=" language-golang"><code class="language-golang">package mainimport "fmt"type Person interface {    growUp()}type Student struct {    age int}func (p Student) growUp() {    p.age += 1    return}func main() {    var qcrao = Person(Student{age: 18})    fmt.Println(qcrao)}</code></pre><p>执行命令：</p><pre class=" language-shell"><code class="language-shell">go tool compile -S main.go</code></pre><p>得到 main 函数的汇编代码如下：</p><pre class=" language-asm"><code class="language-asm">0x0000 00000 (./src/main.go:30) TEXT    "".main(SB), $80-00x0000 00000 (./src/main.go:30) MOVQ    (TLS), CX0x0009 00009 (./src/main.go:30) CMPQ    SP, 16(CX)0x000d 00013 (./src/main.go:30) JLS     1570x0013 00019 (./src/main.go:30) SUBQ    $80, SP0x0017 00023 (./src/main.go:30) MOVQ    BP, 72(SP)0x001c 00028 (./src/main.go:30) LEAQ    72(SP), BP0x0021 00033 (./src/main.go:30) FUNCDATA$0, gclocals·69c1753bd5f81501d95132d08af04464(SB)0x0021 00033 (./src/main.go:30) FUNCDATA$1, gclocals·e226d4ae4a7cad8835311c6a4683c14f(SB)0x0021 00033 (./src/main.go:31) MOVQ    $18, ""..autotmp_1+48(SP)0x002a 00042 (./src/main.go:31) LEAQ    go.itab."".Student,"".Person(SB), AX0x0031 00049 (./src/main.go:31) MOVQ    AX, (SP)0x0035 00053 (./src/main.go:31) LEAQ    ""..autotmp_1+48(SP), AX0x003a 00058 (./src/main.go:31) MOVQ    AX, 8(SP)0x003f 00063 (./src/main.go:31) PCDATA  $0, $00x003f 00063 (./src/main.go:31) CALL    runtime.convT2I64(SB)0x0044 00068 (./src/main.go:31) MOVQ    24(SP), AX0x0049 00073 (./src/main.go:31) MOVQ    16(SP), CX0x004e 00078 (./src/main.go:33) TESTQ   CX, CX0x0051 00081 (./src/main.go:33) JEQ     870x0053 00083 (./src/main.go:33) MOVQ    8(CX), CX0x0057 00087 (./src/main.go:33) MOVQ    $0, ""..autotmp_2+56(SP)0x0060 00096 (./src/main.go:33) MOVQ    $0, ""..autotmp_2+64(SP)0x0069 00105 (./src/main.go:33) MOVQ    CX, ""..autotmp_2+56(SP)0x006e 00110 (./src/main.go:33) MOVQ    AX, ""..autotmp_2+64(SP)0x0073 00115 (./src/main.go:33) LEAQ    ""..autotmp_2+56(SP), AX0x0078 00120 (./src/main.go:33) MOVQ    AX, (SP)0x007c 00124 (./src/main.go:33) MOVQ    $1, 8(SP)0x0085 00133 (./src/main.go:33) MOVQ    $1, 16(SP)0x008e 00142 (./src/main.go:33) PCDATA  $0, $10x008e 00142 (./src/main.go:33) CALL    fmt.Println(SB)0x0093 00147 (./src/main.go:34) MOVQ    72(SP), BP0x0098 00152 (./src/main.go:34) ADDQ    $80, SP0x009c 00156 (./src/main.go:34) RET0x009d 00157 (./src/main.go:34) NOP0x009d 00157 (./src/main.go:30) PCDATA  $0, $-10x009d 00157 (./src/main.go:30) CALL    runtime.morestack_noctxt(SB)0x00a2 00162 (./src/main.go:30) JMP     0</code></pre><p>我们从第 10 行开始看，如果不理解前面几行汇编代码的话，可以回去看看公众号前面两篇文章，这里我就省略了。</p><table><thead><tr><th>汇编行数</th><th>操作</th></tr></thead><tbody><tr><td>10-14</td><td>构造调用 <code>runtime.convT2I64(SB)</code> 的参数</td></tr></tbody></table><p>我们来看下这个函数的参数形式：</p><pre class=" language-golang"><code class="language-golang">func convT2I64(tab *itab, elem unsafe.Pointer) (i iface) {    // ……}</code></pre><p><code>convT2I64</code> 会构造出一个 <code>inteface</code>，也就是我们的 <code>Person</code> 接口。</p><p>第一个参数的位置是 <code>(SP)</code>，这里被赋上了 <code>go.itab.&quot;&quot;.Student,&quot;&quot;.Person(SB)</code> 的地址。</p><p>我们从生成的汇编找到：</p><pre class=" language-asm"><code class="language-asm">go.itab."".Student,"".Person SNOPTRDATA dupok size=40        0x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00          0x0010 00 00 00 00 00 00 00 00 da 9f 20 d4                      rel 0+8 t=1 type."".Person+0        rel 8+8 t=1 type."".Student+0</code></pre><p><code>size=40</code> 大小为40字节，回顾一下：</p><pre class=" language-golang"><code class="language-golang">type itab struct {    inter  *interfacetype // 8字节    _type  *_type // 8字节    link   *itab // 8字节    hash   uint32 // 4字节    bad    bool   // 1字节    inhash bool   // 1字节    unused [2]byte // 2字节    fun    [1]uintptr // variable sized // 8字节}</code></pre><p>把每个字段的大小相加，<code>itab</code> 结构体的大小就是 40 字节。上面那一串数字实际上是 <code>itab</code> 序列化后的内容，注意到大部分数字是 0，从 24 字节开始的 4 个字节 <code>da 9f 20 d4</code> 实际上是 <code>itab</code> 的 <code>hash</code> 值，这在判断两个类型是否相同的时候会用到。</p><p>下面两行是链接指令，简单说就是将所有源文件综合起来，给每个符号赋予一个全局的位置值。这里的意思也比较明确：前8个字节最终存储的是 <code>type.&quot;&quot;.Person</code> 的地址，对应 <code>itab</code> 里的 <code>inter</code> 字段，表示接口类型；8-16 字节最终存储的是 <code>type.&quot;&quot;.Student</code> 的地址，对应 <code>itab</code> 里 <code>_type</code> 字段，表示具体类型。</p><p>第二个参数就比较简单了，它就是数字 <code>18</code> 的地址，这也是初始化 <code>Student</code> 结构体的时候会用到。</p><table><thead><tr><th>汇编行数</th><th>操作</th></tr></thead><tbody><tr><td>15</td><td>调用 <code>runtime.convT2I64(SB)</code></td></tr></tbody></table><p>具体看下代码：</p><pre class=" language-golang"><code class="language-golang">func convT2I64(tab *itab, elem unsafe.Pointer) (i iface) {    t := tab._type    //...    var x unsafe.Pointer    if *(*uint64)(elem) == 0 {        x = unsafe.Pointer(&zeroVal[0])    } else {        x = mallocgc(8, t, false)        *(*uint64)(x) = *(*uint64)(elem)    }    i.tab = tab    i.data = x    return}</code></pre><p>这块代码比较简单，把 <code>tab</code> 赋给了 <code>iface</code> 的 <code>tab</code> 字段；<code>data</code> 部分则是在堆上申请了一块内存，然后将 <code>elem</code> 指向的 <code>18</code> 拷贝过去。这样 <code>iface</code> 就组装好了。</p><table><thead><tr><th>汇编行数</th><th>操作</th></tr></thead><tbody><tr><td>17</td><td>把 <code>i.tab</code> 赋给 <code>CX</code></td></tr><tr><td>18</td><td>把 <code>i.data</code> 赋给 <code>AX</code></td></tr><tr><td>19-21</td><td>检测 <code>i.tab</code> 是否是 nil，如果不是的话，把 CX 移动 8 个字节，也就是把 <code>itab</code> 的 <code>_type</code> 字段赋给了 CX，这也是接口的实体类型，最终要作为 <code>fmt.Println</code> 函数的参数</td></tr></tbody></table><p>后面，就是调用 <code>fmt.Println</code> 函数及之前的参数准备工作了，不再赘述。</p><p>这样，我们就把一个 <code>interface</code> 的构造过程说完了。</p><p>【引申1】<br>如何打印出接口类型的 <code>Hash</code> 值？</p><p>这里参考曹大神翻译的一篇文章，参考资料里会写上。具体做法如下：</p><pre class=" language-golang"><code class="language-golang">type iface struct {    tab  *itab    data unsafe.Pointer}type itab struct {    inter uintptr    _type uintptr    link uintptr    hash  uint32    _     [4]byte    fun   [1]uintptr}func main() {    var qcrao = Person(Student{age: 18})    iface := (*iface)(unsafe.Pointer(&qcrao))    fmt.Printf("iface.tab.hash = %#x\n", iface.tab.hash)}</code></pre><p>定义了一个<code>山寨版</code>的 <code>iface</code> 和 <code>itab</code>，说它<code>山寨</code>是因为 <code>itab</code> 里的一些关键数据结构都不具体展开了，比如 <code>_type</code>，对比一下正宗的定义就可以发现，但是<code>山寨版</code>依然能工作，因为 <code>_type</code> 就是一个指针而已嘛。</p><p>在 <code>main</code> 函数里，先构造出一个接口对象 <code>qcrao</code>，然后强制类型转换，最后读取出 <code>hash</code> 值，非常妙！你也可以自己动手试一下。</p><p>运行结果：</p><pre class=" language-shell"><code class="language-shell">iface.tab.hash = 0xd4209fda</code></pre><p>值得一提的是，构造接口 <code>qcrao</code> 的时候，即使我把 <code>age</code> 写成其他值，得到的 <code>hash</code> 值依然不变的，这应该是可以预料的，<code>hash</code> 值只和他的字段、方法相关。</p><h1 id="7-类型转换和断言的区别"><a href="#7-类型转换和断言的区别" class="headerlink" title="7. 类型转换和断言的区别"></a>7. 类型转换和断言的区别</h1><p>我们知道，Go 语言中不允许隐式类型转换，也就是说 <code>=</code> 两边，不允许出现类型不相同的变量。</p><p><code>类型转换</code>、<code>类型断言</code>本质都是把一个类型转换成另外一个类型。不同之处在于，类型断言是对接口变量进行的操作。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>对于<code>类型转换</code>而言，转换前后的两个类型要相互兼容才行。类型转换的语法为：</p><blockquote><p>&lt;结果类型&gt; := &lt;目标类型&gt; ( &lt;表达式&gt; )</p></blockquote><pre class=" language-golang"><code class="language-golang">package mainimport "fmt"func main() {    var i int = 9    var f float64    f = float64(i)    fmt.Printf("%T, %v\n", f, f)    f = 10.8    a := int(f)    fmt.Printf("%T, %v\n", a, a)    // s := []int(i)}</code></pre><p>上面的代码里，我定义了一个 <code>int</code> 型和 <code>float64</code> 型的变量，尝试在它们之前相互转换，结果是成功的：<code>int</code> 型和 <code>float64</code> 是相互兼容的。</p><p>如果我把最后一行代码的注释去掉，编译器会报告类型不兼容的错误：</p><pre class=" language-shell"><code class="language-shell">cannot convert i (type int) to type []int</code></pre><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>前面说过，因为空接口 <code>interface{}</code> 没有定义任何函数，因此 Go 中所有类型都实现了空接口。当一个函数的形参是 <code>interface{}</code>，那么在函数中，需要对形参进行断言，从而得到它的真实类型。</p><p>断言的语法为：</p><blockquote><p>&lt;目标类型的值&gt;，&lt;布尔参数&gt; := &lt;表达式&gt;.( 目标类型 ) // 安全类型断言<br>&lt;目标类型的值&gt; := &lt;表达式&gt;.( 目标类型 )　　//非安全类型断言</p></blockquote><p>类型转换和类型断言有些相似，不同之处，在于类型断言是对接口进行的操作。</p><p>还是来看一个简短的例子：</p><pre class=" language-golang"><code class="language-golang">package mainimport "fmt"type Student struct {    Name string    Age int}func main() {    var i interface{} = new(Student)    s := i.(Student)    fmt.Println(s)}</code></pre><p>运行一下：</p><pre class=" language-shell"><code class="language-shell">panic: interface conversion: interface {} is *main.Student, not main.Student</code></pre><p>直接 <code>panic</code> 了，这是因为 <code>i</code> 是 <code>*Student</code> 类型，并非 <code>Student</code> 类型，断言失败。这里直接发生了 <code>panic</code>，线上代码可能并不适合这样做，可以采用“安全断言”的语法：</p><pre class=" language-golang"><code class="language-golang">func main() {    var i interface{} = new(Student)    s, ok := i.(Student)    if ok {        fmt.Println(s)    }}</code></pre><p>这样，即使断言失败也不会 <code>panic</code>。</p><p>断言其实还有另一种形式，就是用在利用 <code>switch</code> 语句判断接口的类型。每一个 <code>case</code> 会被顺序地考虑。当命中一个 <code>case</code> 时，就会执行 <code>case</code> 中的语句，因此 <code>case</code> 语句的顺序是很重要的，因为很有可能会有多个 <code>case</code> 匹配的情况。</p><p>代码示例如下：</p><pre class=" language-golang"><code class="language-golang">func main() {    //var i interface{} = new(Student)    //var i interface{} = (*Student)(nil)    var i interface{}    fmt.Printf("%p %v\n", &i, i)    judge(i)}func judge(v interface{}) {    fmt.Printf("%p %v\n", &v, v)    switch v := v.(type) {    case nil:        fmt.Printf("%p %v\n", &v, v)        fmt.Printf("nil type[%T] %v\n", v, v)    case Student:        fmt.Printf("%p %v\n", &v, v)        fmt.Printf("Student type[%T] %v\n", v, v)    case *Student:        fmt.Printf("%p %v\n", &v, v)        fmt.Printf("*Student type[%T] %v\n", v, v)    default:        fmt.Printf("%p %v\n", &v, v)        fmt.Printf("unknow\n")    }}type Student struct {    Name string    Age int}</code></pre><p><code>main</code> 函数里有三行不同的声明，每次运行一行，注释另外两行，得到三组运行结果：</p><pre class=" language-shell"><code class="language-shell">// --- var i interface{} = new(Student)0xc4200701b0 [Name: ], [Age: 0]0xc4200701d0 [Name: ], [Age: 0]0xc420080020 [Name: ], [Age: 0]*Student type[*main.Student] [Name: ], [Age: 0]// --- var i interface{} = (*Student)(nil)0xc42000e1d0 <nil>0xc42000e1f0 <nil>0xc42000c030 <nil>*Student type[*main.Student] <nil>// --- var i interface{}0xc42000e1d0 <nil>0xc42000e1e0 <nil>0xc42000e1f0 <nil>nil type[<nil>] <nil></code></pre><p>对于第一行语句：</p><pre class=" language-golang"><code class="language-golang">var i interface{} = new(Student)</code></pre><p><code>i</code> 是一个 <code>*Student</code> 类型，匹配上第三个 case，从打印的三个地址来看，这三处的变量实际上都是不一样的。在 <code>main</code> 函数里有一个局部变量 <code>i</code>；调用函数时，实际上是复制了一份参数，因此函数里又有一个变量 <code>v</code>，它是 <code>i</code> 的拷贝；断言之后，又生成了一份新的拷贝。所以最终打印的三个变量的地址都不一样。</p><p>对于第二行语句：</p><pre class=" language-golang"><code class="language-golang">var i interface{} = (*Student)(nil)</code></pre><p>这里想说明的其实是 <code>i</code> 在这里动态类型是 <code>(*Student)</code>, 数据为 <code>nil</code>，它的类型并不是 <code>nil</code>，它与 <code>nil</code> 作比较的时候，得到的结果也是 <code>false</code>。</p><p>最后一行语句：</p><pre class=" language-golang"><code class="language-golang">var i interface{}</code></pre><p>这回 <code>i</code> 才是 <code>nil</code> 类型。</p><p>【引申1】<br><code>fmt.Println</code> 函数的参数是 <code>interface</code>。对于内置类型，函数内部会用穷举法，得出它的真实类型，然后转换为字符串打印。而对于自定义类型，首先确定该类型是否实现了 <code>String()</code> 方法，如果实现了，则直接打印输出 <code>String()</code> 方法的结果；否则，会通过反射来遍历对象的成员进行打印。</p><p>再来看一个简短的例子，比较简单，不要紧张：</p><pre class=" language-golang"><code class="language-golang">package mainimport "fmt"type Student struct {    Name string    Age int}func main() {    var s = Student{        Name: "qcrao",        Age: 18,    }    fmt.Println(s)}</code></pre><p>因为 <code>Student</code> 结构体没有实现 <code>String()</code> 方法，所以 <code>fmt.Println</code> 会利用反射挨个打印成员变量：</p><pre class=" language-shell"><code class="language-shell">{qcrao 18}</code></pre><p>增加一个 <code>String()</code> 方法的实现：</p><pre class=" language-golang"><code class="language-golang">func (s Student) String() string {    return fmt.Sprintf("[Name: %s], [Age: %d]", s.Name, s.Age)}</code></pre><p>打印结果：</p><pre class=" language-shell"><code class="language-shell">[Name: qcrao], [Age: 18]</code></pre><p>按照我们自定义的方法来打印了。</p><p>【引申2】<br>针对上面的例子，如果改一下：</p><pre class=" language-goalng"><code class="language-goalng">func (s *Student) String() string {    return fmt.Sprintf("[Name: %s], [Age: %d]", s.Name, s.Age)}</code></pre><p>注意看两个函数的接受者类型不同，现在 <code>Student</code> 结构体只有一个接受者类型为 <code>指针类型</code> 的 <code>String()</code> 函数，打印结果：</p><pre class=" language-shell"><code class="language-shell">{qcrao 18}</code></pre><p>为什么？</p><blockquote><p>类型 <code>T</code> 只有接受者是 <code>T</code> 的方法；而类型 <code>*T</code> 拥有接受者是 <code>T</code> 和 <code>*T</code> 的方法。语法上 <code>T</code> 能直接调 <code>*T</code> 的方法仅仅是 <code>Go</code> 的语法糖。</p></blockquote><p>所以， <code>Student</code> 结构体定义了接受者类型是值类型的 <code>String()</code> 方法时，通过</p><pre class=" language-golang"><code class="language-golang">fmt.Println(s)fmt.Println(&s)</code></pre><p>均可以按照自定义的格式来打印。</p><p>如果 <code>Student</code> 结构体定义了接受者类型是指针类型的 <code>String()</code> 方法时，只有通过</p><pre class=" language-golang"><code class="language-golang">fmt.Println(&s)</code></pre><p>才能按照自定义的格式打印。</p><h1 id="8-接口转换的原理"><a href="#8-接口转换的原理" class="headerlink" title="8. 接口转换的原理"></a>8. 接口转换的原理</h1><p>通过前面提到的 <code>iface</code> 的源码可以看到，实际上它包含接口的类型 <code>interfacetype</code> 和 实体类型的类型 <code>_type</code>，这两者都是 <code>iface</code> 的字段 <code>itab</code> 的成员。也就是说生成一个 <code>itab</code> 同时需要接口的类型和实体的类型。</p><blockquote><p>&lt;interface 类型， 实体类型&gt; -&gt;itable</p></blockquote><p>当判定一种类型是否满足某个接口时，Go 使用类型的方法集和接口所需要的方法集进行匹配，如果类型的方法集完全包含接口的方法集，则可认为该类型实现了该接口。</p><p>例如某类型有 <code>m</code> 个方法，某接口有 <code>n</code> 个方法，则很容易知道这种判定的时间复杂度为 <code>O(mn)</code>，Go 会对方法集的函数按照函数名的字典序进行排序，所以实际的时间复杂度为 <code>O(m+n)</code>。</p><p>这里我们来探索将一个接口转换给另外一个接口背后的原理，当然，能转换的原因必然是类型兼容。</p><p>直接来看一个例子：</p><pre class=" language-golang"><code class="language-golang">package mainimport "fmt"type coder interface {    code()    run()}type runner interface {    run()}type Gopher struct {    language string}func (g Gopher) code() {    return}func (g Gopher) run() {    return}func main() {    var c coder = Gopher{}    var r runner    r = c    fmt.Println(c, r)}</code></pre><p>简单解释下上述代码：定义了两个 <code>interface</code>: <code>coder</code> 和 <code>runner</code>。定义了一个实体类型 <code>Gopher</code>，类型 <code>Gopher</code> 实现了两个方法，分别是 <code>run()</code> 和 <code>code()</code>。main 函数里定义了一个接口变量 <code>c</code>，绑定了一个 <code>Gopher</code> 对象，之后将 <code>c</code> 赋值给另外一个接口变量 <code>r</code> 。赋值成功的原因是 <code>c</code> 中包含 <code>run()</code> 方法。这样，两个接口变量完成了转换。</p><p>执行命令：</p><pre class=" language-shell"><code class="language-shell">go tool compile -S ./src/main.go</code></pre><p>得到 main 函数的汇编命令，可以看到： <code>r = c</code> 这一行语句实际上是调用了 <code>runtime.convI2I(SB)</code>，也就是 <code>convI2I</code> 函数，从函数名来看，就是将一个 <code>interface</code> 转换成另外一个 <code>interface</code>，看下它的源代码：</p><pre class=" language-golang"><code class="language-golang">func convI2I(inter *interfacetype, i iface) (r iface) {    tab := i.tab    if tab == nil {        return    }    if tab.inter == inter {        r.tab = tab        r.data = i.data        return    }    r.tab = getitab(inter, tab._type, false)    r.data = i.data    return}</code></pre><p>代码比较简单，函数参数 <code>inter</code> 表示接口类型，<code>i</code> 表示绑定了实体类型的接口，<code>r</code> 则表示接口转换了之后的新的 <code>iface</code>。通过前面的分析，我们又知道， <code>iface</code> 是由 <code>tab</code> 和 <code>data</code> 两个字段组成。所以，实际上 <code>convI2I</code> 函数真正要做的事，找到新 <code>interface</code> 的 <code>tab</code> 和 <code>data</code>，就大功告成了。</p><p>我们还知道，<code>tab</code> 是由接口类型 <code>interfacetype</code> 和 实体类型 <code>_type</code>。所以最关键的语句是 <code>r.tab = getitab(inter, tab._type, false)</code>。</p><p>因此，重点来看下 <code>getitab</code> 函数的源码，只看关键的地方：</p><pre class=" language-golang"><code class="language-golang">func getitab(inter *interfacetype, typ *_type, canfail bool) *itab {    // ……    // 根据 inter, typ 计算出 hash 值    h := itabhash(inter, typ)    // look twice - once without lock, once with.    // common case will be no lock contention.    var m *itab    var locked int    for locked = 0; locked < 2; locked++ {        if locked != 0 {            lock(&ifaceLock)        }        // 遍历哈希表的一个 slot        for m = (*itab)(atomic.Loadp(unsafe.Pointer(&hash[h]))); m != nil; m = m.link {            // 如果在 hash 表中已经找到了 itab（inter 和 typ 指针都相同）            if m.inter == inter && m._type == typ {                // ……                if locked != 0 {                    unlock(&ifaceLock)                }                return m            }        }    }    // 在 hash 表中没有找到 itab，那么新生成一个 itab    m = (*itab)(persistentalloc(unsafe.Sizeof(itab{})+uintptr(len(inter.mhdr)-1)*sys.PtrSize, 0, &memstats.other_sys))    m.inter = inter    m._type = typ    // 添加到全局的 hash 表中    additab(m, true, canfail)    unlock(&ifaceLock)    if m.bad {        return nil    }    return m}</code></pre><p>简单总结一下：getitab 函数会根据 <code>interfacetype</code> 和 <code>_type</code> 去全局的 itab 哈希表中查找，如果能找到，则直接返回；否则，会根据给定的 <code>interfacetype</code> 和 <code>_type</code> 新生成一个 <code>itab</code>，并插入到 itab 哈希表，这样下一次就可以直接拿到 <code>itab</code>。</p><p>这里查找了两次，并且第二次上锁了，这是因为如果第一次没找到，在第二次仍然没有找到相应的 <code>itab</code> 的情况下，需要新生成一个，并且写入哈希表，因此需要加锁。这样，其他协程在查找相同的 <code>itab</code> 并且也没有找到时，第二次查找时，会被挂住，之后，就会查到第一个协程写入哈希表的 <code>itab</code>。 </p><p>再来看一下 <code>additab</code> 函数的代码：</p><pre class=" language-golang"><code class="language-golang">// 检查 _type 是否符合 interface_type 并且创建对应的 itab 结构体 将其放到 hash 表中func additab(m *itab, locked, canfail bool) {    inter := m.inter    typ := m._type    x := typ.uncommon()    // both inter and typ have method sorted by name,    // and interface names are unique,    // so can iterate over both in lock step;    // the loop is O(ni+nt) not O(ni*nt).    //     // inter 和 typ 的方法都按方法名称进行了排序    // 并且方法名都是唯一的。所以循环的次数是固定的    // 只用循环 O(ni+nt)，而非 O(ni*nt)    ni := len(inter.mhdr)    nt := int(x.mcount)    xmhdr := (*[1 << 16]method)(add(unsafe.Pointer(x), uintptr(x.moff)))[:nt:nt]    j := 0    for k := 0; k < ni; k++ {        i := &inter.mhdr[k]        itype := inter.typ.typeOff(i.ityp)        name := inter.typ.nameOff(i.name)        iname := name.name()        ipkg := name.pkgPath()        if ipkg == "" {            ipkg = inter.pkgpath.name()        }        for ; j < nt; j++ {            t := &xmhdr[j]            tname := typ.nameOff(t.name)            // 检查方法名字是否一致            if typ.typeOff(t.mtyp) == itype && tname.name() == iname {                pkgPath := tname.pkgPath()                if pkgPath == "" {                    pkgPath = typ.nameOff(x.pkgpath).name()                }                if tname.isExported() || pkgPath == ipkg {                    if m != nil {                        // 获取函数地址，并加入到itab.fun数组中                        ifn := typ.textOff(t.ifn)                        *(*unsafe.Pointer)(add(unsafe.Pointer(&m.fun[0]), uintptr(k)*sys.PtrSize)) = ifn                    }                    goto nextimethod                }            }        }        // ……        m.bad = true        break    nextimethod:    }    if !locked {        throw("invalid itab locking")    }    // 计算 hash 值    h := itabhash(inter, typ)    // 加到Hash Slot链表中    m.link = hash[h]    m.inhash = true    atomicstorep(unsafe.Pointer(&hash[h]), unsafe.Pointer(m))}</code></pre><p><code>additab</code> 会检查 <code>itab</code> 持有的 <code>interfacetype</code> 和 <code>_type</code> 是否符合，就是看 <code>_type</code> 是否完全实现了 <code>interfacetype</code> 的方法，也就是看两者的方法列表重叠的部分就是 <code>interfacetype</code> 所持有的方法列表。注意到其中有一个双层循环，乍一看，循环次数是 <code>ni * nt</code>，但由于两者的函数列表都按照函数名称进行了排序，因此最终只执行了 <code>ni + nt</code> 次，代码里通过一个小技巧来实现：第二层循环并没有从 0 开始计数，而是从上一次遍历到的位置开始。</p><p>求 hash 值的函数比较简单：</p><pre class=" language-golang"><code class="language-golang">func itabhash(inter *interfacetype, typ *_type) uint32 {    h := inter.typ.hash    h += 17 * typ.hash    return h % hashSize}</code></pre><p><code>hashSize</code> 的值是 1009。</p><p>更一般的，当把实体类型赋值给接口的时候，会调用 <code>conv</code> 系列函数，例如空接口调用 <code>convT2E</code> 系列、非空接口调用 <code>convT2I</code> 系列。这些函数比较相似：</p><blockquote><ol><li>具体类型转空接口时，_type 字段直接复制源类型的 _type；调用 mallocgc 获得一块新内存，把值复制进去，data 再指向这块新内存。</li><li>具体类型转非空接口时，入参 tab 是编译器在编译阶段预先生成好的，新接口 tab 字段直接指向入参 tab 指向的 itab；调用 mallocgc 获得一块新内存，把值复制进去，data 再指向这块新内存。</li><li>而对于接口转接口，itab 调用 getitab 函数获取。只用生成一次，之后直接从 hash 表中获取。</li></ol></blockquote><h1 id="9-如何用-interface-实现多态"><a href="#9-如何用-interface-实现多态" class="headerlink" title="9. 如何用 interface 实现多态"></a>9. 如何用 interface 实现多态</h1><p><code>Go</code> 语言并没有设计诸如虚函数、纯虚函数、继承、多重继承等概念，但它通过接口却非常优雅地支持了面向对象的特性。</p><p>多态是一种运行期的行为，它有以下几个特点：</p><blockquote><ol><li>一种类型具有多种类型的能力</li><li>允许不同的对象对同一消息做出灵活的反应</li><li>以一种通用的方式对待个使用的对象</li><li>非动态语言必须通过继承和接口的方式来实现</li></ol></blockquote><p>看一个实现了多态的代码例子：</p><pre class=" language-golang"><code class="language-golang">package mainimport "fmt"func main() {    qcrao := Student{age: 18}    whatJob(&qcrao)    growUp(&qcrao)    fmt.Println(qcrao)    stefno := Programmer{age: 100}    whatJob(stefno)    growUp(stefno)    fmt.Println(stefno)}func whatJob(p Person) {    p.job()}func growUp(p Person) {    p.growUp()}type Person interface {    job()    growUp()}type Student struct {    age int}func (p Student) job() {    fmt.Println("I am a student.")    return}func (p *Student) growUp() {    p.age += 1    return}type Programmer struct {    age int}func (p Programmer) job() {    fmt.Println("I am a programmer.")    return}func (p Programmer) growUp() {    // 程序员老得太快 ^_^    p.age += 10    return}</code></pre><p>代码里先定义了 1 个 <code>Person</code> 接口，包含两个函数：</p><pre class=" language-golang"><code class="language-golang">job()growUp()</code></pre><p>然后，又定义了 2 个结构体，<code>Student</code> 和 <code>Programmer</code>，同时，类型 <code>*Student</code>、<code>Programmer</code> 实现了 <code>Person</code> 接口定义的两个函数。注意，<code>*Student</code> 类型实现了接口， <code>Student</code> 类型却没有。</p><p>之后，我又定义了函数参数是 <code>Person</code> 接口的两个函数：</p><pre class=" language-golang"><code class="language-golang">func whatJob(p Person)func growUp(p Person)</code></pre><p><code>main</code> 函数里先生成 <code>Student</code> 和 <code>Programmer</code> 的对象，再将它们分别传入到函数 <code>whatJob</code> 和 <code>growUp</code>。函数中，直接调用接口函数，实际执行的时候是看最终传入的实体类型是什么，调用的是实体类型实现的函数。于是，不同对象针对同一消息就有多种表现，<code>多态</code>就实现了。</p><p>更深入一点来说的话，在函数 <code>whatJob()</code> 或者 <code>growUp()</code> 内部，接口 <code>person</code> 绑定了实体类型 <code>*Student</code> 或者 <code>Programmer</code>。根据前面分析的 <code>iface</code> 源码，这里会直接调用 <code>fun</code> 里保存的函数，类似于： <code>s.tab-&gt;fun[0]</code>，而因为 <code>fun</code> 数组里保存的是实体类型实现的函数，所以当函数传入不同的实体类型时，调用的实际上是不同的函数实现，从而实现多态。</p><p>运行一下代码：</p><pre class=" language-shell"><code class="language-shell">I am a student.{19}I am a programmer.{100}</code></pre><h1 id="10-Go-接口与-C-接口有何异同"><a href="#10-Go-接口与-C-接口有何异同" class="headerlink" title="10. Go 接口与 C++ 接口有何异同"></a>10. Go 接口与 C++ 接口有何异同</h1><p>接口定义了一种规范，描述了类的行为和功能，而不做具体实现。</p><p>C++ 的接口是使用抽象类来实现的，如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “= 0” 来指定的。例如：</p><pre class=" language-C++"><code class="language-C++">class Shape{   public:      // 纯虚函数      virtual double getArea() = 0;   private:      string name;      // 名称};</code></pre><p>设计抽象类的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。</p><p>派生类需要明确地声明它继承自基类，并且需要实现基类中所有的纯虚函数。</p><p>C++ 定义接口的方式称为“侵入式”，而 Go 采用的是 “非侵入式”，不需要显式声明，只需要实现接口定义的函数，编译器自动会识别。</p><p>C++ 和 Go 在定义接口方式上的不同，也导致了底层实现上的不同。C++ 通过虚函数表来实现基类调用派生类的函数；而 Go 通过 <code>itab</code> 中的 <code>fun</code> 字段来实现接口变量调用实体类型的函数。C++ 中的虚函数表是在编译期生成的；而 Go 的 <code>itab</code> 中的 <code>fun</code> 字段是在运行期间动态生成的。原因在于，Go 中实体类型可能会无意中实现 N 多接口，很多接口并不是本来需要的，所以不能为类型实现的所有接口都生成一个 <code>itab</code>， 这也是“非侵入式”带来的影响；这在 C++ 中是不存在的，因为派生需要显示声明它继承自哪个基类。</p><p><img src="https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png" alt="QR"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【包含反射、接口等源码分析】<a href="https://zhuanlan.zhihu.com/p/27055513" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27055513</a></p><p>【虚函数表和C++的区别】<a href="https://mp.weixin.qq.com/s/jU9HeR1tOyh-ME5iEYM5-Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/jU9HeR1tOyh-ME5iEYM5-Q</a></p><p>【具体类型向接口赋值】<a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/07.2.html" target="_blank" rel="noopener">https://tiancaiamao.gitbooks.io/go-internals/content/zh/07.2.html</a></p><p>【Go夜读群的讨论】<a href="https://github.com/developer-learning/reading-go/blob/master/content/discuss/2018-08-30-understanding-go-interfaces.md">https://github.com/developer-learning/reading-go/blob/master/content/discuss/2018-08-30-understanding-go-interfaces.md</a></p><p>【廖雪峰 鸭子类型】<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431865288798deef438d865e4c2985acff7e9fad15e3000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431865288798deef438d865e4c2985acff7e9fad15e3000</a></p><p>【值类型和指针类型，iface源码】<a href="https://www.jianshu.com/p/5f8ecbe4f6af" target="_blank" rel="noopener">https://www.jianshu.com/p/5f8ecbe4f6af</a></p><p>【总体说明itab的生成方式、作用】<a href="http://www.codeceo.com/article/go-interface.html" target="_blank" rel="noopener">http://www.codeceo.com/article/go-interface.html</a></p><p>【conv系列函数的作用】<a href="https://blog.csdn.net/zhonglinzhang/article/details/85772336" target="_blank" rel="noopener">https://blog.csdn.net/zhonglinzhang/article/details/85772336</a></p><p>【convI2I itab作用】<a href="https://www.jianshu.com/p/a5e99b1d50b1" target="_blank" rel="noopener">https://www.jianshu.com/p/a5e99b1d50b1</a></p><p>【interface 源码解读 很不错 包含反射】<a href="http://wudaijun.com/2018/01/go-interface-implement/" target="_blank" rel="noopener">http://wudaijun.com/2018/01/go-interface-implement/</a></p><p>【what why how思路来写interface】<a href="http://legendtkl.com/2017/06/12/understanding-golang-interface/" target="_blank" rel="noopener">http://legendtkl.com/2017/06/12/understanding-golang-interface/</a></p><p>【有汇编分析，不错】<a href="http://legendtkl.com/2017/07/01/golang-interface-implement/" target="_blank" rel="noopener">http://legendtkl.com/2017/07/01/golang-interface-implement/</a></p><p>【第一幅图可以参考 gdb调试】<a href="https://www.do1618.com/archives/797/golang-interface%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">https://www.do1618.com/archives/797/golang-interface%E5%88%86%E6%9E%90/</a></p><p>【类型转换和断言】<a href="https://my.oschina.net/goal/blog/194308" target="_blank" rel="noopener">https://my.oschina.net/goal/blog/194308</a></p><p>【interface 和 nil】<a href="https://my.oschina.net/goal/blog/194233" target="_blank" rel="noopener">https://my.oschina.net/goal/blog/194233</a></p><p>【函数和方法】<a href="https://www.jianshu.com/p/5376e15966b3" target="_blank" rel="noopener">https://www.jianshu.com/p/5376e15966b3</a></p><p>【反射】<a href="https://flycode.co/archives/267357" target="_blank" rel="noopener">https://flycode.co/archives/267357</a></p><p>【接口特点列表】<a href="https://segmentfault.com/a/1190000011451232" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011451232</a></p><p>【interface 全面介绍，包含C++对比】<a href="https://www.jianshu.com/p/b38b1719636e" target="_blank" rel="noopener">https://www.jianshu.com/p/b38b1719636e</a></p><p>【Go四十二章经 interface】<a href="https://github.com/ffhelicopter/Go42/blob/master/content/42_19_interface.md">https://github.com/ffhelicopter/Go42/blob/master/content/42_19_interface.md</a></p><p>【对Go接口的反驳，有说到接口的定义】<a href="http://blog.zhaojie.me/2013/04/why-i-dont-like-go-style-interface-or-structural-typing.html" target="_blank" rel="noopener">http://blog.zhaojie.me/2013/04/why-i-dont-like-go-style-interface-or-structural-typing.html</a></p><p>【gopher 接口】<a href="http://fuxiaohei.me/2017/4/22/gopherchina-2017.html" target="_blank" rel="noopener">http://fuxiaohei.me/2017/4/22/gopherchina-2017.html</a></p><p>【译文 还不错】<a href="https://mp.weixin.qq.com/s/tBg8D1qXHqBr3r7oRt6iGA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/tBg8D1qXHqBr3r7oRt6iGA</a></p><p>【infoQ 文章】<a href="https://www.infoq.cn/article/go-interface-talk" target="_blank" rel="noopener">https://www.infoq.cn/article/go-interface-talk</a></p><p>【Go接口详解】<a href="https://zhuanlan.zhihu.com/p/27055513" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27055513</a></p><p>【Go interface】<a href="https://sanyuesha.com/2017/07/22/how-to-understand-go-interface/" target="_blank" rel="noopener">https://sanyuesha.com/2017/07/22/how-to-understand-go-interface/</a></p><p>【getitab源码说明】<a href="https://www.twblogs.net/a/5c245d59bd9eee16b3db561d" target="_blank" rel="noopener">https://www.twblogs.net/a/5c245d59bd9eee16b3db561d</a></p><p>【浅显易懂】<a href="https://yami.io/golang-interface/" target="_blank" rel="noopener">https://yami.io/golang-interface/</a></p><p>【golang io包的妙用】<a href="https://www.jianshu.com/p/8c33f7c84509" target="_blank" rel="noopener">https://www.jianshu.com/p/8c33f7c84509</a></p><p>【探索C++与Go的接口底层实现】<a href="https://www.jianshu.com/p/073c09a05da7" target="_blank" rel="noopener">https://www.jianshu.com/p/073c09a05da7</a><br><a href="https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/README.md">https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/README.md</a></p><p>【汇编层面】<a href="http://xargin.com/go-and-interface/" target="_blank" rel="noopener">http://xargin.com/go-and-interface/</a></p><p>【有图】<a href="https://i6448038.github.io/2018/10/01/Golang-interface/" target="_blank" rel="noopener">https://i6448038.github.io/2018/10/01/Golang-interface/</a></p><p>【图】<a href="https://mp.weixin.qq.com/s/px9BRQrTCLX6BbvXJbysCA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/px9BRQrTCLX6BbvXJbysCA</a></p><p>【英文开源书】<a href="https://github.com/cch123/go-internals/blob/master/chapter2_interfaces/README.md">https://github.com/cch123/go-internals/blob/master/chapter2_interfaces/README.md</a></p><p>【曹大的翻译】<a href="http://xargin.com/go-and-interface/" target="_blank" rel="noopener">http://xargin.com/go-and-interface/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这次文章依然很长，基本上涵盖了 &lt;code&gt;interface&lt;/code&gt; 的方方面面，有例子，有源码分析，有汇编分析，前前后后写了 20 多天。洋洋洒洒，长篇大论，依然有些东西没有涉及到，比如文章里没有写到&lt;code&gt;反射&lt;/code&gt;，当然，后面会单独写一篇关于&lt;co
      
    
    </summary>
    
      <category term="编程语言" scheme="https://github.com/qcrao/qcrao.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="golang" scheme="https://github.com/qcrao/qcrao.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>深度解密Go语言之slice</title>
    <link href="https://github.com/qcrao/qcrao.github.io/2019/04/02/dive-into-go-slice/"/>
    <id>https://github.com/qcrao/qcrao.github.io/2019/04/02/dive-into-go-slice/</id>
    <published>2019-04-02T00:38:00.000Z</published>
    <updated>2019-07-24T14:08:53.892Z</updated>
    
    <content type="html"><![CDATA[<p>Go 语言的 <code>slice</code> 很好用，不过也有一些坑。<code>slice</code> 是 Go 语言一个很重要的数据结构。网上已经有很多文章写过了，似乎没必要再写。但是每个人看问题的视角不同，写出来的东西自然也不一样。我这篇会从更底层的汇编语言去解读它。而且在我写这篇文章的过程中，发现绝大部分文章都存在一些问题，文章里会讲到，这里先不展开。</p><p>我希望本文可以终结这个话题，下次再有人想和你讨论 <code>slice</code>，直接把这篇文章的链接丢过去就行了。</p><p>[toc]</p><h1 id="当我们在说-slice-时，到底在说什么"><a href="#当我们在说-slice-时，到底在说什么" class="headerlink" title="当我们在说 slice 时，到底在说什么"></a>当我们在说 slice 时，到底在说什么</h1><p><code>slice</code> 翻译成中文就是<code>切片</code>，它和<code>数组（array）</code>很类似，可以用下标的方式进行访问，如果越界，就会产生 panic。但是它比数组更灵活，可以自动地进行扩容。</p><p>了解 slice 的本质，最简单的方法就是看它的源代码：</p><pre class=" language-golang"><code class="language-golang">// runtime/slice.gotype slice struct {    array unsafe.Pointer // 元素指针    len   int // 长度     cap   int // 容量}</code></pre><p>看到了吗，<code>slice</code> 共有三个属性：<br><code>指针</code>，指向底层数组；<br><code>长度</code>，表示切片可用元素的个数，也就是说使用下标对 slice 的元素进行访问时，下标不能超过 slice 的长度；<br><code>容量</code>，底层数组的元素个数，容量 &gt;= 长度。在底层数组不进行扩容的情况下，容量也是 slice 可以扩张的最大限度。</p><p><img src="https://user-images.githubusercontent.com/7698088/55270142-876c2000-52d6-11e9-99e5-2e921fc2d430.png" alt="切片数据结构"></p><p>注意，底层数组是可以被多个 slice 同时指向的，因此对一个 slice 的元素进行操作是有可能影响到其他 slice 的。</p><h1 id="slice-的创建"><a href="#slice-的创建" class="headerlink" title="slice 的创建"></a>slice 的创建</h1><p>创建 slice 的方式有以下几种：</p><table><thead><tr><th>序号</th><th>方式</th><th>代码示例</th></tr></thead><tbody><tr><td>1</td><td>直接声明</td><td><code>var slice []int</code></td></tr><tr><td>2</td><td>new</td><td><code>slice := *new([]int)</code></td></tr><tr><td>3</td><td>字面量</td><td><code>slice := []int{1,2,3,4,5}</code></td></tr><tr><td>4</td><td>make</td><td><code>slice := make([]int, 5, 10)</code></td></tr><tr><td>5</td><td>从切片或数组“截取”</td><td><code>slice := array[1:5]</code> 或 <code>slice := sourceSlice[1:5]</code></td></tr></tbody></table><h2 id="直接声明"><a href="#直接声明" class="headerlink" title="直接声明"></a>直接声明</h2><p>第一种创建出来的 slice 其实是一个 <code>nil slice</code>。它的长度和容量都为0。和<code>nil</code>比较的结果为<code>true</code>。</p><p>这里比较混淆的是<code>empty slice</code>，它的长度和容量也都为0，但是所有的空切片的数据指针都指向同一个地址 <code>0xc42003bda0</code>。空切片和 <code>nil</code> 比较的结果为<code>false</code>。</p><p>它们的内部结构如下图：</p><p><img src="https://user-images.githubusercontent.com/7698088/54864985-ac720780-4d99-11e9-8386-68ef68880c8d.png" alt="nil slice 与 empty slice"></p><table><thead><tr><th>创建方式</th><th>nil切片</th><th>空切片</th></tr></thead><tbody><tr><td>方式一</td><td>var s1 []int</td><td>var s2 = []int{}</td></tr><tr><td>方式二</td><td>var s4 = *new([]int)</td><td>var s3 = make([]int, 0)</td></tr><tr><td>长度</td><td>0</td><td>0</td></tr><tr><td>容量</td><td>0</td><td>0</td></tr><tr><td>和 <code>nil</code> 比较</td><td><code>true</code></td><td><code>false</code></td></tr></tbody></table><p><code>nil</code> 切片和空切片很相似，长度和容量都是0，官方建议尽量使用 <code>nil</code> 切片。</p><p>关于<code>nil slice</code>和<code>empty slice</code>的探索可以参考公众号“码洞”作者老钱写的一篇文章《深度解析 Go 语言中「切片」的三种特殊状态》，地址附在了参考资料部分。</p><h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><p>比较简单，直接用<code>初始化表达式</code>创建。</p><pre class=" language-golang"><code class="language-golang">package mainimport "fmt"func main() {    s1 := []int{0, 1, 2, 3, 8: 100}    fmt.Println(s1, len(s1), cap(s1))}</code></pre><p>运行结果：</p><pre class=" language-shell"><code class="language-shell">[0 1 2 3 0 0 0 0 100] 9 9</code></pre><p>唯一值得注意的是上面的代码例子中使用了索引号，直接赋值，这样，其他未注明的元素则默认 <code>0 值</code>。</p><h2 id="make"><a href="#make" class="headerlink" title="make"></a>make</h2><p><code>make</code>函数需要传入三个参数：切片类型，长度，容量。当然，容量可以不传，默认和长度相等。</p><p>上篇文章<a href="https://www.cnblogs.com/qcrao-2018/p/10562216.html" target="_blank" rel="noopener">《走进Go的底层》</a>中，我们学到了汇编这个工具，这次我们再次请出汇编来更深入地看看<code>slice</code>。如果没看过上篇文章，建议先回去看完，再继续阅读本文效果更佳。</p><p>先来一小段玩具代码，使用 <code>make</code> 关键字创建 <code>slice</code>：</p><pre class=" language-golang"><code class="language-golang">package mainimport "fmt"func main() {    slice := make([]int, 5, 10) // 长度为5，容量为10    slice[2] = 2 // 索引为2的元素赋值为2    fmt.Println(slice)}</code></pre><p>执行如下命令，得到 Go 汇编代码：</p><pre class=" language-shell"><code class="language-shell">go tool compile -S main.go</code></pre><p>我们只关注main函数：</p><pre class=" language-asm"><code class="language-asm">0x0000 00000 (main.go:5)TEXT    "".main(SB), $96-00x0000 00000 (main.go:5)MOVQ    (TLS), CX0x0009 00009 (main.go:5)CMPQ    SP, 16(CX)0x000d 00013 (main.go:5)JLS     2280x0013 00019 (main.go:5)SUBQ    $96, SP0x0017 00023 (main.go:5)MOVQ    BP, 88(SP)0x001c 00028 (main.go:5)LEAQ    88(SP), BP0x0021 00033 (main.go:5)FUNCDATA    $0, gclocals·69c1753bd5f81501d95132d08af04464(SB)0x0021 00033 (main.go:5)FUNCDATA    $1, gclocals·57cc5e9a024203768cbab1c731570886(SB)0x0021 00033 (main.go:5)LEAQ    type.int(SB), AX0x0028 00040 (main.go:6)MOVQ    AX, (SP)0x002c 00044 (main.go:6)MOVQ    $5, 8(SP)0x0035 00053 (main.go:6)MOVQ    $10, 16(SP)0x003e 00062 (main.go:6)PCDATA  $0, $00x003e 00062 (main.go:6)CALL    runtime.makeslice(SB)0x0043 00067 (main.go:6)MOVQ    24(SP), AX0x0048 00072 (main.go:6)MOVQ    32(SP), CX0x004d 00077 (main.go:6)MOVQ    40(SP), DX0x0052 00082 (main.go:7)CMPQ    CX, $20x0056 00086 (main.go:7)JLS     2210x005c 00092 (main.go:7)MOVQ    $2, 16(AX)0x0064 00100 (main.go:8)MOVQ    AX, ""..autotmp_2+64(SP)0x0069 00105 (main.go:8)MOVQ    CX, ""..autotmp_2+72(SP)0x006e 00110 (main.go:8)MOVQ    DX, ""..autotmp_2+80(SP)0x0073 00115 (main.go:8)MOVQ    $0, ""..autotmp_1+48(SP)0x007c 00124 (main.go:8)MOVQ    $0, ""..autotmp_1+56(SP)0x0085 00133 (main.go:8)LEAQ    type.[]int(SB), AX0x008c 00140 (main.go:8)MOVQ    AX, (SP)0x0090 00144 (main.go:8)LEAQ    ""..autotmp_2+64(SP), AX0x0095 00149 (main.go:8)MOVQ    AX, 8(SP)0x009a 00154 (main.go:8)PCDATA  $0, $10x009a 00154 (main.go:8)CALL    runtime.convT2Eslice(SB)0x009f 00159 (main.go:8)MOVQ    16(SP), AX0x00a4 00164 (main.go:8)MOVQ    24(SP), CX0x00a9 00169 (main.go:8)MOVQ    AX, ""..autotmp_1+48(SP)0x00ae 00174 (main.go:8)MOVQ    CX, ""..autotmp_1+56(SP)0x00b3 00179 (main.go:8)LEAQ    ""..autotmp_1+48(SP), AX0x00b8 00184 (main.go:8)MOVQ    AX, (SP)0x00bc 00188 (main.go:8)MOVQ    $1, 8(SP)0x00c5 00197 (main.go:8)MOVQ    $1, 16(SP)0x00ce 00206 (main.go:8)PCDATA  $0, $10x00ce 00206 (main.go:8)CALL    fmt.Println(SB)0x00d3 00211 (main.go:9)MOVQ    88(SP), BP0x00d8 00216 (main.go:9)ADDQ    $96, SP0x00dc 00220 (main.go:9)RET0x00dd 00221 (main.go:7)PCDATA  $0, $00x00dd 00221 (main.go:7)CALL    runtime.panicindex(SB)0x00e2 00226 (main.go:7)UNDEF0x00e4 00228 (main.go:7)NOP0x00e4 00228 (main.go:5)PCDATA  $0, $-10x00e4 00228 (main.go:5)CALL    runtime.morestack_noctxt(SB)0x00e9 00233 (main.go:5)JMP     0</code></pre><p>先说明一下，Go 语言汇编 <code>FUNCDATA</code> 和 <code>PCDATA</code> 是编译器产生的，用于保存一些和垃圾收集相关的信息，我们先不用 care。</p><p>以上汇编代码行数比较多，没关系，因为命令都比较简单，而且我们的 Go 源码也足够简单，没有理由看不明白。</p><p>我们先从上到下扫一眼，看到几个关键函数：</p><pre class=" language-shell"><code class="language-shell">CALL    runtime.makeslice(SB)CALL    runtime.convT2Eslice(SB)CALL    fmt.Println(SB)CALL    runtime.morestack_noctxt(SB)</code></pre><table><thead><tr><th>序号</th><th>功能</th></tr></thead><tbody><tr><td>1</td><td>创建slice</td></tr><tr><td>2</td><td>类型转换</td></tr><tr><td>3</td><td>打印函数</td></tr><tr><td>4</td><td>栈空间扩容</td></tr></tbody></table><p><code>1</code>是创建 slice 相关的；<code>2</code>是类型转换；调用 <code>fmt.Println</code>需要将 slice 作一个转换； <code>3</code>是打印语句；<code>4</code>是栈空间扩容函数，在函数开始处，会检查当前栈空间是否足够，不够的话需要调用它来进行扩容。暂时可以忽略。</p><p>调用了函数就会涉及到参数传递，Go 的参数传递都是通过 栈空间完成的。接下来，我们详细分析这整个过程。</p><table><thead><tr><th>行数</th><th>作用</th></tr></thead><tbody><tr><td>1</td><td><code>main</code>函数定义，栈帧大小为 <code>96B</code></td></tr><tr><td>2-4</td><td>判断栈是否需要进行扩容，如果需要则跳到 <code>228</code>，这里会调用 <code>runtime.morestack_noctxt(SB)</code> 进行栈扩容操作。具体细节后续还会有文章来讲</td></tr><tr><td>5-9</td><td>将 <code>caller BP</code> 压栈，具体细节后面会讲到</td></tr><tr><td>10-15</td><td>调用 <code>runtime.makeslice(SB)</code> 函数及准备工作。*_type表示的是 <code>int</code>，也就是 <code>slice</code> 元素的类型。这里对应的源码是第6行，也就是调用 <code>make</code> 创建 <code>slice</code> 的那一行。<code>5</code> 和 <code>10</code> 分别代表长度和容量，函数参数会在栈顶准备好，之后执行函数调用命令 <code>CALL</code>，进入到被调用函数的栈帧，就会按顺序从 <code>caller</code> 的栈顶取函数参数</td></tr><tr><td>16-18</td><td>接收 <code>makeslice</code>的返回值，通过 <code>move</code> 移动到寄存器中</td></tr><tr><td>19-21</td><td>给数组索引值为 <code>2</code> 的元素赋上值 <code>2</code>，因为是 <code>int</code> 型的 <code>slice</code>，元素大小为8字节，所以 <code>MOVQ $2, 16(AX)</code> 此命令就是将 <code>2</code> 搬到索引为 <code>2</code> 的位置。这里还会对索引值的大小进行检查，如果越界，则会跳转到 <code>221</code>，执行 <code>panic</code> 函数</td></tr><tr><td>22-26</td><td>分别通过寄存器 <code>AX，CX，DX</code> 将 <code>makeslice</code> 的返回值 <code>move</code> 到内存的其他位置，也称为局部变量，这样就构造出了 <code>slice</code></td></tr></tbody></table><p><img src="https://user-images.githubusercontent.com/7698088/54982728-5fcf3c00-4fe6-11e9-819b-9c5b45cc93bf.png" alt="makeslice 栈帧"></p><p>左边是栈上的数据，右边是堆上的数据。<code>array</code> 指向 <code>slice</code> 的底层数据，被分配到堆上了。注意，栈上的地址是从高向低增长；堆则从低向高增长。栈左边的数字表示对应的汇编代码的行数，栈右边箭头则表示栈地址。（48）SP、（56）SP 表示的内容接着往下看。</p><p>注意，在图中，栈地址是从下往上增长，所以 SP 表示的是图中 <code>*_type</code> 所在的位置，其它的依此类推。</p><table><thead><tr><th>行数</th><th>作用</th></tr></thead><tbody><tr><td>27-32</td><td>准备调用 <code>runtime.convT2Eslice(SB)</code>的函数参数</td></tr><tr><td>33-36</td><td>接收返回值，通过AX，CX寄存器 <code>move</code> 到(48)SP、（56）SP</td></tr></tbody></table><p><code>convT2Eslice</code> 的函数声明如下：</p><pre class=" language-golang"><code class="language-golang">func convT2Eslice(t *_type, elem unsafe.Pointer) (e eface) </code></pre><p>第一个参数是指针 <code>*_type</code>，<code>_type</code>是一个表示类型的结构体，这里传入的就是 <code>slice</code>的类型 <code>[]int</code>；第二个参数则是元素的指针，这里传入的就是 <code>slice</code> 底层数组的首地址。</p><p>返回值 <code>eface</code> 的结构体定义如下：</p><pre class=" language-golang"><code class="language-golang">type eface struct {    _type *_type    data  unsafe.Pointer}</code></pre><p>由于我们会调用 <code>fmt.Println(slice)</code>，看下函数原型：</p><pre class=" language-golang"><code class="language-golang">func Println(a ...interface{}) (n int, err error)</code></pre><p><code>Println</code> 接收 interface 类型，因此我们需要将 <code>slice</code> 转换成 interface 类型。由于 <code>slice</code> 没有方法，是个“<code>空 interface</code>”。因此会调用 <code>convT2Eslice</code> 完成这一转换过程。</p><p><code>convT2Eslice</code> 函数返回的是类型指针和数据地址。源码就不贴了，大体流程是：调用 <code>mallocgc</code> 分配一块内存，把数据 <code>copy</code> 进到新的内存，然后返回这块内存的地址，<code>*_type</code> 则直接返回传入的参数。</p><p><img src="https://user-images.githubusercontent.com/7698088/55271648-2d298a00-52eb-11e9-9dd0-e1bcc1fe33d0.png" alt="convT2Eslice 栈帧"></p><p><code>32(SP)</code> 和 <code>40(SP)</code> 其实是 <code>makeslice</code> 函数的返回值，这里可以忽略。</p><p>还剩 <code>fmt.Println(slice)</code> 最后一个函数调用了，我们继续。</p><table><thead><tr><th>行数</th><th>作用</th></tr></thead><tbody><tr><td>37-40</td><td>准备 <code>Println</code> 函数参数。共3个参数，第一个是类型地址，还有两个 <code>1</code>，这块暂时还不知道为什么要传，有了解的同学可以在文章后面留言</td></tr></tbody></table><p>所以调用 <code>fmt.Println(slice)</code> 时，实际是传入了一个 <code>slice类型的eface地址</code>。这样，<code>Println</code>就可以访问类型中的数据，最终给“打印”出来。 </p><p><img src="https://user-images.githubusercontent.com/7698088/55271702-1f283900-52ec-11e9-9d3f-d8eb754ef23c.png" alt="fmt.Println 栈帧"></p><p>最后，我们看下 <code>main</code> 函数栈帧的开始和收尾部分。</p><pre class=" language-asm"><code class="language-asm">0x0013 00019 (main.go:5)SUBQ    $96, SP0x0017 00023 (main.go:5)MOVQ    BP, 88(SP)0x001c 00028 (main.go:5)LEAQ    88(SP), BP…………………………0x00d3 00211 (main.go:9)MOVQ    88(SP), BP0x00d8 00216 (main.go:9)ADDQ    $96, SPRET</code></pre><p><code>BP</code>可以理解为保存了当前函数栈帧栈底的地址，<code>SP</code>则保存栈顶的地址。</p><p>初始，<code>BP</code> 和 <code>SP</code> 分别有一个初始状态。</p><p><code>main</code> 函数执行的时候，先根据 <code>main</code> 函数栈帧大小确定 <code>SP</code> 的新指向，使得 <code>main</code> 函数栈帧大小达到 <code>96B</code>。之后把老的 <code>BP</code> 保存到 <code>main</code>  函数栈帧的底部，并使 <code>BP</code> 寄存器重新指向新的栈底，也就是 <code>main</code> 函数栈帧的栈底。</p><p>最后，当 <code>main</code> 函数执行完毕，把它栈底的 <code>BP</code> 给回弹回到 <code>BP</code> 寄存器，恢复调用前的初始状态。一切都像是没有发生一样，完美的现场。</p><p><img src="https://user-images.githubusercontent.com/7698088/54874022-24821100-4e1e-11e9-805b-408c29b3c1c4.png" alt="栈帧变化"></p><p>这部分，又详细地分析了一遍函数调用的过程。一方面，让大家复习一下上一篇文章讲的内容；另一方面，向大家展示如何找到 Go 中的一个函数背后真实调用了哪些函数。像例子中，我们就看到了 <code>make</code> 函数背后，实际上是调用了 <code>makeslice</code> 函数；还有一点，让大家对汇编不那么“惧怕”，可以轻松地分析一些东西。</p><h2 id="截取"><a href="#截取" class="headerlink" title="截取"></a>截取</h2><p>截取也是比较常见的一种创建 slice 的方法，可以从数组或者 slice 直接截取，当然需要指定起止索引位置。</p><p>基于已有 slice 创建新 slice 对象，被称为 <code>reslice</code>。新 slice 和老 slice 共用底层数组，新老 slice 对底层数组的更改都会影响到彼此。基于数组创建的新 slice 对象也是同样的效果：对数组或 slice 元素作的更改都会影响到彼此。</p><p>值得注意的是，新老 slice 或者新 slice 老数组互相影响的前提是两者共用底层数组，如果因为执行 <code>append</code> 操作使得新 slice 底层数组扩容，移动到了新的位置，两者就不会相互影响了。所以，<code>问题的关键在于两者是否会共用底层数组</code>。</p><p>截取操作采用如下方式：</p><pre class=" language-golang"><code class="language-golang"> data := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} slice := data[2:4:6] // data[low, high, max]</code></pre><p>对 <code>data</code> 使用3个索引值，截取出新的  <code>slice</code>。这里 <code>data</code> 可以是数组或者 <code>slice</code>。<code>low</code> 是最低索引值，这里是闭区间，也就是说第一个元素是 <code>data</code> 位于 <code>low</code> 索引处的元素；而 <code>high</code> 和 <code>max</code> 则是开区间，表示最后一个元素只能是索引 <code>high-1</code> 处的元素，而最大容量则只能是索引 <code>max-1</code> 处的元素。</p><pre class=" language-golang"><code class="language-golang">max >= high >= low</code></pre><p>当 <code>high == low</code> 时，新 <code>slice</code> 为空。</p><p>还有一点，<code>high</code> 和 <code>max</code> 必须在老数组或者老 <code>slice</code> 的容量（<code>cap</code>）范围内。</p><p>来看一个例子，来自雨痕大佬《Go学习笔记》第四版，P43页，参考资料里有开源书籍地址。这里我会进行扩展，并会作详细说明：</p><pre class=" language-golang"><code class="language-golang">package mainimport "fmt"func main() {    slice := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}    s1 := slice[2:5]    s2 := s1[2:6:7]    s2 = append(s2, 100)    s2 = append(s2, 200)    s1[2] = 20    fmt.Println(s1)    fmt.Println(s2)    fmt.Println(slice)}</code></pre><p>先看下代码运行的结果：</p><pre class=" language-shell"><code class="language-shell">[2 3 20][4 5 6 7 100 200][0 1 2 3 20 5 6 7 100 9]</code></pre><p>我们来走一遍代码，初始状态如下：</p><pre class=" language-golang"><code class="language-golang">slice := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}s1 := slice[2:5]s2 := s1[2:6:7]</code></pre><p><code>s1</code> 从 <code>slice</code> 索引2（闭区间）到索引5（开区间，元素真正取到索引4），长度为3，容量默认到数组结尾，为8。<br><code>s2</code> 从 <code>s1</code> 的索引2（闭区间）到索引6（开区间，元素真正取到索引5），容量到索引7（开区间，真正到索引6），为5。</p><p><img src="https://user-images.githubusercontent.com/7698088/54960948-c5490b80-4f99-11e9-8772-66d102caae8e.png" alt="slice origin"></p><p>接着，向 <code>s2</code> 尾部追加一个元素 100：</p><pre class=" language-golang"><code class="language-golang">s2 = append(s2, 100)</code></pre><p><code>s2</code> 容量刚好够，直接追加。不过，这会修改原始数组对应位置的元素。这一改动，数组和 <code>s1</code> 都可以看得到。</p><p><img src="https://user-images.githubusercontent.com/7698088/54960896-8ca93200-4f99-11e9-86de-df4d85cca135.png" alt="append 100"></p><p>再次向 <code>s2</code> 追加元素200：</p><pre class=" language-golang"><code class="language-golang">s2 = append(s2, 100)</code></pre><p>这时，<code>s2</code> 的容量不够用，该扩容了。于是，<code>s2</code> 另起炉灶，将原来的元素复制新的位置，扩大自己的容量。并且为了应对未来可能的 <code>append</code> 带来的再一次扩容，<code>s2</code> 会在此次扩容的时候多留一些 <code>buffer</code>，将新的容量将扩大为原始容量的2倍，也就是10了。</p><p><img src="https://user-images.githubusercontent.com/7698088/54961368-4654d280-4f9b-11e9-9b00-de96c6eedea9.png" alt="append 200"></p><p>最后，修改 <code>s1</code> 索引为2位置的元素：</p><pre class=" language-golang"><code class="language-golang">s1[2] = 20</code></pre><p>这次只会影响原始数组相应位置的元素。它影响不到 <code>s2</code> 了，人家已经远走高飞了。</p><p><img src="https://user-images.githubusercontent.com/7698088/54961330-29200400-4f9b-11e9-88d0-a29308a818ae.png" alt="s1[2]=20"></p><p>再提一点，打印 <code>s1</code> 的时候，只会打印出 <code>s1</code> 长度以内的元素。所以，只会打印出3个元素，虽然它的底层数组不止3个元素。</p><p>至于，我们想在汇编层面看看到底它们是如何共享底层数组的，限于篇幅，这里不再展开。感兴趣的同学可以在公众号后台回复：<code>切片截取</code>。</p><p>我会给你详细分析函数调用关系，对共享底层数组的行为也会一目了然。二维码见文章底部。</p><h1 id="slice-和数组的区别在哪"><a href="#slice-和数组的区别在哪" class="headerlink" title="slice 和数组的区别在哪"></a>slice 和数组的区别在哪</h1><p>slice 的底层数据是数组，slice 是对数组的封装，它描述一个数组的片段。两者都可以通过下标来访问单个元素。</p><p>数组是定长的，长度定义好之后，不能再更改。在 Go 中，数组是不常见的，因为其长度是类型的一部分，限制了它的表达能力，比如 <code>[3]int</code> 和 <code>[4]int</code> 就是不同的类型。</p><p>而切片则非常灵活，它可以动态地扩容。切片的类型和长度无关。</p><h1 id="append-到底做了什么"><a href="#append-到底做了什么" class="headerlink" title="append 到底做了什么"></a>append 到底做了什么</h1><p>先来看看 <code>append</code> 函数的原型：</p><pre class=" language-golang"><code class="language-golang">func append(slice []Type, elems ...Type) []Type</code></pre><p>append 函数的参数长度可变，因此可以追加多个值到 slice 中，还可以用 <code>...</code> 传入 slice，直接追加一个切片。</p><pre class=" language-golang"><code class="language-golang">slice = append(slice, elem1, elem2)slice = append(slice, anotherSlice...)</code></pre><p><code>append</code>函数返回值是一个新的slice，Go编译器不允许调用了 append 函数后不使用返回值。</p><pre class=" language-golang"><code class="language-golang">append(slice, elem1, elem2)append(slice, anotherSlice...)</code></pre><p>所以上面的用法是错的，不能编译通过。</p><p>使用 append 可以向 slice 追加元素，实际上是往底层数组添加元素。但是底层数组的长度是固定的，如果索引 <code>len-1</code> 所指向的元素已经是底层数组的最后一个元素，就没法再添加了。</p><p>这时，slice 会迁移到新的内存位置，新底层数组的长度也会增加，这样就可以放置新增的元素。同时，为了应对未来可能再次发生的 append 操作，新的底层数组的长度，也就是新 <code>slice</code> 的容量是留了一定的 <code>buffer</code> 的。否则，每次添加元素的时候，都会发生迁移，成本太高。</p><p>新 slice 预留的 <code>buffer</code> 大小是有一定规律的。网上大多数的文章都是这样描述的：</p><blockquote><p>当原 slice 容量小于 <code>1024</code> 的时候，新 slice 容量变成原来的 <code>2</code> 倍；原 slice 容量超过 <code>1024</code>，新 slice 容量变成原来的<code>1.25</code>倍。</p></blockquote><p>我在这里先说结论：以上描述是错误的。</p><p>为了说明上面的规律是错误的，我写了一小段玩具代码：</p><pre class=" language-golang"><code class="language-golang">package mainimport "fmt"func main() {    s := make([]int, 0)    oldCap := cap(s)    for i := 0; i < 2048; i++ {        s = append(s, i)        newCap := cap(s)        if newCap != oldCap {            fmt.Printf("[%d -> %4d] cap = %-4d  |  after append %-4d  cap = %-4d\n", 0, i-1, oldCap, i, newCap)            oldCap = newCap        }    }}</code></pre><p>我先创建了一个空的 <code>slice</code>，然后，在一个循环里不断往里面 <code>append</code> 新的元素。然后记录容量的变化，并且每当容量发生变化的时候，记录下老的容量，以及添加完元素之后的容量，同时记下此时 <code>slice</code> 里的元素。这样，我就可以观察，新老 <code>slice</code> 的容量变化情况，从而找出规律。</p><p>运行结果：</p><pre class=" language-shell"><code class="language-shell">[0 ->   -1] cap = 0     |  after append 0     cap = 1   [0 ->    0] cap = 1     |  after append 1     cap = 2   [0 ->    1] cap = 2     |  after append 2     cap = 4   [0 ->    3] cap = 4     |  after append 4     cap = 8   [0 ->    7] cap = 8     |  after append 8     cap = 16  [0 ->   15] cap = 16    |  after append 16    cap = 32  [0 ->   31] cap = 32    |  after append 32    cap = 64  [0 ->   63] cap = 64    |  after append 64    cap = 128 [0 ->  127] cap = 128   |  after append 128   cap = 256 [0 ->  255] cap = 256   |  after append 256   cap = 512 [0 ->  511] cap = 512   |  after append 512   cap = 1024[0 -> 1023] cap = 1024  |  after append 1024  cap = 1280[0 -> 1279] cap = 1280  |  after append 1280  cap = 1696[0 -> 1695] cap = 1696  |  after append 1696  cap = 2304</code></pre><p>在老 slice 容量小于1024的时候，新 slice 的容量的确是老 slice 的2倍。目前还算正确。</p><p>但是，当老 slice 容量大于等于 <code>1024</code> 的时候，情况就有变化了。当向 slice 中添加元素 <code>1280</code> 的时候，老 slice 的容量为 <code>1280</code>，之后变成了 <code>1696</code>，两者并不是 <code>1.25</code> 倍的关系（1696/1280=1.325）。添加完 <code>1696</code> 后，新的容量 <code>2304</code> 当然也不是 <code>1696</code> 的 <code>1.25</code> 倍。</p><p>可见，现在网上各种文章中的扩容策略并不正确。我们直接搬出源码：源码面前，了无秘密。</p><p>从前面汇编代码我们也看到了，向 slice 追加元素的时候，若容量不够，会调用 <code>growslice</code> 函数，所以我们直接看它的代码。</p><pre class=" language-golang"><code class="language-golang">// go 1.9.5 src/runtime/slice.go:82func growslice(et *_type, old slice, cap int) slice {    // ……    newcap := old.cap    doublecap := newcap + newcap    if cap > doublecap {        newcap = cap    } else {        if old.len < 1024 {            newcap = doublecap        } else {            for newcap < cap {                newcap += newcap / 4            }        }    }    // ……    capmem = roundupsize(uintptr(newcap) * ptrSize)    newcap = int(capmem / ptrSize)}</code></pre><p>看到了吗？如果只看前半部分，现在网上各种文章里说的 <code>newcap</code> 的规律是对的。现实是，后半部分还对 <code>newcap</code> 作了一个<code>内存对齐</code>，这个和内存分配策略相关。进行内存对齐之后，新 slice 的容量是要 <code>大于等于</code> 老 slice 容量的 <code>2倍</code>或者<code>1.25倍</code>。</p><p>之后，向 Go 内存管理器申请内存，将老 slice 中的数据复制过去，并且将 append 的元素添加到新的底层数组中。</p><p>最后，向 <code>growslice</code> 函数调用者返回一个新的 slice，这个 slice 的长度并没有变化，而容量却增大了。</p><p>关于 <code>append</code>，我们最后来看一个例子，来源于参考资料部分的【Golang Slice的扩容规则】。</p><pre class=" language-golang"><code class="language-golang">package mainimport "fmt"func main() {    s := []int{1,2}    s = append(s,4,5,6)    fmt.Printf("len=%d, cap=%d",len(s),cap(s))}</code></pre><p>运行结果是：</p><pre class=" language-shell"><code class="language-shell">len=5, cap=6</code></pre><p>如果按网上各种文章中总结的那样：小于原 slice 长度小于 1024 的时候，容量每次增加 1 倍。添加元素 4 的时候，容量变为4；添加元素 5 的时候不变；添加元素 6 的时候容量增加 1 倍，变成 8。</p><p>那上面代码的运行结果就是：</p><pre class=" language-shell"><code class="language-shell">len=5, cap=8</code></pre><p>这是错误的！我们来仔细看看，为什么会这样，再次搬出代码：</p><pre class=" language-golang"><code class="language-golang">// go 1.9.5 src/runtime/slice.go:82func growslice(et *_type, old slice, cap int) slice {    // ……    newcap := old.cap    doublecap := newcap + newcap    if cap > doublecap {        newcap = cap    } else {        // ……    }    // ……    capmem = roundupsize(uintptr(newcap) * ptrSize)    newcap = int(capmem / ptrSize)}</code></pre><p>这个函数的参数依次是 <code>元素的类型，老的 slice，新 slice 最小求的容量</code>。</p><p>例子中 <code>s</code> 原来只有 2 个元素，<code>len</code> 和 <code>cap</code> 都为 2，<code>append</code> 了三个元素后，长度变为 3，容量最小要变成 5，即调用 <code>growslice</code> 函数时，传入的第三个参数应该为 5。即 <code>cap=5</code>。而一方面，<code>doublecap</code> 是原 <code>slice</code>容量的 2 倍，等于 4。满足第一个 <code>if</code> 条件，所以 <code>newcap</code> 变成了 5。</p><p>接着调用了 <code>roundupsize</code> 函数，传入 40。（代码中ptrSize是指一个指针的大小，在64位机上是8）</p><p>我们再看内存对齐，搬出 <code>roundupsize</code> 函数的代码：</p><pre class=" language-golang"><code class="language-golang">// src/runtime/msize.go:13func roundupsize(size uintptr) uintptr {    if size < _MaxSmallSize {        if size <= smallSizeMax-8 {            return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])        } else {            //……        }    }    //……}const _MaxSmallSize = 32768const smallSizeMax = 1024const smallSizeDiv = 8</code></pre><p>很明显，我们最终将返回这个式子的结果：</p><pre class=" language-golang"><code class="language-golang">class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]]</code></pre><p>这是 <code>Go</code> 源码中有关内存分配的两个 <code>slice</code>。<code>class_to_size</code>通过 <code>spanClass</code>获取 <code>span</code>划分的 <code>object</code>大小。而 <code>size_to_class8</code> 表示通过 <code>size</code> 获取它的 <code>spanClass</code>。</p><pre class=" language-golang"><code class="language-golang">var size_to_class8 = [smallSizeMax/smallSizeDiv + 1]uint8{0, 1, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31}var class_to_size = [_NumSizeClasses]uint16{0, 8, 16, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240, 256, 288, 320, 352, 384, 416, 448, 480, 512, 576, 640, 704, 768, 896, 1024, 1152, 1280, 1408, 1536, 1792, 2048, 2304, 2688, 3072, 3200, 3456, 4096, 4864, 5376, 6144, 6528, 6784, 6912, 8192, 9472, 9728, 10240, 10880, 12288, 13568, 14336, 16384, 18432, 19072, 20480, 21760, 24576, 27264, 28672, 32768}</code></pre><p>我们传进去的 <code>size</code> 等于 40。所以 <code>(size+smallSizeDiv-1)/smallSizeDiv = 5</code>；获取 <code>size_to_class8</code> 数组中索引为 <code>5</code> 的元素为 <code>4</code>；获取 <code>class_to_size</code> 中索引为 <code>4</code> 的元素为 <code>48</code>。</p><p>最终，新的 slice 的容量为 <code>6</code>：</p><pre class=" language-golang"><code class="language-golang">newcap = int(capmem / ptrSize) // 6</code></pre><p>至于，上面的两个<code>魔法数组</code>的由来，暂时就不展开了。</p><h1 id="为什么-nil-slice-可以直接-append"><a href="#为什么-nil-slice-可以直接-append" class="headerlink" title="为什么 nil slice 可以直接 append"></a>为什么 nil slice 可以直接 append</h1><p>其实 <code>nil slice</code> 或者 <code>empty slice</code> 都是可以通过调用 append 函数来获得底层数组的扩容。最终都是调用 <code>mallocgc</code> 来向 Go 的内存管理器申请到一块内存，然后再赋给原来的<code>nil slice</code> 或 <code>empty slice</code>，然后摇身一变，成为“真正”的 <code>slice</code> 了。</p><h1 id="传-slice-和-slice-指针有什么区别"><a href="#传-slice-和-slice-指针有什么区别" class="headerlink" title="传 slice 和 slice 指针有什么区别"></a>传 slice 和 slice 指针有什么区别</h1><p>前面我们说到，slice 其实是一个结构体，包含了三个成员：len, cap, array。分别表示切片长度，容量，底层数据的地址。</p><p>当 slice 作为函数参数时，就是一个普通的结构体。其实很好理解：若直接传 slice，在调用者看来，实参 slice 并不会被函数中的操作改变；若传的是 slice 的指针，在调用者看来，是会被改变原 slice 的。</p><p>值的注意的是，不管传的是 slice 还是 slice 指针，如果改变了 slice 底层数组的数据，会反应到实参 slice 的底层数据。为什么能改变底层数组的数据？很好理解：底层数据在 slice 结构体里是一个指针，仅管 slice 结构体自身不会被改变，也就是说底层数据地址不会被改变。 但是通过指向底层数据的指针，可以改变切片的底层数据，没有问题。</p><p>通过 slice 的 array 字段就可以拿到数组的地址。在代码里，是直接通过类似 <code>s[i]=10</code> 这种操作改变 slice 底层数组元素值。</p><p>另外，啰嗦一句，Go 语言的函数参数传递，只有值传递，没有引用传递。后面会再写一篇相关的文章，敬请期待。</p><p>再来看一个年幼无知的代码片段：</p><pre class=" language-golang"><code class="language-golang">package mainfunc main() {    s := []int{1, 1, 1}    f(s)    fmt.Println(s)}func f(s []int) {    // i只是一个副本，不能改变s中元素的值    /*for _, i := range s {        i++    }    */    for i := range s {        s[i] += 1    }}</code></pre><p>运行一下，程序输出：</p><pre class=" language-shell"><code class="language-shell">[2 2 2]</code></pre><p>果真改变了原始 slice 的底层数据。这里传递的是一个 slice 的副本，在 <code>f</code> 函数中，<code>s</code> 只是 <code>main</code> 函数中 <code>s</code> 的一个拷贝。在<code>f</code> 函数内部，对 <code>s</code> 的作用并不会改变外层 <code>main</code> 函数的 <code>s</code>。</p><p>要想真的改变外层 <code>slice</code>，只有将返回的新的 slice 赋值到原始 slice，或者向函数传递一个指向 slice 的指针。我们再来看一个例子：</p><pre class=" language-golang"><code class="language-golang">package mainimport "fmt"func myAppend(s []int) []int {    // 这里 s 虽然改变了，但并不会影响外层函数的 s    s = append(s, 100)    return s}func myAppendPtr(s *[]int) {    // 会改变外层 s 本身    *s = append(*s, 100)    return}func main() {    s := []int{1, 1, 1}    newS := myAppend(s)    fmt.Println(s)    fmt.Println(newS)    s = newS    myAppendPtr(&s)    fmt.Println(s)}</code></pre><p>运行结果：</p><pre class=" language-shell"><code class="language-shell">[1 1 1][1 1 1 100][1 1 1 100 100]</code></pre><p><code>myAppend</code> 函数里，虽然改变了 <code>s</code>，但它只是一个值传递，并不会影响外层的 <code>s</code>，因此第一行打印出来的结果仍然是 <code>[1 1 1]</code>。</p><p>而 <code>newS</code> 是一个新的 <code>slice</code>，它是基于 <code>s</code> 得到的。因此它打印的是追加了一个 <code>100</code> 之后的结果： <code>[1 1 1 100]</code>。</p><p>最后，将 <code>newS</code> 赋值给了 <code>s</code>，<code>s</code> 这时才真正变成了一个新的slice。之后，再给 <code>myAppendPtr</code> 函数传入一个 <code>s  指针</code>，这回它真的被改变了：<code>[1 1 1 100 100]</code>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到此，关于 <code>slice</code> 的部分就讲完了，不知大家有没有看过瘾。我们最后来总结一下：</p><ul><li>切片是对底层数组的一个抽象，描述了它的一个片段。</li><li>切片实际上是一个结构体，它有三个字段：长度，容量，底层数据的地址。</li><li>多个切片可能共享同一个底层数组，这种情况下，对其中一个切片或者底层数组的更改，会影响到其他切片。</li><li><code>append</code> 函数会在切片容量不够的情况下，调用 <code>growslice</code> 函数获取所需要的内存，这称为扩容，扩容会改变元素原来的位置。</li><li>扩容策略并不是简单的扩为原切片容量的 <code>2</code> 倍或 <code>1.25</code> 倍，还有内存对齐的操作。扩容后的容量 &gt;= 原容量的 <code>2</code> 倍或 <code>1.25</code> 倍。</li><li>当直接用切片作为函数参数时，可以改变切片的元素，不能改变切片本身；想要改变切片本身，可以将改变后的切片返回，函数调用者接收改变后的切片或者将切片指针作为函数参数。</li></ul><p>最后，如果你觉得本文对你有帮助的话，帮我点一下右下角的“推荐”吧，感谢！</p><p><img src="https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png" alt="QR"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【码洞《深度解析 Go 语言中「切片」的三种特殊状态》】<a href="https://juejin.im/post/5bea58df6fb9a049f153bca8" target="_blank" rel="noopener">https://juejin.im/post/5bea58df6fb9a049f153bca8</a></p><p>【老钱 数组】<a href="https://juejin.im/post/5be53bc251882516c15af2e0" target="_blank" rel="noopener">https://juejin.im/post/5be53bc251882516c15af2e0</a></p><p>【老钱 切片】<a href="https://juejin.im/post/5be8e0b1f265da614d08b45a" target="_blank" rel="noopener">https://juejin.im/post/5be8e0b1f265da614d08b45a</a></p><p>【golang interface源码】<a href="https://i6448038.github.io/2018/10/01/Golang-interface/" target="_blank" rel="noopener">https://i6448038.github.io/2018/10/01/Golang-interface/</a></p><p>【golang interface源码】<a href="http://legendtkl.com/2017/07/01/golang-interface-implement/" target="_blank" rel="noopener">http://legendtkl.com/2017/07/01/golang-interface-implement/</a></p><p>【interface】<a href="https://www.jishuwen.com/d/2C9z#tuit" target="_blank" rel="noopener">https://www.jishuwen.com/d/2C9z#tuit</a></p><p>【雨痕开源Go学习笔记】<a href="https://github.com/qyuhen/book">https://github.com/qyuhen/book</a></p><p>【slice 图很漂亮】<a href="https://halfrost.com/go_slice/" target="_blank" rel="noopener">https://halfrost.com/go_slice/</a></p><p>【Golang Slice的扩容规则】<a href="https://jodezer.github.io/2017/05/golangSlice%E7%9A%84%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99" target="_blank" rel="noopener">https://jodezer.github.io/2017/05/golangSlice%E7%9A%84%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99</a></p><p>【slice作为参数】<a href="https://www.cnblogs.com/fwdqxl/p/9317769.html" target="_blank" rel="noopener">https://www.cnblogs.com/fwdqxl/p/9317769.html</a></p><p>【源码】<a href="https://ictar.xyz/2018/10/25/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-go-slice/" target="_blank" rel="noopener">https://ictar.xyz/2018/10/25/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-go-slice/</a></p><p>【append机制 译文】<a href="https://brantou.github.io/2017/05/24/go-array-slice-string/" target="_blank" rel="noopener">https://brantou.github.io/2017/05/24/go-array-slice-string/</a></p><p>【slice 汇编】<a href="http://xargin.com/go-slice/" target="_blank" rel="noopener">http://xargin.com/go-slice/</a></p><p>【slice tricks】<a href="https://colobu.com/2017/03/22/Slice-Tricks/" target="_blank" rel="noopener">https://colobu.com/2017/03/22/Slice-Tricks/</a></p><p>【有图】<a href="https://i6448038.github.io/2018/08/11/array-and-slice-principle/" target="_blank" rel="noopener">https://i6448038.github.io/2018/08/11/array-and-slice-principle/</a></p><p>【slice的本质】<a href="https://www.flysnow.org/2018/12/21/golang-sliceheader.html" target="_blank" rel="noopener">https://www.flysnow.org/2018/12/21/golang-sliceheader.html</a></p><p>【slice使用技巧】<a href="https://blog.thinkeridea.com/201901/go/slice_de_yi_xie_shi_yong_ji_qiao.html" target="_blank" rel="noopener">https://blog.thinkeridea.com/201901/go/slice_de_yi_xie_shi_yong_ji_qiao.html</a></p><p>【slice/array、内存增长】<a href="https://blog.thinkeridea.com/201901/go/shen_ru_pou_xi_slice_he_array.html" target="_blank" rel="noopener">https://blog.thinkeridea.com/201901/go/shen_ru_pou_xi_slice_he_array.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Go 语言的 &lt;code&gt;slice&lt;/code&gt; 很好用，不过也有一些坑。&lt;code&gt;slice&lt;/code&gt; 是 Go 语言一个很重要的数据结构。网上已经有很多文章写过了，似乎没必要再写。但是每个人看问题的视角不同，写出来的东西自然也不一样。我这篇会从更底层的汇编语言去
      
    
    </summary>
    
      <category term="编程语言" scheme="https://github.com/qcrao/qcrao.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="golang" scheme="https://github.com/qcrao/qcrao.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>深入Go的底层，带你走进一群有追求的人</title>
    <link href="https://github.com/qcrao/qcrao.github.io/2019/03/20/dive-into-go-asm/"/>
    <id>https://github.com/qcrao/qcrao.github.io/2019/03/20/dive-into-go-asm/</id>
    <published>2019-03-20T00:10:00.000Z</published>
    <updated>2019-07-24T11:29:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>上周六晚上，我参加了“Go夜读”活动，这期主要讲Go汇编语言，由滴滴大佬曹春晖大神主讲。活动结束后，我感觉打通了任督二脉。活动从晚上9点到深夜11点多，全程深度参与，大呼过瘾，以至于活动结束之后，久久不能平静。</p><p>可以说理解了Go汇编语言，就可以让我们对Go的理解上一个台阶，很多以前模棱的东西，在汇编语言面前都无所遁形了。我在活动上收获了很多，今天我来作一个总结，希望给大家带来启发！</p><h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>几周前我写了一篇关于<code>defer</code>的文章：<a href="https://www.cnblogs.com/qcrao-2018/p/10367346.html" target="_blank" rel="noopener">《Golang之如何轻松化解defer的温柔陷阱》</a>。这篇文章发出后不久就被<code>GoCN</code>的每日新闻收录了，然后就被Go夜读群的大佬杨文看到了，之后被邀请去夜读活动分享。</p><p>正式分享前，我又主题阅读了很多文章，以求把defer讲清楚。阅读过程中，我发现但凡深入一点的文章，都会抛出Go汇编语言。于是就去搜索资料，无奈相关的资料太少，看得云里雾里，最后到了真正要分享的时候也没有完全弄清楚。</p><p>夜读活动结束之后，杨大发布了由春晖大神带来的夜读分享预告：<code>《plan9 汇编入门，带你打通应用和底层》</code>。我得知这个消息后，非常激动！终于有牛人可以讲讲Go汇编语言了，听完之后估计会有很大提升，也能搞懂defer的底层原理了！</p><p>接着，我发现，春晖大神竟然和我在同一个公司！我在公司内网上搜到了他写的plan9汇编相关文章，发布到Go夜读的github上。我提前花时间预习完了文章，整理出了遇到的问题。</p><p>周六晚上9点准时开讲，曹大的准备很充分！原来1个小时的时间被拉长到了2个多小时，而曹大精力和反应一直很迅速，问的问题很快就能得到回答。我全程和曹大直接对话，感觉简直不要太爽！</p><p>这篇文章既是对这次夜读的总结，也是为了宣传一下Go夜读活动。那里是一群有追求的人，他们每周都会聚在一起，通过网络，探讨Go语言的方方面面。我相信，参与的人都会有很多不同的收获。</p><p>我直接参与的Go夜读活动有三期，一期分享，两期听讲，每次都有很多的收获。</p><h1 id="自我介绍的技巧"><a href="#自我介绍的技巧" class="headerlink" title="自我介绍的技巧"></a>自我介绍的技巧</h1><p>很多人都不知道怎么做好一个自我介绍，要么含糊其辞，介绍完大家都不知道你讲了什么；要么说了半天无效的信息，大家并不关心的事情，搞得很尴尬。 其实自我介绍没那么难，掌握套路后，是可以做得很好的！</p><p>我在上上期Go夜读分享的时候，用一张PPT完成了自我介绍。包含了四个方面：<code>个人基本信息</code>、<code>出现在此时此地的原因</code>、<code>我能带来的帮助</code>、<code>我希望得到的帮助</code>。</p><p><code>个人基本信息</code>包括你叫什么名字，是哪里人，在什么地方工作，毕业于哪个学校，有什么兴趣爱好……这些基本的属性。这些信息可以让大家快速形成对你的直观认识。</p><p><code>出现在此时此地的原因</code>，可以讲解你的故事。你在什么地方通过什么人知道了这个活动，然后因为什么打动你来参加……通过故事可以迅速拉近与现场其他参与者的距离。</p><p><code>我能带来的帮助</code>，参加活动的人都是想获取一些东西的：知识、经验、见闻等等。但是，我们不能只索取，不付出。因此，可以讲讲你可以提供的帮助。比如我可以联系场地，我会写宣传文章等等，你可以讲出你独特的价值。</p><p><code>我希望得到的帮助</code>。每个参与的人都希望从活动中获得自己想要的东西，正是因为此，这个活动对于参与者才有意义，也才会持续下去的动力。</p><p>这四个方面，可以组成一个非常精彩的自我介绍。它最早是我在听罗胖的《罗辑思维》听到的，我把它写进了我的<code>人生算法</code>里，今天推荐给大家。希望大家以后在需要自我介绍的场合有话可说，而且能说的精彩。</p><p><img src="https://user-images.githubusercontent.com/7698088/54608061-e3d77000-4a8a-11e9-95a3-7484f94b959b.png" alt="自我介绍"></p><h1 id="硬核知识点"><a href="#硬核知识点" class="headerlink" title="硬核知识点"></a>硬核知识点</h1><h2 id="什么是plan9汇编"><a href="#什么是plan9汇编" class="headerlink" title="什么是plan9汇编"></a>什么是plan9汇编</h2><p>我们知道，CPU是只认二进制指令的，也就是一串的0101；人类无法记住这些二进制码，于是发明了汇编语言。汇编语言实际上是二进制指令的文本形式，它与指令可以一一对应。</p><p>每一种CPU指令都是不一样的，因此对应的汇编语言也就不一样。人类写完汇编语言后，把它转换成二进制码，就可以被机器执行了。转换的动作由编译器完成。</p><blockquote><p>Go语言的编译器和汇编器都带了一个-S参数，可以查看生成的最终目标代码。通过对比目标代码和原始的Go语言或Go汇编语言代码的差异可以加深对底层实现的理解。</p></blockquote><p>Go汇编语言实际上来源于plan9汇编语言，而plan9汇编语言最初来源于Go语言作者之一的Ken Thompson为plan9系统所写的C语言编译器输出的汇编伪代码。这里强烈推荐一下春晖大神的新书《Go语言高级编程》，即将上市，电子版的点击阅读原文可以看到地址，书中有一整个章节讲Go的汇编语言，非常精彩！</p><p>理解Go的汇编语言，哪怕只是一点点，都能对Go的运行机制有更深入的理解。比如我们以前讲的defer，如果从Go源码编译后的汇编代码来看，就能深刻地掌握它的底层原理。再比如，很多文章都会分析Go的函数参数传递都是值传递，如果把汇编代码秀出来，很容易就能得出结论。</p><h2 id="汇编角度看函数调用及返回过程"><a href="#汇编角度看函数调用及返回过程" class="headerlink" title="汇编角度看函数调用及返回过程"></a>汇编角度看函数调用及返回过程</h2><p>假设我们有一个这样年幼无知的例子，求两个int的和，Go源码如下：</p><pre class=" language-golang"><code class="language-golang">package mainfunc main() {    _ = add(3,5)}func add(a, b int) int {    return a+b}</code></pre><p>使用如下命令得到汇编代码：</p><pre class=" language-shell"><code class="language-shell">go tool compile -S main.go</code></pre><p><code>go tool compile</code>命令用于调用Go语言提供的底层命令工具，其中<code>-S</code>参数表示输出汇编格式。</p><p>我们现在只关心add函数的汇编代码：</p><pre class=" language-asm"><code class="language-asm">"".add STEXT nosplit size=19 args=0x18 locals=0x0        0x0000 00000 (main.go:7)        TEXT    "".add(SB), NOSPLIT, $0-24        0x0000 00000 (main.go:7)        FUNCDATA        $0, gclocals·54241e171da8af6ae173d69da0236748(SB)        0x0000 00000 (main.go:7)        FUNCDATA        $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)        0x0000 00000 (main.go:7)        MOVQ    "".b+16(SP), AX        0x0005 00005 (main.go:7)        MOVQ    "".a+8(SP), CX        0x000a 00010 (main.go:8)        ADDQ    CX, AX        0x000d 00013 (main.go:8)        MOVQ    AX, "".~r2+24(SP)        0x0012 00018 (main.go:8)        RET</code></pre><p>看不懂没关系，我目前也不是全部都懂，但是对于理解一个函数调用的整体过程而言，足够了。</p><pre class=" language-asm"><code class="language-asm">0x0000 00000 (main.go:7)        TEXT    "".add(SB), NOSPLIT, $0-24</code></pre><p>这一行表示定义<code>add</code>这个函数，最后的数字<code>$0-24</code>，其中<code>0</code>表示函数栈帧大小为0；<code>24</code>表示参数及返回值的大小：参数是2个int型变量，返回值是1个int型变量，共24字节。</p><p>再看中间这四行：</p><pre class=" language-asm"><code class="language-asm">        0x0000 00000 (main.go:7)        MOVQ    "".b+16(SP), AX        0x0005 00005 (main.go:7)        MOVQ    "".a+8(SP), CX        0x000a 00010 (main.go:8)        ADDQ    CX, AX        0x000d 00013 (main.go:8)        MOVQ    AX, "".~r2+24(SP)</code></pre><p>代码片段中的第1行，将第2个参数<code>b</code>搬到<code>AX</code>寄存器；第2行将1个参数<code>a</code>搬到寄存器<code>CX</code>；第3行将<code>a</code>和<code>b</code>相加，相加的结果搬到<code>AX</code>；最后一行，将结果搬到返回参数的地址，这段汇编代码非常简单，来看一下函数调用者和被调者的栈帧图：</p><p>(SP)指栈顶，b+16(SP)表示裸骑1的位置，从SP往上增加16个字节，注意，前面的b仅表示一个标号；同样，a+8(SP)表示实参0；~r2+24(SP)则表示返回值的位置。</p><p>具体可以看下面的图：</p><p><img src="https://user-images.githubusercontent.com/7698088/54614544-8c8bcc80-4a97-11e9-9e68-61be5e6f5085.png" alt="add函数栈帧"></p><p>上面add函数的栈帧大小为0，其实更一般的调用者与被调用者的栈帧示意图如下：</p><p><img src="https://user-images.githubusercontent.com/7698088/54598545-aca99480-4a73-11e9-8870-99ab8ee9fcb7.png" alt="栈帧"></p><p>最后，执行<code>RET</code>指令。这一步把被调用函数<code>add</code>栈帧清零,接着，弹出栈顶的<code>返回地址</code>，把它赋给指令寄存器<code>rip</code>，而<code>返回地址</code>就是<code>main</code>函数里调用<code>add</code>函数的下一行。</p><p>于是，又回到了<code>main</code>函数的执行环境，<code>add</code>函数的栈帧也被销毁了。但是注意，这块内存是没有被清零的，清零动作是之后再次申请这块内存的时候要做的事。比如，声明了一个int型变量，它的默认值是0，清零的动作是在这里完成的。</p><p>这样，main函数完成了函数调用，也拿到了返回值，完美。</p><h2 id="汇编角度看slice"><a href="#汇编角度看slice" class="headerlink" title="汇编角度看slice"></a>汇编角度看slice</h2><p>再来看一个例子，我们来看看<code>slice</code>的底层到底是什么。</p><pre class=" language-golang"><code class="language-golang">package mainfunc main() {    s := make([]int, 3, 10)    _ = f(s)}func f(s []int) int {    return s[1]}</code></pre><p>用上面同样的命令得到汇编代码，我们只关注<code>f</code>函数的汇编代码：</p><pre class=" language-asm"><code class="language-asm">"".f STEXT nosplit size=53 args=0x20 locals=0x8        // 栈帧大小为8字节，参数和返回值为32字节        0x0000 00000 (main.go:8)        TEXT    "".f(SB), NOSPLIT, $8-32        // SP栈顶指针下移8字节        0x0000 00000 (main.go:8)        SUBQ    $8, SP        // 将BP寄存器的值入栈        0x0004 00004 (main.go:8)        MOVQ    BP, (SP)        // 将新的栈顶地址保存到BP寄存器        0x0008 00008 (main.go:8)        LEAQ    (SP), BP        0x000c 00012 (main.go:8)        FUNCDATA        $0, gclocals·4032f753396f2012ad1784f398b170f4(SB)        0x000c 00012 (main.go:8)        FUNCDATA        $1, gclocals·69c1753bd5f81501d95132d08af04464(SB)        // 取出slice的长度len        0x000c 00012 (main.go:8)        MOVQ    "".s+24(SP), AX        // 比较索引1是否超过len        0x0011 00017 (main.go:9)        CMPQ    AX, $1        // 如果超过len，越界了。跳转到46        0x0015 00021 (main.go:9)        JLS     46        // 将slice的数据首地址加载到AX寄存器        0x0017 00023 (main.go:9)        MOVQ    "".s+16(SP), AX        // 将第8byte地址的元素保存到AX寄存器，也就是salaries[1]        0x001c 00028 (main.go:9)        MOVQ    8(AX), AX        // 将结果拷贝到返回参数的位置（y）        0x0020 00032 (main.go:9)        MOVQ    AX, "".~r1+40(SP)        // 恢复BP的值        0x0025 00037 (main.go:9)        MOVQ    (SP), BP        // SP向上移动8个字节        0x0029 00041 (main.go:9)        ADDQ    $8, SP        // 返回        0x002d 00045 (main.go:9)        RET        0x002e 00046 (main.go:9)        PCDATA  $0, $1        // 越界，panic        0x002e 00046 (main.go:9)        CALL    runtime.panicindex(SB)        0x0033 00051 (main.go:9)        UNDEF        0x0000 48 83 ec 08 48 89 2c 24 48 8d 2c 24 48 8b 44 24  H...H.,$H.,$H.D$        0x0010 18 48 83 f8 01 76 17 48 8b 44 24 10 48 8b 40 08  .H...v.H.D$.H.@.        0x0020 48 89 44 24 28 48 8b 2c 24 48 83 c4 08 c3 e8 00  H.D$(H.,$H......        0x0030 00 00 00 0f 0b                                   .....        rel 47+4 t=8 runtime.panicindex+0</code></pre><p>通过上面的汇编代码，我们画出函数调用的栈帧图：</p><p><img src="https://user-images.githubusercontent.com/7698088/54599149-fe065380-4a74-11e9-800b-9a12db0c730c.png" alt="f函数栈帧"></p><p>我们可以清晰地看到，一个slice本质上是用一个数据首地址，一个长度Len，一个容量Cap。所以在参数是slice的函数里，对slice的操作会影响到实参的slice。</p><h1 id="正确参与Go夜读活动的方式"><a href="#正确参与Go夜读活动的方式" class="headerlink" title="正确参与Go夜读活动的方式"></a>正确参与Go夜读活动的方式</h1><p>最后再说一下Go夜读活动的方式和目标。引自Go夜读的github说明文件：</p><blockquote><p>由一个主讲人带着大家一起去阅读 Go 源代码，一起去啃那些难啃的算法、学习代码里面的奇淫技巧，遇到问题或者有疑惑了，我们可以一起去检索，解答这些问题。我们可以一起学习，共同成长。</p></blockquote><blockquote><p>我们希望可以推进大家深入了解 Go ，快速成长为资深的 Gopher 。我们希望每次来了的人和没来的人都能够有收获，成长。</p></blockquote><p>前面我说Go夜读活动的小伙伴是一群有追求的人，这里我也指出一些问题吧。就我参与的三期来看，虽然zoom接入人数很多，高峰期50+人，但是全过程大家交流比较少，基本上是主讲人一个人在那自嗨。春晖大佬讲的那期，只有我全程提问。感觉像是我们两个人在对话，我的问题弄清楚了，只是不知道其他的参与同学如何？</p><p>我再给分享者和参与者提一些建议吧：</p><p>对于分享者，事先做好充足的准备，可以在文章里列出主要的点，放在github里，参考春晖大佬的plan9汇编讲义；最重要的一点，分享前给大家提供一份预习资料。</p><p>对于参与者，能获得最多收获的方式就是会前预习，会中积极提问，会后复习总结发散。另外，强烈建议参与者会前要准备至少一个问题，有针对性地听，才会有收获。会中也要积极提问，这也是对主讲者的反馈，不至于主讲者觉得只有自己在对着电脑讲。</p><p>最后，欢迎每一个学习Go语言的同学都能来Go夜读看看！点击阅读原文可以看到文章里提到的所有资料，包括上期曹大plan9汇编的视频回放，不容错过！</p><p><img src="https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png" alt="QR"></p><h1 id="阅读原文"><a href="#阅读原文" class="headerlink" title="阅读原文"></a>阅读原文</h1><p><a href="https://github.com/developer-learning/reading-go">夜读地址</a><br><a href="https://github.com/cch123/asmshare/blob/master/layout.md">《plan9 汇编入门，带你打通应用和底层》讲义</a><br><a href="https://www.bilibili.com/video/av46494102" target="_blank" rel="noopener">《plan9 汇编入门，带你打通应用和底层》视频地址</a><br><a href="https://chai2010.cn/advanced-go-programming-book/" target="_blank" rel="noopener">曹大的Go高级编程书，纸质书即将出版</a><br><a href="https://github.com/cch123/golang-notes">曹大go源码阅读</a><br><a href="http://xargin.com/" target="_blank" rel="noopener">曹大博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上周六晚上，我参加了“Go夜读”活动，这期主要讲Go汇编语言，由滴滴大佬曹春晖大神主讲。活动结束后，我感觉打通了任督二脉。活动从晚上9点到深夜11点多，全程深度参与，大呼过瘾，以至于活动结束之后，久久不能平静。&lt;/p&gt;
&lt;p&gt;可以说理解了Go汇编语言，就可以让我们对Go的理
      
    
    </summary>
    
      <category term="编程语言" scheme="https://github.com/qcrao/qcrao.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="golang" scheme="https://github.com/qcrao/qcrao.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>图解Go语言内存分配</title>
    <link href="https://github.com/qcrao/qcrao.github.io/2019/03/13/graphic-go-memory-allocation/"/>
    <id>https://github.com/qcrao/qcrao.github.io/2019/03/13/graphic-go-memory-allocation/</id>
    <published>2019-03-13T01:41:00.000Z</published>
    <updated>2019-07-24T11:01:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言内置运行时（就是runtime），抛弃了传统的内存分配方式，改为自主管理。这样可以自主地实现更好的内存使用模式，比如内存池、预分配等等。这样，不会每次内存分配都需要进行系统调用。</p><p>Golang运行时的内存分配算法主要源自 Google 为 C 语言开发的<code>TCMalloc算法</code>，全称<code>Thread-Caching Malloc</code>。核心思想就是把内存分为多级管理，从而降低锁的粒度。它将可用的堆内存采用二级分配的方式进行管理：每个线程都会自行维护一个独立的内存池，进行内存分配时优先从该内存池中分配，当内存池不足时才会向全局内存池申请，以避免不同线程对全局内存池的频繁竞争。</p><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>Go在程序启动的时候，会先向操作系统申请一块内存（注意这时还只是一段虚拟的地址空间，并不会真正地分配内存），切成小块后自己进行管理。</p><p>申请到的内存块被分配了三个区域，在X64上分别是512MB，16GB，512GB大小。</p><p><img src="https://user-images.githubusercontent.com/7698088/54165891-9e6cde80-449d-11e9-8947-14e6f75f4089.png" alt="堆区总览"></p><p><code>arena区域</code>就是我们所谓的堆区，Go动态分配的内存都是在这个区域，它把内存分割成<code>8KB</code>大小的页，一些页组合起来称为<code>mspan</code>。</p><p><code>bitmap区域</code>标识<code>arena</code>区域哪些地址保存了对象，并且用<code>4bit</code>标志位表示对象是否包含指针、<code>GC</code>标记信息。<code>bitmap</code>中一个<code>byte</code>大小的内存对应<code>arena</code>区域中4个指针大小（指针大小为 8B ）的内存，所以<code>bitmap</code>区域的大小是<code>512GB/(4*8B)=16GB</code>。</p><p><img src="https://user-images.githubusercontent.com/7698088/54197565-3a7b0200-44ff-11e9-92e2-34185ee3e0bc.png" alt="bitmap arena"></p><p><img src="https://user-images.githubusercontent.com/7698088/54197295-85484a00-44fe-11e9-9c77-9836120b8454.png" alt="bitmap arena"></p><p>从上图其实还可以看到bitmap的高地址部分指向arena区域的低地址部分，也就是说bitmap的地址是由高地址向低地址增长的。</p><p><code>spans区域</code>存放<code>mspan</code>（也就是一些<code>arena</code>分割的页组合起来的内存管理基本单元，后文会再讲）的指针，每个指针对应一页，所以<code>spans</code>区域的大小就是<code>512GB/8KB*8B=512MB</code>。除以8KB是计算<code>arena</code>区域的页数，而最后乘以8是计算<code>spans</code>区域所有指针的大小。创建<code>mspan</code>的时候，按页填充对应的<code>spans</code>区域，在回收<code>object</code>时，根据地址很容易就能找到它所属的<code>mspan</code>。</p><h1 id="内存管理单元"><a href="#内存管理单元" class="headerlink" title="内存管理单元"></a>内存管理单元</h1><p><code>mspan</code>：Go中内存管理的基本单元，是由一片连续的<code>8KB</code>的页组成的大块内存。注意，这里的页和操作系统本身的页并不是一回事，它一般是操作系统页大小的几倍。一句话概括：<code>mspan</code>是一个包含起始地址、<code>mspan</code>规格、页的数量等内容的双端链表。</p><p>每个<code>mspan</code>按照它自身的属性<code>Size Class</code>的大小分割成若干个<code>object</code>，每个<code>object</code>可存储一个对象。并且会使用一个位图来标记其尚未使用的<code>object</code>。属性<code>Size Class</code>决定<code>object</code>大小，而<code>mspan</code>只会分配给和<code>object</code>尺寸大小接近的对象，当然，对象的大小要小于<code>object</code>大小。还有一个概念：<code>Span Class</code>，它和<code>Size Class</code>的含义差不多，</p><pre class=" language-c"><code class="language-c">Size_Class <span class="token operator">=</span> Span_Class <span class="token operator">/</span> <span class="token number">2</span></code></pre><p>这是因为其实每个 <code>Size Class</code>有两个<code>mspan</code>，也就是有两个<code>Span Class</code>。其中一个分配给含有指针的对象，另一个分配给不含有指针的对象。这会给垃圾回收机制带来利好，之后的文章再谈。</p><p>如下图，<code>mspan</code>由一组连续的页组成，按照一定大小划分成<code>object</code>。</p><p><img src="https://user-images.githubusercontent.com/7698088/54070690-0b198a80-429e-11e9-8838-eef9cd160f5c.png" alt="page mspan"></p><p>Go1.9.2里<code>mspan</code>的<code>Size Class</code>共有67种，每种<code>mspan</code>分割的object大小是8*2n的倍数，这个是写死在代码里的：</p><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// path: /usr/local/go/src/runtime/sizeclasses.go</span><span class="token keyword">const</span> _NumSizeClasses <span class="token operator">=</span> <span class="token number">67</span><span class="token keyword">var</span> class_to_size <span class="token operator">=</span> <span class="token punctuation">[</span>_NumSizeClasses<span class="token punctuation">]</span><span class="token builtin">uint16</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">48</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">,</span> <span class="token number">96</span><span class="token punctuation">,</span> <span class="token number">112</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">,</span> <span class="token number">144</span><span class="token punctuation">,</span> <span class="token number">160</span><span class="token punctuation">,</span> <span class="token number">176</span><span class="token punctuation">,</span> <span class="token number">192</span><span class="token punctuation">,</span> <span class="token number">208</span><span class="token punctuation">,</span> <span class="token number">224</span><span class="token punctuation">,</span> <span class="token number">240</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">288</span><span class="token punctuation">,</span> <span class="token number">320</span><span class="token punctuation">,</span> <span class="token number">352</span><span class="token punctuation">,</span> <span class="token number">384</span><span class="token punctuation">,</span> <span class="token number">416</span><span class="token punctuation">,</span> <span class="token number">448</span><span class="token punctuation">,</span> <span class="token number">480</span><span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">,</span> <span class="token number">576</span><span class="token punctuation">,</span> <span class="token number">640</span><span class="token punctuation">,</span> <span class="token number">704</span><span class="token punctuation">,</span> <span class="token number">768</span><span class="token punctuation">,</span> <span class="token number">896</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">,</span> <span class="token number">1152</span><span class="token punctuation">,</span> <span class="token number">1280</span><span class="token punctuation">,</span> <span class="token number">1408</span><span class="token punctuation">,</span> <span class="token number">1536</span><span class="token punctuation">,</span><span class="token number">1792</span><span class="token punctuation">,</span> <span class="token number">2048</span><span class="token punctuation">,</span> <span class="token number">2304</span><span class="token punctuation">,</span> <span class="token number">2688</span><span class="token punctuation">,</span> <span class="token number">3072</span><span class="token punctuation">,</span> <span class="token number">3200</span><span class="token punctuation">,</span> <span class="token number">3456</span><span class="token punctuation">,</span> <span class="token number">4096</span><span class="token punctuation">,</span> <span class="token number">4864</span><span class="token punctuation">,</span> <span class="token number">5376</span><span class="token punctuation">,</span> <span class="token number">6144</span><span class="token punctuation">,</span> <span class="token number">6528</span><span class="token punctuation">,</span> <span class="token number">6784</span><span class="token punctuation">,</span> <span class="token number">6912</span><span class="token punctuation">,</span> <span class="token number">8192</span><span class="token punctuation">,</span> <span class="token number">9472</span><span class="token punctuation">,</span> <span class="token number">9728</span><span class="token punctuation">,</span> <span class="token number">10240</span><span class="token punctuation">,</span> <span class="token number">10880</span><span class="token punctuation">,</span> <span class="token number">12288</span><span class="token punctuation">,</span> <span class="token number">13568</span><span class="token punctuation">,</span> <span class="token number">14336</span><span class="token punctuation">,</span> <span class="token number">16384</span><span class="token punctuation">,</span> <span class="token number">18432</span><span class="token punctuation">,</span> <span class="token number">19072</span><span class="token punctuation">,</span> <span class="token number">20480</span><span class="token punctuation">,</span> <span class="token number">21760</span><span class="token punctuation">,</span> <span class="token number">24576</span><span class="token punctuation">,</span> <span class="token number">27264</span><span class="token punctuation">,</span> <span class="token number">28672</span><span class="token punctuation">,</span> <span class="token number">32768</span><span class="token punctuation">}</span></code></pre><p>根据<code>mspan</code>的<code>Size Class</code>可以得到它划分的<code>object</code>大小。 比如<code>Size Class</code>等于3，<code>object</code>大小就是32B。 32B大小的object可以存储对象大小范围在17B~32B的对象。而对于微小对象（小于16B），分配器会将其进行合并，将几个对象分配到同一个<code>object</code>中。</p><p>数组里最大的数是32768，也就是32KB，超过此大小就是大对象了，它会被特别对待，这个稍后会再介绍。顺便提一句，类型<code>Size Class</code>为0表示大对象，它实际上直接由堆内存分配，而小对象都要通过<code>mspan</code>来分配。</p><p>对于mspan来说，它的<code>Size Class</code>会决定它所能分到的页数，这也是写死在代码里的：</p><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// path: /usr/local/go/src/runtime/sizeclasses.go</span><span class="token keyword">const</span> _NumSizeClasses <span class="token operator">=</span> <span class="token number">67</span><span class="token keyword">var</span> class_to_allocnpages <span class="token operator">=</span> <span class="token punctuation">[</span>_NumSizeClasses<span class="token punctuation">]</span><span class="token builtin">uint8</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span></code></pre><p>比如当我们要申请一个<code>object</code>大小为<code>32B</code>的<code>mspan</code>的时候，在class_to_size里对应的索引是3，而索引3在<code>class_to_allocnpages</code>数组里对应的页数就是1。</p><p><code>mspan</code>结构体定义：</p><pre class=" language-golang"><code class="language-golang">// path: /usr/local/go/src/runtime/mheap.gotype mspan struct {    //链表前向指针，用于将span链接起来    next *mspan        //链表前向指针，用于将span链接起来    prev *mspan        // 起始地址，也即所管理页的地址    startAddr uintptr     // 管理的页数    npages uintptr     // 块个数，表示有多少个块可供分配    nelems uintptr     //分配位图，每一位代表一个块是否已分配    allocBits *gcBits     // 已分配块的个数    allocCount uint16     // class表中的class ID，和Size Classs相关    spanclass spanClass      // class表中的对象大小，也即块大小    elemsize uintptr }</code></pre><p>我们将<code>mspan</code>放到更大的视角来看：</p><p><img src="https://user-images.githubusercontent.com/7698088/54192326-a440df00-44f2-11e9-950a-bbdfb7c36e62.png" alt="mspan更大视角"></p><p>上图可以看到有两个<code>S</code>指向了同一个<code>mspan</code>，因为这两个<code>S</code>指向的<code>P</code>是同属一个<code>mspan</code>的。所以，通过<code>arena</code>上的地址可以快速找到指向它的<code>S</code>，通过<code>S</code>就能找到<code>mspan</code>，回忆一下前面我们说的<code>mspan</code>区域的每个指针对应一页。</p><p>假设最左边第一个<code>mspan</code>的<code>Size Class</code>等于10，根据前面的<code>class_to_size</code>数组，得出这个<code>msapn</code>分割的<code>object</code>大小是144B，算出可分配的对象个数是<code>8KB/144B=56.89</code>个，取整56个，所以会有一些内存浪费掉了，Go的源码里有所有<code>Size Class</code>的<code>mspan</code>浪费的内存的大小；再根据<code>class_to_allocnpages</code>数组，得到这个<code>mspan</code>只由1个<code>page</code>组成；假设这个<code>mspan</code>是分配给无指针对象的，那么<code>spanClass</code>等于20。</p><p><code>startAddr</code>直接指向<code>arena</code>区域的某个位置，表示这个<code>mspan</code>的起始地址，<code>allocBits</code>指向一个位图，每位代表一个块是否被分配了对象；<code>allocCount</code>则表示总共已分配的对象个数。</p><p>这样，左起第一个<code>mspan</code>的各个字段参数就如下图所示：</p><p><img src="https://user-images.githubusercontent.com/7698088/54210478-87200680-451a-11e9-98dc-2e5adbb43d4a.png" alt="左起第一个mspan具体值"></p><h1 id="内存管理组件"><a href="#内存管理组件" class="headerlink" title="内存管理组件"></a>内存管理组件</h1><p>内存分配由内存分配器完成。分配器由3种组件构成：<code>mcache</code>, <code>mcentral</code>, <code>mheap</code>。</p><h2 id="mcache"><a href="#mcache" class="headerlink" title="mcache"></a>mcache</h2><p><code>mcache</code>：每个工作线程都会绑定一个mcache，本地缓存可用的<code>mspan</code>资源，这样就可以直接给Goroutine分配，因为不存在多个Goroutine竞争的情况，所以不会消耗锁资源。</p><p><code>mcache</code>的结构体定义：</p><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">//path: /usr/local/go/src/runtime/mcache.go</span><span class="token keyword">type</span> mcache <span class="token keyword">struct</span> <span class="token punctuation">{</span>    alloc <span class="token punctuation">[</span>numSpanClasses<span class="token punctuation">]</span><span class="token operator">*</span>mspan<span class="token punctuation">}</span>numSpanClasses <span class="token operator">=</span> _NumSizeClasses <span class="token operator">&lt;&lt;</span> <span class="token number">1</span></code></pre><p><code>mcache</code>用<code>Span Classes</code>作为索引管理多个用于分配的<code>mspan</code>，它包含所有规格的<code>mspan</code>。它是<code>_NumSizeClasses</code>的2倍，也就是<code>67*2=134</code>，为什么有一个两倍的关系，前面我们提到过：为了加速之后内存回收的速度，数组里一半的<code>mspan</code>中分配的对象不包含指针，另一半则包含指针。</p><p>对于无指针对象的<code>mspan</code>在进行垃圾回收的时候无需进一步扫描它是否引用了其他活跃的对象。 后面的垃圾回收文章会再讲到，这次先到这里。</p><p><img src="https://user-images.githubusercontent.com/7698088/54191324-a86bfd00-44f0-11e9-9039-3b64d39036d9.png" alt="mcache"></p><p><code>mcache</code>在初始化的时候是没有任何<code>mspan</code>资源的，在使用过程中会动态地从<code>mcentral</code>申请，之后会缓存下来。当对象小于等于32KB大小时，使用<code>mcache</code>的相应规格的<code>mspan</code>进行分配。</p><h2 id="mcentral"><a href="#mcentral" class="headerlink" title="mcentral"></a>mcentral</h2><p><code>mcentral</code>：为所有<code>mcache</code>提供切分好的<code>mspan</code>资源。每个<code>central</code>保存一种特定大小的全局<code>mspan</code>列表，包括已分配出去的和未分配出去的。 每个<code>mcentral</code>对应一种<code>mspan</code>，而<code>mspan</code>的种类导致它分割的<code>object</code>大小不同。当工作线程的<code>mcache</code>中没有合适（也就是特定大小的）的<code>mspan</code>时就会从<code>mcentral</code>获取。</p><p><code>mcentral</code>被所有的工作线程共同享有，存在多个Goroutine竞争的情况，因此会消耗锁资源。结构体定义：</p><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">//path: /usr/local/go/src/runtime/mcentral.go</span><span class="token keyword">type</span> mcentral <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 互斥锁</span>    lock mutex     <span class="token comment" spellcheck="true">// 规格</span>    sizeclass <span class="token builtin">int32</span>     <span class="token comment" spellcheck="true">// 尚有空闲object的mspan链表</span>    nonempty mSpanList     <span class="token comment" spellcheck="true">// 没有空闲object的mspan链表，或者是已被mcache取走的msapn链表</span>    empty mSpanList     <span class="token comment" spellcheck="true">// 已累计分配的对象个数</span>    nmalloc <span class="token builtin">uint64</span> <span class="token punctuation">}</span></code></pre><p><img src="https://user-images.githubusercontent.com/7698088/54211962-2219e000-451d-11e9-85e1-0e8200925fa5.png" alt="mcentral"></p><p><code>empty</code>表示这条链表里的<code>mspan</code>都被分配了<code>object</code>，或者是已经被<code>cache</code>取走了的<code>mspan</code>，这个<code>mspan</code>就被那个工作线程独占了。而<code>nonempty</code>则表示有空闲对象的<code>mspan</code>列表。每个<code>central</code>结构体都在<code>mheap</code>中维护。</p><p>简单说下<code>mcache</code>从<code>mcentral</code>获取和归还<code>mspan</code>的流程：</p><ul><li><p>获取<br>加锁；从<code>nonempty</code>链表找到一个可用的<code>mspan</code>；并将其从<code>nonempty</code>链表删除；将取出的<code>mspan</code>加入到<code>empty</code>链表；将<code>mspan</code>返回给工作线程；解锁。</p></li><li><p>归还<br>加锁；将<code>mspan</code>从<code>empty</code>链表删除；将<code>mspan</code>加入到<code>nonempty</code>链表；解锁。</p></li></ul><h2 id="mheap"><a href="#mheap" class="headerlink" title="mheap"></a>mheap</h2><p><code>mheap</code>：代表Go程序持有的所有堆空间，Go程序使用一个<code>mheap</code>的全局对象<code>_mheap</code>来管理堆内存。</p><p>当<code>mcentral</code>没有空闲的<code>mspan</code>时，会向<code>mheap</code>申请。而<code>mheap</code>没有资源时，会向操作系统申请新内存。<code>mheap</code>主要用于大对象的内存分配，以及管理未切割的<code>mspan</code>，用于给<code>mcentral</code>切割成小对象。</p><p>同时我们也看到，<code>mheap</code>中含有所有规格的<code>mcentral</code>，所以，当一个<code>mcache</code>从<code>mcentral</code>申请<code>mspan</code>时，只需要在独立的<code>mcentral</code>中使用锁，并不会影响申请其他规格的<code>mspan</code>。</p><p><code>mheap</code>结构体定义：</p><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">//path: /usr/local/go/src/runtime/mheap.go</span><span class="token keyword">type</span> mheap <span class="token keyword">struct</span> <span class="token punctuation">{</span>    lock mutex    <span class="token comment" spellcheck="true">// spans: 指向mspans区域，用于映射mspan和page的关系</span>    spans <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>mspan     <span class="token comment" spellcheck="true">// 指向bitmap首地址，bitmap是从高地址向低地址增长的</span>    bitmap <span class="token builtin">uintptr</span>     <span class="token comment" spellcheck="true">// 指示arena区首地址</span>    arena_start <span class="token builtin">uintptr</span>     <span class="token comment" spellcheck="true">// 指示arena区已使用地址位置</span>    arena_used  <span class="token builtin">uintptr</span>     <span class="token comment" spellcheck="true">// 指示arena区末地址</span>    arena_end   <span class="token builtin">uintptr</span>     central <span class="token punctuation">[</span><span class="token number">67</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token keyword">struct</span> <span class="token punctuation">{</span>        mcentral mcentral        pad <span class="token punctuation">[</span>sys<span class="token punctuation">.</span>CacheLineSize <span class="token operator">-</span> unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span>mcentral<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">%</span>sys<span class="token punctuation">.</span>CacheLineSize<span class="token punctuation">]</span><span class="token builtin">byte</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="https://user-images.githubusercontent.com/7698088/54213273-1cbd9500-451f-11e9-93e4-28f39615b6a2.png" alt="mheap"></p><p>上图我们看到，bitmap和arena_start指向了同一个地址，这是因为bitmap的地址是从高到低增长的，所以他们指向的内存位置相同。</p><h1 id="内存分配流程"><a href="#内存分配流程" class="headerlink" title="内存分配流程"></a>内存分配流程</h1><p>上一篇文章<a href="https://www.cnblogs.com/qcrao-2018/p/10453260.html" target="_blank" rel="noopener">《Golang之变量去哪儿》</a>中我们提到了，变量是在栈上分配还是在堆上分配，是由逃逸分析的结果决定的。通常情况下，编译器是倾向于将变量分配到栈上的，因为它的开销小，最极端的就是”zero garbage”，所有的变量都会在栈上分配，这样就不会存在内存碎片，垃圾回收之类的东西。</p><p>Go的内存分配器在分配对象时，根据对象的大小，分成三类：小对象（小于等于16B）、一般对象（大于16B，小于等于32KB）、大对象（大于32KB）。</p><p>大体上的分配流程：</p><ul><li><blockquote><p>32KB 的对象，直接从mheap上分配；</p></blockquote></li><li>&lt;=16B 的对象使用mcache的tiny分配器分配；</li><li>(16B,32KB] 的对象，首先计算对象的规格大小，然后使用mcache中相应规格大小的mspan分配；<ul><li>如果mcache没有相应规格大小的mspan，则向mcentral申请</li><li>如果mcentral没有相应规格大小的mspan，则向mheap申请</li><li>如果mheap中也没有合适大小的mspan，则向操作系统申请</li></ul></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Go语言的内存分配非常复杂，它的一个原则就是能复用的一定要复用。源码很难追，后面可能会再来一篇关于内存分配的源码阅读相关的文章。简单总结一下本文吧。</p><p>文章从一个比较粗的角度来看Go的内存分配，并没有深入细节。一般而言，了解它的原理，到这个程度也可以了。</p><ul><li>Go在程序启动时，会向操作系统申请一大块内存，之后自行管理。</li><li>Go内存管理的基本单元是mspan，它由若干个页组成，每种mspan可以分配特定大小的object。</li><li>mcache, mcentral, mheap是Go内存管理的三大组件，层层递进。mcache管理线程在本地缓存的mspan；mcentral管理全局的mspan供所有线程使用；mheap管理Go的所有动态分配内存。</li><li>极小对象会分配在一个object中，以节省资源，使用tiny分配器分配内存；一般小对象通过mspan分配内存；大对象则直接由mheap分配内存。</li></ul><p><img src="https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png" alt="QR"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【简单易懂，非常清晰】<a href="https://yq.aliyun.com/articles/652551" target="_blank" rel="noopener">https://yq.aliyun.com/articles/652551</a></p><p>【内存分配器的初始化过程，分配流程图很详细】<a href="https://www.jianshu.com/p/47691d870756" target="_blank" rel="noopener">https://www.jianshu.com/p/47691d870756</a></p><p>【全局的图】<a href="https://swanspouse.github.io/2018/08/22/golang-memory-model/" target="_blank" rel="noopener">https://swanspouse.github.io/2018/08/22/golang-memory-model/</a></p><p>【雨痕 Go1.5源码阅读】<a href="https://github.com/qyuhen/book">https://github.com/qyuhen/book</a></p><p>【图不错】<a href="https://www.jianshu.com/p/47691d870756" target="_blank" rel="noopener">https://www.jianshu.com/p/47691d870756</a></p><p>【整体感】<a href="https://juejin.im/post/59f2e19f5188253d6816d504" target="_blank" rel="noopener">https://juejin.im/post/59f2e19f5188253d6816d504</a></p><p>【源码解读】<a href="http://legendtkl.com/2017/04/02/golang-alloc/" target="_blank" rel="noopener">http://legendtkl.com/2017/04/02/golang-alloc/</a></p><p>【重点推荐 深入到晶体管了 图很好】<a href="https://www.linuxzen.com/go-memory-allocator-visual-guide.html" target="_blank" rel="noopener">https://www.linuxzen.com/go-memory-allocator-visual-guide.html</a></p><p>【总体描述对象分配流程】<a href="http://gocode.cc/project/4/article/103" target="_blank" rel="noopener">http://gocode.cc/project/4/article/103</a></p><p>【实际Linux命令】<a href="https://mikespook.com/2014/12/%E7%90%86%E8%A7%A3-go-%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">https://mikespook.com/2014/12/%E7%90%86%E8%A7%A3-go-%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8/</a></p><p>【整体流程图 对象分配函数调用链路】<a href="http://blog.newbmiao.com/2018/08/20/go-source-analysis-of-memory-alloc.html" target="_blank" rel="noopener">http://blog.newbmiao.com/2018/08/20/go-source-analysis-of-memory-alloc.html</a></p><p>【源码讲解 非常细致】<a href="https://www.cnblogs.com/zkweb/p/7880099.html" target="_blank" rel="noopener">https://www.cnblogs.com/zkweb/p/7880099.html</a></p><p>【源码阅读】<a href="https://zhuanlan.zhihu.com/p/34930748" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34930748</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Go语言内置运行时（就是runtime），抛弃了传统的内存分配方式，改为自主管理。这样可以自主地实现更好的内存使用模式，比如内存池、预分配等等。这样，不会每次内存分配都需要进行系统调用。&lt;/p&gt;
&lt;p&gt;Golang运行时的内存分配算法主要源自 Google 为 C 语言开发
      
    
    </summary>
    
      <category term="编程语言" scheme="https://github.com/qcrao/qcrao.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="golang" scheme="https://github.com/qcrao/qcrao.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang之变量去哪儿</title>
    <link href="https://github.com/qcrao/qcrao.github.io/2019/03/01/where-go-variables-go/"/>
    <id>https://github.com/qcrao/qcrao.github.io/2019/03/01/where-go-variables-go/</id>
    <published>2019-03-01T00:30:00.000Z</published>
    <updated>2019-07-24T09:48:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>写过C/C++的同学都知道，调用著名的malloc和new函数可以在堆上分配一块内存，这块内存的使用和销毁的责任都在程序员。一不小心，就会发生内存泄露，搞得胆战心惊。</p><p>切换到Golang后，基本不会担心内存泄露了。虽然也有new函数，但是使用new函数得到的内存不一定就在堆上。堆和栈的区别对程序员“模糊化”了，当然这一切都是Go编译器在背后帮我们完成的。</p><p>一个变量是在堆上分配，还是在栈上分配，是经过编译器的<code>逃逸分析</code>之后得出的结论。</p><p>这篇文章，就将带领大家一起去探索<code>逃逸分析</code>——变量到底去哪儿，堆还是栈？</p><h1 id="什么是逃逸分析"><a href="#什么是逃逸分析" class="headerlink" title="什么是逃逸分析"></a>什么是逃逸分析</h1><p>以前写C/C++代码时，为了提高效率，常常将<code>pass-by-value</code>（传值）“升级”成<code>pass-by-reference</code>，企图避免构造函数的运行，并且直接返回一个指针。</p><p>你一定还记得，这里隐藏了一个很大的坑：在函数内部定义了一个局部变量，然后返回这个局部变量的地址（指针）。这些局部变量是在栈上分配的（静态内存分配），一旦函数执行完毕，变量占据的内存会被销毁，任何对这个返回值作的动作（如解引用），都将扰乱程序的运行，甚至导致程序直接崩溃。比如下面的这段代码：</p><pre class=" language-C"><code class="language-C">int *foo ( void )   {       int t = 3;    return &t;} </code></pre><p>有些同学可能知道上面这个坑，用了个更聪明的做法：在函数内部使用new函数构造一个变量（动态内存分配），然后返回此变量的地址。因为变量是在堆上创建的，所以函数退出时不会被销毁。但是，这样就行了吗？new出来的对象该在何时何地delete呢？调用者可能会忘记delete或者直接拿返回值传给其他函数，之后就再也不能delete它了，也就是发生了内存泄露。关于这个坑，大家可以去看看《Effective C++》条款21，讲得非常好！</p><p>C++是公认的语法最复杂的语言，据说没有人可以完全掌握C++的语法。而这一切在Go语言中就大不相同了。像上面示例的C++代码放到Go里，没有任何问题。</p><p>你表面的光鲜，一定是背后有很多人为你撑起的！Go语言里就是编译器的<code>逃逸分析</code>。它是编译器执行静态代码分析后，对内存管理进行的优化和简化。</p><p>在编译原理中，分析指针动态范围的方法称之为<code>逃逸分析</code>。通俗来讲，当一个对象的指针被多个方法或线程引用时，我们称这个指针发生了逃逸。</p><p>更简单来说，<code>逃逸分析</code>决定一个变量是分配在堆上还是分配在栈上。</p><h1 id="为什么要逃逸分析"><a href="#为什么要逃逸分析" class="headerlink" title="为什么要逃逸分析"></a>为什么要逃逸分析</h1><p>前面讲的C/C++中出现的问题，在Go中作为一个语言特性被大力推崇。真是C/C++之砒霜Go之蜜糖！</p><p>C/C++中动态分配的内存需要我们手动释放，导致猿们平时在写程序时，如履薄冰。这样做有他的好处：程序员可以完全掌控内存。但是缺点也是很多的：经常出现忘记释放内存，导致内存泄露。所以，很多现代语言都加上了垃圾回收机制。</p><p>Go的垃圾回收，让堆和栈对程序员保持透明。真正解放了程序员的双手，让他们可以专注于业务，“高效”地完成代码编写。把那些内存管理的复杂机制交给编译器，而程序员可以去享受生活。</p><p><code>逃逸分析</code>这种“骚操作”把变量合理地分配到它该去的地方，“找准自己的位置”。即使你是用new申请到的内存，如果我发现你竟然在退出函数后没有用了，那么就把你丢到栈上，毕竟栈上的内存分配比堆上快很多；反之，即使你表面上只是一个普通的变量，但是经过逃逸分析后发现在退出函数之后还有其他地方在引用，那我就把你分配到堆上。真正地做到“按需分配”，提前实现共产主义！</p><p>如果变量都分配到堆上，堆不像栈可以自动清理。它会引起Go频繁地进行垃圾回收，而垃圾回收会占用比较大的系统开销（占用CPU容量的25%）。</p><p>堆和栈相比，堆适合不可预知大小的内存分配。但是为此付出的代价是分配速度较慢，而且会形成内存碎片。栈内存分配则会非常快。栈分配内存只需要两个CPU指令：“PUSH”和“RELEASSE”，分配和释放；而堆分配内存首先需要去找到一块大小合适的内存块，之后要通过垃圾回收才能释放。</p><p>通过逃逸分析，可以尽量把那些不需要分配到堆上的变量直接分配到栈上，堆上的变量少了，会减轻分配堆内存的开销，同时也会减少gc的压力，提高程序的运行速度。</p><h1 id="逃逸分析是怎么完成的"><a href="#逃逸分析是怎么完成的" class="headerlink" title="逃逸分析是怎么完成的"></a>逃逸分析是怎么完成的</h1><p>Go逃逸分析最基本的原则是：如果一个函数返回对一个变量的引用，那么它就会发生逃逸。</p><p>简单来说，编译器会分析代码的特征和代码生命周期，Go中的变量只有在编译器可以证明在函数返回后不会再被引用的，才分配到栈上，其他情况下都是分配到堆上。</p><p>Go语言里没有一个关键字或者函数可以直接让变量被编译器分配到堆上，相反，编译器通过分析代码来决定将变量分配到何处。</p><p>对一个变量取地址，可能会被分配到堆上。但是编译器进行逃逸分析后，如果考察到在函数返回后，此变量不会被引用，那么还是会被分配到栈上。套个取址符，就想骗补助？Too young！</p><p>简单来说，编译器会根据变量是否被外部引用来决定是否逃逸：</p><blockquote><ol><li>如果函数外部没有引用，则优先放到栈中；</li><li>如果函数外部存在引用，则必定放到堆中；</li></ol></blockquote><p>针对第一条，可能放到堆上的情形：定义了一个很大的数组，需要申请的内存过大，超过了栈的存储能力。</p><h1 id="逃逸分析实例"><a href="#逃逸分析实例" class="headerlink" title="逃逸分析实例"></a>逃逸分析实例</h1><p>Go提供了相关的命令，可以查看变量是否发生逃逸。</p><p>还是用上面我们提到的例子：</p><pre class=" language-golang"><code class="language-golang">package mainimport "fmt"func foo() *int {    t := 3    return &t;}func main() {    x := foo()    fmt.Println(*x)}</code></pre><p>foo函数返回一个局部变量的指针，main函数里变量x接收它。执行如下命令：</p><pre class=" language-shell"><code class="language-shell">go build -gcflags '-m -l' main.go</code></pre><p>加<code>-l</code>是为了不让foo函数被内联。得到如下输出：</p><pre class=" language-shell"><code class="language-shell"># command-line-argumentssrc/main.go:7:9: &t escapes to heapsrc/main.go:6:7: moved to heap: tsrc/main.go:12:14: *x escapes to heapsrc/main.go:12:13: main ... argument does not escape</code></pre><p>foo函数里的变量<code>t</code>逃逸了，和我们预想的一致。让我们不解的是为什么main函数里的<code>x</code>也逃逸了？这是因为有些函数参数为interface类型，比如fmt.Println(a …interface{})，编译期间很难确定其参数的具体类型，也会发生逃逸。</p><p>使用反汇编命令也可以看出变量是否发生逃逸。</p><pre class=" language-shell"><code class="language-shell">go tool compile -S main.go</code></pre><p>截取部分结果，图中标记出来的说明<code>t</code>是在堆上分配内存，发生了逃逸。<br><img src="https://user-images.githubusercontent.com/7698088/53530056-a33ea380-3b29-11e9-9388-8ed7f6ce79ee.png" alt="反汇编"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>堆上动态分配内存比栈上静态分配内存，开销大很多。</p><p>变量分配在栈上需要能在编译期确定它的作用域，否则会分配到堆上。</p><p>Go编译器会在编译期对考察变量的作用域，并作一系列检查，如果它的作用域在运行期间对编译器一直是可知的，那么就会分配到栈上。</p><p>简单来说，编译器会根据变量是否被外部引用来决定是否逃逸。对于Go程序员来说，编译器的这些逃逸分析规则不需要掌握，我们只需通过<code>go build -gcflags &#39;-m&#39;</code>命令来观察变量逃逸情况就行了。</p><p>不要盲目使用变量的指针作为函数参数，虽然它会减少复制操作。但其实当参数为变量自身的时候，复制是在栈上完成的操作，开销远比变量逃逸后动态地在堆上分配内存少的多。</p><p>最后，尽量写出少一些逃逸的代码，提升程序的运行效率。</p><p><img src="https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png" alt="QR"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【逃逸是怎么发生的？很赞 结尾有很多参考资料】<a href="https://www.do1618.com/archives/1328/go-%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">https://www.do1618.com/archives/1328/go-%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/</a></p><p>【Go的变量到底在堆还是栈中分配】<a href="https://github.com/developer-learning/night-reading-go/blob/master/content/discuss/2018-07-09-make-new-in-go.md">https://github.com/developer-learning/night-reading-go/blob/master/content/discuss/2018-07-09-make-new-in-go.md</a></p><p>【Golang堆栈的理解】<a href="https://segmentfault.com/a/1190000017498101" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017498101</a></p><p>【逃逸分析 编写栈分配内存建议】<a href="https://segment.com/blog/allocation-efficiency-in-high-performance-go-services/" target="_blank" rel="noopener">https://segment.com/blog/allocation-efficiency-in-high-performance-go-services/</a><br>【逃逸分析 比较简洁】<a href="https://studygolang.com/articles/17584" target="_blank" rel="noopener">https://studygolang.com/articles/17584</a></p><p>【逃逸分析定义】<a href="https://cloud.tencent.com/developer/article/1117410" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1117410</a></p><p>【逃逸分析例子】<a href="https://my.oschina.net/renhc/blog/2222104" target="_blank" rel="noopener">https://my.oschina.net/renhc/blog/2222104</a></p><p><a href="https://gocn.vip/article/355" target="_blank" rel="noopener">https://gocn.vip/article/355</a><br>【汇编代码 传参】<a href="https://github.com/maniafish/about_go/blob/master/heap_stack.md">https://github.com/maniafish/about_go/blob/master/heap_stack.md</a></p><p>【逃逸分析的缺陷】<a href="https://studygolang.com/articles/12396" target="_blank" rel="noopener">https://studygolang.com/articles/12396</a></p><p>【比较好的逃逸分析的例子】<a href="http://www.agardner.me/golang/garbage/collection/gc/escape/analysis/2015/10/18/go-escape-analysis.html" target="_blank" rel="noopener">http://www.agardner.me/golang/garbage/collection/gc/escape/analysis/2015/10/18/go-escape-analysis.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写过C/C++的同学都知道，调用著名的malloc和new函数可以在堆上分配一块内存，这块内存的使用和销毁的责任都在程序员。一不小心，就会发生内存泄露，搞得胆战心惊。&lt;/p&gt;
&lt;p&gt;切换到Golang后，基本不会担心内存泄露了。虽然也有new函数，但是使用new函数得到的内
      
    
    </summary>
    
      <category term="编程语言" scheme="https://github.com/qcrao/qcrao.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="golang" scheme="https://github.com/qcrao/qcrao.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang之轻松化解defer的温柔陷阱</title>
    <link href="https://github.com/qcrao/qcrao.github.io/2019/02/12/how-to-keep-off-trap-of-defer/"/>
    <id>https://github.com/qcrao/qcrao.github.io/2019/02/12/how-to-keep-off-trap-of-defer/</id>
    <published>2019-02-12T03:08:00.000Z</published>
    <updated>2019-07-24T13:24:15.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是defer？"><a href="#什么是defer？" class="headerlink" title="什么是defer？"></a>什么是defer？</h1><p><code>defer</code>是Go语言提供的一种用于注册延迟调用的机制：让函数或语句可以在当前函数执行完毕后（包括通过return正常结束或者panic导致的异常结束）执行。</p><p><code>defer</code>语句通常用于一些成对操作的场景：打开连接/关闭连接；加锁/释放锁；打开文件/关闭文件等。</p><p><code>defer</code>在一些需要回收资源的场景非常有用，可以很方便地在函数结束前做一些清理操作。在打开资源语句的下一行，直接一句defer就可以在函数返回前关闭资源，可谓相当优雅。</p><pre class=" language-golang"><code class="language-golang">f, _ := os.Open("defer.txt")defer f.Close()</code></pre><p>注意：以上代码，忽略了err, 实际上应该先判断是否出错，如果出错了，直接return. 接着再判断<code>f</code>是否为空，如果<code>f</code>为空，就不能调用<code>f.Close()</code>函数了，会直接panic的。</p><h1 id="为什么需要defer？"><a href="#为什么需要defer？" class="headerlink" title="为什么需要defer？"></a>为什么需要defer？</h1><p>程序员在编程的时候，经常需要打开一些资源，比如数据库连接、文件、锁等，这些资源需要在用完之后释放掉，否则会造成内存泄漏。</p><p>但是程序员都是人，是人就会犯错。因此经常有程序员忘记关闭这些资源。Golang直接在语言层面提供<code>defer</code>关键字，在打开资源语句的下一行，就可以直接用<code>defer</code>语句来注册函数结束后执行关闭资源的操作。因为这样一颗“小小”的语法糖，程序员忘写关闭资源语句的情况就大大地减少了。</p><h1 id="怎样合理使用defer"><a href="#怎样合理使用defer" class="headerlink" title="怎样合理使用defer?"></a>怎样合理使用defer?</h1><p>defer的使用其实非常简单：</p><pre class=" language-go"><code class="language-go">f<span class="token punctuation">,</span>err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>    <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">if</span> f <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>    <span class="token keyword">defer</span> f<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>在打开文件的语句附近，用defer语句关闭文件。这样，在函数结束之前，会自动执行defer后面的语句来关闭文件。</p><p>当然，defer会有小小地延迟，对时间要求特别特别特别高的程序，可以避免使用它，其他一般忽略它带来的延迟。</p><h1 id="defer进阶"><a href="#defer进阶" class="headerlink" title="defer进阶"></a>defer进阶</h1><h2 id="defer的底层原理是什么？"><a href="#defer的底层原理是什么？" class="headerlink" title="defer的底层原理是什么？"></a>defer的底层原理是什么？</h2><p>我们先看一下官方对<code>defer</code>的解释：</p><blockquote><p>Each time a “defer” statement executes, the function value and parameters to the call are evaluated as usual and saved anew but the actual function is not invoked. Instead, deferred functions are invoked immediately before the surrounding function returns, in the reverse order they were deferred. If a deferred function value evaluates to nil, execution panics when the function is invoked, not when the “defer” statement is executed.</p></blockquote><p>翻译一下：每次defer语句执行的时候，会把函数“压栈”，函数参数会被拷贝下来；当外层函数（非代码块，如一个for循环）退出时，defer函数按照定义的逆序执行；如果defer执行的函数为nil, 那么会在最终调用函数的产生panic.</p><p>defer语句并不会马上执行，而是会进入一个栈，函数return前，会按先进后出的顺序执行。也说是说最先被定义的defer语句最后执行。先进后出的原因是后面定义的函数可能会依赖前面的资源，自然要先执行；否则，如果前面先执行，那后面函数的依赖就没有了。</p><p>在defer函数定义时，对外部变量的引用是有两种方式的，分别是作为函数参数和作为闭包引用。作为函数参数，则在defer定义时就把值传递给defer，并被cache起来；作为闭包引用的话，则会在defer函数真正调用时根据整个上下文确定当前的值。</p><p>defer后面的语句在执行的时候，函数调用的参数会被保存起来，也就是复制了一份。真正执行的时候，实际上用到的是这个复制的变量，因此如果此变量是一个“值”，那么就和定义的时候是一致的。如果此变量是一个“引用”，那么就可能和定义的时候不一致。 </p><p>举个例子：</p><pre class=" language-golang"><code class="language-golang">func main() {    var whatever [3]struct{}    for i := range whatever {        defer func() {             fmt.Println(i)         }()    }}</code></pre><p>执行结果：</p><pre class=" language-shell"><code class="language-shell">222</code></pre><p>defer后面跟的是一个闭包（后面会讲到），i是“引用”类型的变量，最后i的值为2, 因此最后打印了三个2. </p><p>有了上面的基础，我们来检验一下成果：</p><pre class=" language-golang"><code class="language-golang">type number intfunc (n number) print()   { fmt.Println(n) }func (n *number) pprint() { fmt.Println(*n) }func main() {    var n number    defer n.print()    defer n.pprint()    defer func() { n.print() }()    defer func() { n.pprint() }()    n = 3}</code></pre><p>执行结果是：</p><pre class=" language-golang"><code class="language-golang">3330</code></pre><p>第四个defer语句是闭包，引用外部函数的n, 最终结果是3;<br>第三个defer语句同第四个；<br>第二个defer语句，n是引用，最终求值是3.<br>第一个defer语句，对n直接求值，开始的时候n=0, 所以最后是0;</p><h2 id="利用defer原理"><a href="#利用defer原理" class="headerlink" title="利用defer原理"></a>利用defer原理</h2><p>有些情况下，我们会故意用到defer的先求值，再延迟调用的性质。想象这样的场景：在一个函数里，需要打开两个文件进行合并操作，合并完后，在函数执行完后关闭打开的文件句柄。</p><pre class=" language-golang"><code class="language-golang">func mergeFile() error {    f, _ := os.Open("file1.txt")    if f != nil {        defer func(f io.Closer) {            if err := f.Close(); err != nil {                fmt.Printf("defer close file1.txt err %v\n", err)            }        }(f)    }    // ……    f, _ = os.Open("file2.txt")    if f != nil {        defer func(f io.Closer) {            if err := f.Close(); err != nil {                fmt.Printf("defer close file2.txt err %v\n", err)            }        }(f)    }    return nil}</code></pre><p>上面的代码中就用到了defer的原理，defer函数定义的时候，参数就已经复制进去了，之后，真正执行close()函数的时候就刚好关闭的是正确的“文件”了，妙哉！可以想像一下如果不这样将f当成函数参数传递进去的话，最后两个语句关闭的就是同一个文件了，都是最后一个打开的文件。</p><p>不过在调用close()函数的时候，要注意一点：先判断调用主体是否为空，否则会panic. 比如上面的代码片段里，先判断<code>f</code>不为空，才会调用<code>Close()</code>函数，这样最安全。</p><h2 id="defer命令的拆解"><a href="#defer命令的拆解" class="headerlink" title="defer命令的拆解"></a>defer命令的拆解</h2><p>如果defer像上面介绍地那样简单（其实也不简单啦），这个世界就完美了。事情总是没这么简单，defer用得不好，是会跳进很多坑的。</p><p>理解这些坑的关键是这条语句：</p><pre class=" language-golang"><code class="language-golang">return xxx</code></pre><p>上面这条语句经过编译之后，变成了三条指令：</p><pre class=" language-asm"><code class="language-asm">1. 返回值 = xxx2. 调用defer函数3. 空的return</code></pre><p>1,3步才是Return 语句真正的命令，第2步是defer定义的语句，这里可能会操作返回值。</p><p>下面我们来看两个例子，试着将return语句和defer语句拆解到正确的顺序。</p><p>第一个例子：</p><pre class=" language-golang"><code class="language-golang">func f() (r int) {     t := 5     defer func() {       t = t + 5     }()     return t}</code></pre><p>拆解后：</p><pre class=" language-golang"><code class="language-golang">func f() (r int) {     t := 5     // 1. 赋值指令     r = t     // 2. defer被插入到赋值与返回之间执行，这个例子中返回值r没被修改过     func() {                 t = t + 5     }     // 3. 空的return指令     return}</code></pre><p>这里第二步没有操作返回值r, 因此，main函数中调用f()得到5.</p><p>第二个例子：</p><pre class=" language-golang"><code class="language-golang">func f() (r int) {    defer func(r int) {          r = r + 5    }(r)    return 1}</code></pre><p>拆解后：</p><pre class=" language-golang"><code class="language-golang">func f() (r int) {     // 1. 赋值     r = 1     // 2. 这里改的r是之前传值传进去的r，不会改变要返回的那个r值     func(r int) {           r = r + 5     }(r)     // 3. 空的return     return}</code></pre><p>因此，main函数中调用f()得到1.</p><h2 id="defer语句的参数"><a href="#defer语句的参数" class="headerlink" title="defer语句的参数"></a>defer语句的参数</h2><p>defer语句表达式的值在定义时就已经确定了。下面展示三个函数：</p><pre class=" language-golang"><code class="language-golang">func f1() {    var err error    defer fmt.Println(err)    err = errors.New("defer error")    return}func f2() {    var err error    defer func() {        fmt.Println(err)    }()    err = errors.New("defer error")    return}func f3() {    var err error    defer func(err error) {        fmt.Println(err)    }(err)    err = errors.New("defer error")    return}func main() {    f1()    f2()    f3()}</code></pre><p>运行结果：</p><pre class=" language-shell"><code class="language-shell"><nil>defer error<nil></code></pre><p>第1，3个函数是因为作为函数参数，定义的时候就会求值，定义的时候err变量的值都是nil, 所以最后打印的时候都是nil. 第2个函数的参数其实也是会在定义的时候求值，只不过，第2个例子中是一个闭包，它引用的变量err在执行的时候最终变成<code>defer error</code>了。关于闭包在本文后面有介绍。</p><p>第3个函数的错误还比较容易犯，在生产环境中，很容易写出这样的错误代码。最后defer语句没有起到作用。</p><h2 id="闭包是什么？"><a href="#闭包是什么？" class="headerlink" title="闭包是什么？"></a>闭包是什么？</h2><p>闭包是由函数及其相关引用环境组合而成的实体,即：</p><pre class=" language-shell"><code class="language-shell">闭包=函数+引用环境</code></pre><p>一般的函数都有函数名，但是匿名函数就没有。匿名函数不能独立存在，但可以直接调用或者赋值于某个变量。匿名函数也被称为闭包，一个闭包继承了函数声明时的作用域。在Golang中，所有的匿名函数都是闭包。</p><p>有个不太恰当的例子，可以把闭包看成是一个类，一个闭包函数调用就是实例化一个类。闭包在运行时可以有多个实例，它会将同一个作用域里的变量和常量捕获下来，无论闭包在什么地方被调用（实例化）时，都可以使用这些变量和常量。而且，闭包捕获的变量和常量是引用传递，不是值传递。</p><p>举个简单的例子：</p><pre class=" language-golang"><code class="language-golang">func main() {    var a = Accumulator()    fmt.Printf("%d\n", a(1))    fmt.Printf("%d\n", a(10))    fmt.Printf("%d\n", a(100))    fmt.Println("------------------------")    var b = Accumulator()    fmt.Printf("%d\n", b(1))    fmt.Printf("%d\n", b(10))    fmt.Printf("%d\n", b(100))}func Accumulator() func(int) int {    var x int    return func(delta int) int {        fmt.Printf("(%+v, %+v) - ", &x, x)        x += delta        return x    }}</code></pre><p>执行结果：</p><pre class=" language-shell"><code class="language-shell">(0xc420014070, 0) - 1(0xc420014070, 1) - 11(0xc420014070, 11) - 111------------------------(0xc4200140b8, 0) - 1(0xc4200140b8, 1) - 11(0xc4200140b8, 11) - 111</code></pre><p>闭包引用了x变量，a,b可看作2个不同的实例，实例之间互不影响。实例内部，x变量是同一个地址，因此具有“累加效应”。</p><h2 id="defer配合recover"><a href="#defer配合recover" class="headerlink" title="defer配合recover"></a>defer配合recover</h2><p>Golang被诟病比较多的就是它的error, 经常是各种error满天飞。编程的时候总是会返回一个error, 留给调用者处理。如果是那种致命的错误，比如程序执行初始化的时候出问题，直接panic掉，省得上线运行后出更大的问题。</p><p>但是有些时候，我们需要从异常中恢复。比如服务器程序遇到严重问题，产生了panic, 这时我们至少可以在程序崩溃前做一些“扫尾工作”，如关闭客户端的连接，防止客户端一直等待等等。</p><p>panic会停掉当前正在执行的程序，不只是当前协程。在这之前，它会有序地执行完当前协程defer列表里的语句，其它协程里挂的defer语句不作保证。因此，我们经常在defer里挂一个recover语句，防止程序直接挂掉，这起到了<code>try...catch</code>的效果。</p><p>注意，recover()函数只在defer的上下文中才有效（且只有通过在defer中用匿名函数调用才有效），直接调用的话，只会返回<code>nil</code>. </p><pre class=" language-golang"><code class="language-golang">func main() {    defer fmt.Println("defer main")    var user = os.Getenv("USER_")    go func() {        defer func() {            fmt.Println("defer caller")            if err := recover(); err != nil {                fmt.Println("recover success. err: ", err)            }        }()        func() {            defer func() {                fmt.Println("defer here")            }()            if user == "" {                panic("should set user env.")            }            // 此处不会执行            fmt.Println("after panic")        }()    }()    time.Sleep(100)    fmt.Println("end of main function")}</code></pre><p>上面的panic最终会被recover捕获到。这样的处理方式在一个http server的主流程常常会被用到。一次偶然的请求可能会触发某个bug, 这时用recover捕获panic, 稳住主流程，不影响其他请求。</p><p>程序员通过监控获知此次panic的发生，按时间点定位到日志相应位置，找到发生panic的原因，三下五除二，修复上线。一看四周，大家都埋头干自己的事，简直完美：偷偷修复了一个bug, 没有发现！嘿嘿！</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>defer非常好用，一般情况下不会有什么问题。但是只有深入理解了defer的原理才会避开它的温柔陷阱。掌握了它的原理后，就会写出易懂易维护的代码。</p><p><img src="https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png" alt="QR"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【defer那些事】<a href="https://xiaozhou.net/something-about-defer-2014-05-25.html" target="_blank" rel="noopener">https://xiaozhou.net/something-about-defer-2014-05-25.html</a><br>【defer代码案例】<a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html" target="_blank" rel="noopener">https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html</a><br>【闭包】<a href="https://www.kancloud.cn/liupengjie/go/576456" target="_blank" rel="noopener">https://www.kancloud.cn/liupengjie/go/576456</a><br>【闭包】<a href="http://blog.51cto.com/speakingbaicai/1703229" target="_blank" rel="noopener">http://blog.51cto.com/speakingbaicai/1703229</a><br>【闭包】<a href="https://blog.csdn.net/zhangzhebjut/article/details/25181151" target="_blank" rel="noopener">https://blog.csdn.net/zhangzhebjut/article/details/25181151</a><br>【延迟】<a href="http://liyangliang.me/posts/2014/12/defer-in-golang/" target="_blank" rel="noopener">http://liyangliang.me/posts/2014/12/defer-in-golang/</a><br>【defer三条原则】<a href="https://leokongwq.github.io/2016/10/15/golang-defer.html" target="_blank" rel="noopener">https://leokongwq.github.io/2016/10/15/golang-defer.html</a><br>【defer代码例子】<a href="https://juejin.im/post/5b948b3e6fb9a05d3827beda" target="_blank" rel="noopener">https://juejin.im/post/5b948b3e6fb9a05d3827beda</a><br>【defer panic】<a href="https://ieevee.com/tech/2017/11/23/go-panic.html" target="_blank" rel="noopener">https://ieevee.com/tech/2017/11/23/go-panic.html</a><br>【defer panic】<a href="https://zhuanlan.zhihu.com/p/33743255" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/33743255</a><br>【defer asm】<a href="https://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;mid=2651435875&amp;idx=1&amp;sn=73b1023e91a6570e21bf237cd960b3e1&amp;chksm=80bb6d91b7cce487d8ee5f3674d6746e1c1ecd9c4a725ac65917df0bc3f0540afe723da7cd9c&amp;scene=4&amp;subscene=126&amp;ascene=0&amp;devicetype=android-27&amp;version=27000336&amp;nettype=WIFI&amp;abtest_cookie=BQABAAgACgALABMAFAAFAJ2GHgAjlx4AWpkeAJuZHgCdmR4AAAA%3D&amp;lang=zh_CN&amp;pass_ticket=A7Puc6tZBvtO6nZuNYDlkpGr0ioRdWC8iFkDA7T6N9VXvMm380V3sUaRtsGlyQFt&amp;wx_header=1" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;mid=2651435875&amp;idx=1&amp;sn=73b1023e91a6570e21bf237cd960b3e1&amp;chksm=80bb6d91b7cce487d8ee5f3674d6746e1c1ecd9c4a725ac65917df0bc3f0540afe723da7cd9c&amp;scene=4&amp;subscene=126&amp;ascene=0&amp;devicetype=android-27&amp;version=27000336&amp;nettype=WIFI&amp;abtest_cookie=BQABAAgACgALABMAFAAFAJ2GHgAjlx4AWpkeAJuZHgCdmR4AAAA%3D&amp;lang=zh_CN&amp;pass_ticket=A7Puc6tZBvtO6nZuNYDlkpGr0ioRdWC8iFkDA7T6N9VXvMm380V3sUaRtsGlyQFt&amp;wx_header=1</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是defer？&quot;&gt;&lt;a href=&quot;#什么是defer？&quot; class=&quot;headerlink&quot; title=&quot;什么是defer？&quot;&gt;&lt;/a&gt;什么是defer？&lt;/h1&gt;&lt;p&gt;&lt;code&gt;defer&lt;/code&gt;是Go语言提供的一种用于注册延迟调用的机制：让函
      
    
    </summary>
    
      <category term="编程语言" scheme="https://github.com/qcrao/qcrao.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="golang" scheme="https://github.com/qcrao/qcrao.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>一个字节的网络漫游故事独白</title>
    <link href="https://github.com/qcrao/qcrao.github.io/2019/01/30/byte-travel-story/"/>
    <id>https://github.com/qcrao/qcrao.github.io/2019/01/30/byte-travel-story/</id>
    <published>2019-01-29T22:48:00.000Z</published>
    <updated>2019-07-24T14:08:00.669Z</updated>
    
    <content type="html"><![CDATA[<p>大家好，给大家介绍一下，我是一个字节。相比于你们人类据说即将达到的百岁人生的寿命，我的一生简直不直一提（我只能存活零点几个毫秒）。</p><p>也许只有那些码农才会了解我，而且也只有一部分码农。那些整天做业务的猿们想来也不会真正的了解我，更别提人类其他行业的人了。</p><p>我不甘心，虽然我微不足道，但是我对人类的贡献实在是太大了。没有我的世界根本无法想像：不能听网易云音乐，不能刷抖音，不能上拼多多，所有和网络相关的活动都无法进行。</p><p>所以，今天我要讲讲我的一生，让更多的人知道我的存在，知道我的故事，也为证明自己曾经存在过吧。</p><h1 id="诞生"><a href="#诞生" class="headerlink" title="诞生"></a>诞生</h1><p>我的主人是一个在西二旗知名互联网公司上班的程序猿，过着1095（注：早10点晚9点，一周5天工作）的生活，很少能在晚霞中回家，自然也说不出“落霞与孤鹜齐飞”那样的句子。</p><p>这一天，他9点半到家，第一件事打开电脑，熟练地启动chrome浏览器，在地址栏敲下一个<code>z</code>字符，我所有的故事就从这里开始。</p><p>当主人按下键盘上的<code>z</code>键时，系统了产生一个中断信号，通知CPU过来读取键盘输入，CPU读取到<code>z</code>后，将<code>z</code>发送给chrome浏览器, chrome收到后，将<code>z</code>显示到浏览器的地址栏上，同时后台搜索主人平时访问过的地址，排名第一的<code>https://www.zhihu.com/</code>被快速补全了。</p><p>这时主人熟练地按下了回车键，chrome收到指令后，进行了一顿操作，在这电光火石之间，我诞生了，同时诞生的还有我的字节兄弟们。</p><h1 id="上路"><a href="#上路" class="headerlink" title="上路"></a>上路</h1><p>话说<code>Chorme老大哥</code>接收到了URL后，首先拆解成自己能看懂的东西。<code>https://www.zhihu.com</code>会被拆解成三部分：<code>https</code>、<code>www.zhihu.com</code>、<code>/</code></p><p><code>https</code>表示协议类型，通过这个<code>Chorme老大哥</code>知道他接下来该如何与远方的网站服务器通信；<code>www.zhihu.com</code>表示主机名，就是Chorme老大哥要通信的对象了；第三部分则是它要向服务器要的内容（注：这里表明是空，实际上隐含的表示主目录文件的概念）。</p><p>有了这三项，<code>Chorme老大哥</code>就能从服务器那里获取它想要的内容了，从而展示给我的主人。</p><p><code>Chorme老大哥</code>跑到<code>HTTP数据包生产车间</code>，哼哧哼哧地倒腾半天，生产出了一个HTTP数据包（注：忽略https, 简单起见我们当成http），这个数据包实际上就是我和我的一群字节兄弟们，我们挤在一个集装箱内，熙熙攘攘。</p><p>我们马上就要搭乘<code>IP列车</code>到远方的服务器，见识外面的世界了。集装箱被装上了<code>TCP专车</code>，它将带我们来到列车站。<code>TCP专车</code>很安全也很舒适，我从集装箱的缝隙中看到车前贴上了车牌：<code>80</code>. </p><p>到了车站，<code>TCP专车</code>直接开到了列车上。这样也好，<code>IP列车</code>上很脏，我们坐在专车上更好。 只是列车还不知道具体要去哪，所以我们就只能先在列车上等着了。</p><p>不对啊，列车应该去<code>www.zhihu.com</code>这个网站，不是已经知道了吗？对的，但是<code>IP列车</code>挺笨的，也挺古板的，不认识这些字母。它只认识数字，人类称之为ip. </p><p><code>Chorme老大哥</code>也有点抱怨，人类真是笨，连个ip都记不住，非得用域名来上网。害我还得拿着这个域名去问<code>DNS老大爷</code>，它知道所有域名对应的ip. </p><p>这不，<code>Chorme老大哥</code>又跑到另外一个车间————<code>DNS数据包生产车间</code>里倒腾出了一个DNS数据包，当然还是一群字节兄弟们，不过这里的兄弟就少一些了。它们在集装箱里叽叽喳喳，被装上了<code>UDP敞篷车</code>，车虽然很快，但不太安全，我这些兄弟们坐在上面，提心吊胆，生怕掉下去，因为掉下去，就永远消失了。</p><p><code>UDP敞篷车</code>也直接开到了<code>IP列车</code>上，车前贴了车牌：53.</p><p>这回Chrome老大哥直接从<code>操作系统大佬</code>那要到了<code>DNS老大爷</code>的ip, 贴到了<code>IP列车</code>的车头，<code>IP列车</code>马上全速启动，载着我这些字节兄弟，赶到了<code>DNS老大爷</code>的城堡，<code>UDP敞篷车</code>开下列车，按照车牌号53找到了<code>DNS老大爷</code>的住处。从它那拿到了<code>www.zhihu.com</code>对应的ip.</p><p><code>DNS老大爷</code>学问渊博，他也很仗义，从自己城堡里的<code>DNS数据包生产车间</code>造出了DNS响应包，包里也是我这些字节兄弟们，它们拿着重要的资料数据————<code>www.zhihu.com</code>对应的ip, 坐上了另一趟返程的<code>IP列车</code>，而列车的终点就是我现在所在的地方。当然了，他们是由另一辆<code>UDP敞篷车</code>载着他们回来的。</p><p><code>Chorme老大哥</code>在车间接见了这些兄弟，非常感动。因为他们带回了<code>www.zhihu.com</code>对应的ip. 那些兄弟争先恐后的报告自己知道的东西，有些兄弟报告1, 有些兄弟报告0, <code>Chorme老大哥</code>非常有经验，它把这些消息合并起来了，最终得到了它想要的ip: 118.89.204.192.</p><p><code>Chorme老大哥</code>拿着这个ip来到了我所在的列车前面，我激动地要叫起来了：终于我要出发了！它熟练地把<code>118.89.204.192</code>贴到了列车的前面，马上列车就开动了，我上路了。</p><p><code>IP列车</code>的列车长在掌管着车头的方向，决定着我们的命运走向。路网非常复杂，而车头上只有一个ip地址，根本没告诉列车长应该走哪条路。这不难，富有经验的列车长根据车头的ip地址查到了下一个大站（路由器）的地址，之后再根据这个大站地址查到（ARP协议）途经的下一个小站（交换机或集线器）应该走的轨道。在每个小站，对照这个大站地址，列车长就知道该走哪条路。搞定！</p><p>经过了很多的小站，我们终于到了下一个大站了。站点的工作人员看着我们车头前的ip地址，查了下表（路由表）告诉我们下一个大站的地址，并且告诉我们途径的下一个小站应该走哪条轨道。列车长就这样，一路拿这张表，顺利地把们带到了终点：<br><code>118.89.204.192</code>. </p><p>不过，刚刚就在到终点的前一刻，列车被拦住了，一群荷枪实弹的警卫冲上来了，一些胆小的字节兄弟们都哭了，我也是屏气凝声。他们先是查看了车头的ip地址，再查看了列车长手里的表，还看了下我们的<code>TCP专车</code>的车牌。很快就放行了，虚惊一场！</p><h1 id="新生"><a href="#新生" class="headerlink" title="新生"></a>新生</h1><p>到了终点站后，列车首先停下接受工作人员的检查。列车长出示了他手里的表，对了一下表上标注的下一站地址确实是：知乎。接着又看了下列车头部标注的ip地址，就算检查通过了，第一关很轻松。</p><p>接下来，我们坐的<code>TCP专车</code>开下列车了。进了一个<code>TCP车牌检查站</code>，工作人员看了下车牌号80, 也挥手示意我们通过。</p><p>接着我们都下车走进了<code>主页车间</code>，进去后，我们先按我们身上的标号排好了位置，工作人员将我们每个人所代表的信息进行了聚拢。得到了各种关于主人的信息，比如他所用的浏览器的版本，cookie等等信息，我知道，我们的使命完成了。果然，一道光闪过，我们都消失了，完成了我们光荣的一生。</p><p><code>主页车间</code>领导马上下达生产命令：1组去仓库拉取最新话题，2组去商业中心获取今天的广告主信息……</p><p>很快，各组都完成了任务，车间在一阵轰鸣过后，新的一批字节兄弟诞生了，他们带着这些话题、广告信息，和我们当年出生的时候一样，熙熙攘攘。但是我知道，我获得了新生。</p><h1 id="归家"><a href="#归家" class="headerlink" title="归家"></a>归家</h1><p>像我们当年一样，这些新出生的字节兄弟依次坐上了<code>TCP专车</code>，<code>IP列车</code>一路跋涉，去往我出发的地方，那是我梦开始的地方。</p><p>我所经历的，他们未曾少过一分。</p><h1 id="定格"><a href="#定格" class="headerlink" title="定格"></a>定格</h1><p><code>Chrome老大哥</code>终于等来了这些字节兄弟，在他们排好队后，老大哥看清了字节兄弟们代表的内容：话题<code>如何在西二旗地铁优雅地装逼</code>，热度10w, 广告<code>上午植发，下午上班</code>……</p><p>这些是<code>Chrome老大哥</code>最擅长的事情，分分钟将他们显示在了网页上。字节兄弟们终于完成了使命，定格在了retina屏幕上。</p><p>我的主人点开第一话题后，看了一会儿。然后瞅到了到植发广告，他偷偷地开启了隐身模式，仔细地研究了起来……</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>第一次尝试这种题材的文章，供大家一乐！有写得不到位的地方，欢迎大家补充！</p><p>另外，推荐大家去看《网络是怎样连接的》，看完可以形成对网络的整体印象。写得非常好！</p><p><img src="https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png" alt="QR"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【知乎回答】<a href="https://www.zhihu.com/question/292704461/answer/482549197" target="_blank" rel="noopener">https://www.zhihu.com/question/292704461/answer/482549197</a></p><p>【当我们谈网络时】<a href="https://segmentfault.com/a/1190000004094420" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004094420</a></p><p>【按下键盘时】<a href="https://www.zhihu.com/question/29707696" target="_blank" rel="noopener">https://www.zhihu.com/question/29707696</a></p><p>【mac地址和ip地址】<a href="http://blog.sciencenet.cn/blog-411071-1037673.html" target="_blank" rel="noopener">http://blog.sciencenet.cn/blog-411071-1037673.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大家好，给大家介绍一下，我是一个字节。相比于你们人类据说即将达到的百岁人生的寿命，我的一生简直不直一提（我只能存活零点几个毫秒）。&lt;/p&gt;
&lt;p&gt;也许只有那些码农才会了解我，而且也只有一部分码农。那些整天做业务的猿们想来也不会真正的了解我，更别提人类其他行业的人了。&lt;/p&gt;
      
    
    </summary>
    
      <category term="网络" scheme="https://github.com/qcrao/qcrao.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="协议" scheme="https://github.com/qcrao/qcrao.github.io/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>深度解密HTTP通信细节</title>
    <link href="https://github.com/qcrao/qcrao.github.io/2019/01/18/dive-into-http/"/>
    <id>https://github.com/qcrao/qcrao.github.io/2019/01/18/dive-into-http/</id>
    <published>2019-01-18T02:13:00.000Z</published>
    <updated>2019-07-24T13:59:36.281Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇<a href="https://www.cnblogs.com/qcrao-2018/p/10182185.html" target="_blank" rel="noopener">文章</a>中，我们学会了用wireshark和tcpdump来分析TCP的“三次握手，四次挥手”，非常好用。这哥俩就是传说中的<code>锤子</code>，拿着<code>锤子</code>，看什么都像<code>钉子</code>！在这篇文章中，我对准了<code>HTTP</code>这颗钉子砸下去，咳咳。</p><p>为了对网络数据包的“流转”有更加深刻的理解，我在docker（远程）上部署一个服务，支持http方式调用。从客户端（本地）用http方式请求其中的一个接口，并得到响应数据。同时本地通过wireshark抓包，远程用tcpdump抓包，然后分析过程中的所有通信细节。悲剧是把美好的东西撕碎给人看，而我则是把复杂的东西撕碎了给人看。</p><p>文章稍长，请在看本文时保持耐心。我先通过工具获取HTTP通信的数据包，再来抽丝剥茧，深入二进制的天地里，解密HTTP所有的通信细节。分析过程中，由点到面，将相关知识串接起来。保证全篇读完之后，你对HTTP的理解会上升一个台阶！</p><h1 id="HTTP报文截获"><a href="#HTTP报文截获" class="headerlink" title="HTTP报文截获"></a>HTTP报文截获</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>我手头现在有一个地理几何相关的服务，它提供一组接口对外使用。其中有一个接口是<code>Fence2Area</code>. 使用方传入一个围栏（由点的列表组成，点由&lt;经度，纬度&gt;表示）、点的坐标系类型（谷歌地图用的是wgs84, 国内腾讯、高德用的是soso, 而百度用的是另一套自己的坐标系），接口输出的则是围栏的面积。</p><p>我请求服务的“Fence2Area”接口，输入围栏(fence)顶点(lng, lat)坐标、坐标系类型(coordtype)，输出的则是多边形的面积(area).</p><p>一次正常的请求示例url, 这个大家都不陌生（我用docker_ip代替真实的ip）:</p><pre class=" language-json"><code class="language-json">http<span class="token operator">:</span>//docker_ip<span class="token operator">:</span><span class="token number">7080</span>/data?cmd=Fence2Area&amp;meta=<span class="token punctuation">{</span><span class="token property">"caller"</span><span class="token operator">:</span><span class="token string">"test"</span><span class="token punctuation">,</span><span class="token property">"TraceId"</span><span class="token operator">:</span><span class="token string">"test"</span><span class="token punctuation">}</span>&amp;request=<span class="token punctuation">{</span><span class="token property">"fence"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token property">"lng"</span><span class="token operator">:</span><span class="token number">10.2</span><span class="token punctuation">,</span><span class="token property">"lat"</span><span class="token operator">:</span><span class="token number">10.2</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token property">"lng"</span><span class="token operator">:</span><span class="token number">10.2</span><span class="token punctuation">,</span><span class="token property">"lat"</span><span class="token operator">:</span><span class="token number">8.2</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token property">"lng"</span><span class="token operator">:</span><span class="token number">8.2</span><span class="token punctuation">,</span><span class="token property">"lat"</span><span class="token operator">:</span><span class="token number">8.2</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token property">"lng"</span><span class="token operator">:</span><span class="token number">8.2</span><span class="token punctuation">,</span><span class="token property">"lat"</span><span class="token operator">:</span><span class="token number">10.2</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token property">"coordtype"</span><span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">}</span></code></pre><p>请求发出后，服务器进行处理，之后，客户端收到返回的数据如下：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"area"</span><span class="token operator">:</span> <span class="token number">48764135597.842606</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token property">"errstr"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">}</span></code></pre><p><code>area</code>字段表示面积，<code>errstr</code>表示出错信息，空说明没有出错。</p><h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><p>在真正发送请求之前，需要进行抓包前的设置。在本地mac，我用wireshark; 而在远程docker上，我用tcpdump工具。</p><h3 id="mac本地"><a href="#mac本地" class="headerlink" title="mac本地"></a>mac本地</h3><p>设置wireshark包过滤器，监控本地主机和远程docker之间的通信。</p><pre class=" language-shell"><code class="language-shell">ip.addr eq docker_ip</code></pre><p>点击开始捕获。</p><h3 id="远程docker"><a href="#远程docker" class="headerlink" title="远程docker"></a>远程docker</h3><p>该服务通过7080端口对外提供，使用如下命令捕获网络包：</p><pre class=" language-shell"><code class="language-shell">tcpdump -w /tmp/testHttp.cap port 7080 -s0</code></pre><h2 id="请求-amp-amp-分析"><a href="#请求-amp-amp-分析" class="headerlink" title="请求 &amp;&amp; 分析"></a>请求 &amp;&amp; 分析</h2><p>准备工作做完，我选了一个神圣的时刻，在本地通过浏览器访问如下url:</p><pre class=" language-json"><code class="language-json">http<span class="token operator">:</span>//docker_ip<span class="token operator">:</span><span class="token number">7080</span>/data?cmd=Fence2Area&amp;meta=<span class="token punctuation">{</span><span class="token property">"caller"</span><span class="token operator">:</span><span class="token string">"test"</span><span class="token punctuation">,</span><span class="token property">"TraceId"</span><span class="token operator">:</span><span class="token string">"test"</span><span class="token punctuation">}</span>&amp;request=<span class="token punctuation">{</span><span class="token property">"fence"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token property">"lng"</span><span class="token operator">:</span><span class="token number">10.2</span><span class="token punctuation">,</span><span class="token property">"lat"</span><span class="token operator">:</span><span class="token number">10.2</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token property">"lng"</span><span class="token operator">:</span><span class="token number">10.2</span><span class="token punctuation">,</span><span class="token property">"lat"</span><span class="token operator">:</span><span class="token number">8.2</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token property">"lng"</span><span class="token operator">:</span><span class="token number">8.2</span><span class="token punctuation">,</span><span class="token property">"lat"</span><span class="token operator">:</span><span class="token number">8.2</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token property">"lng"</span><span class="token operator">:</span><span class="token number">8.2</span><span class="token punctuation">,</span><span class="token property">"lat"</span><span class="token operator">:</span><span class="token number">10.2</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token property">"coordtype"</span><span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">}</span></code></pre><p>这样本地的wireshark和远程的tcpdump都能抓取到HTTP网络数据包。</p><h3 id="关闭服务进程"><a href="#关闭服务进程" class="headerlink" title="关闭服务进程"></a>关闭服务进程</h3><p>正式请求之前，我们先看一下几种特殊的情形。</p><p>首先，关闭gcs服务进程，请求直接返回RST报文。</p><p><img src="https://user-images.githubusercontent.com/7698088/51288531-97929400-1a37-11e9-8425-c6a2ca6405ad.png" alt="rst"></p><p>如上图，我在请求的时候，访问服务端的另一个端口<code>5010</code>, 这个端口没有服务监听，和关闭gcs服务进程是同样的效果。可以看到，客户端发送SYN报文，但直接被远程docker RST掉了。因为服务端操作系统找不到监听此端口的进程。</p><h3 id="关闭docker"><a href="#关闭docker" class="headerlink" title="关闭docker"></a>关闭docker</h3><p>关闭docker, 由于发送的SYN报文段得不到响应，因此会进行重试，mac下重试的次数为10次。</p><p><img src="https://user-images.githubusercontent.com/7698088/50555866-08823e00-0d0d-11e9-97cd-f1cdcca2f641.png" alt="mac retry"></p><p>先每隔1秒重试了5次，再用“指数退避”的时间间隔重试，2s, 4s, 8s, 16s, 32s. 最后结束。</p><h3 id="重启docker"><a href="#重启docker" class="headerlink" title="重启docker"></a>重启docker</h3><p>先进行一次正常的访问，随后重启docker。并再次在本地访问以上url, 浏览器这时还是用的上一次的端口，访问到服务端后，因为它已经重启了，所以服务端已经没有这个连接的消息了。因此会返回一个RST报文。</p><h3 id="正常请求"><a href="#正常请求" class="headerlink" title="正常请求"></a>正常请求</h3><p>服务正常启动，正常发送请求，这次请求成功，那是当然的，嘿嘿！</p><p><img src="https://user-images.githubusercontent.com/7698088/50638281-2e6f4300-0f98-11e9-8d8b-0f3c0cc7eb85.png" alt="normal_req_wireshark"></p><p>这是在mac上用wireshark捕获的数据包，共7个包，前三个包为3次握手的包，第四个包为<code>HTTP</code>层发送的请求数据，第五个包为服务端的TCP 确认报文，第六个包为服务端在<code>HTTP</code>层发送的响应数据，第七个包为mac对第六个包的确认报文。</p><p>重点来关注后面几个包，先看第四个包，</p><pre class=" language-shell"><code class="language-shell">0x0000:  4500 0295 0000 4000 3606 623b ac17 ccdc0x0010:  0a60 5cd4 db9b 1ba8 a59a 46ce 6d03 e87d0x0020:  8018 1015 0ee7 0000 0101 080a 2e4c b2ef0x0030:  0f20 3acf 4745 5420 2f64 6174 613f 636d0x0040:  643d 4665 6e63 6532 4172 6561 266d 65740x0050:  613d 7b25 3232 6361 6c6c 6572 2532 323a0x0060:  2532 3274 6573 7425 3232 2c25 3232 54720x0070:  6163 6549 6425 3232 3a25 3232 7465 73740x0080:  2532 327d 2672 6571 7565 7374 3d7b 25320x0090:  3266 656e 6365 2532 323a 5b7b 2532 326c0x00a0:  6e67 2532 323a 3130 2e32 2c25 3232 6c610x00b0:  7425 3232 3a31 302e 327d 2c25 3230 7b250x00c0:  3232 6c6e 6725 3232 3a31 302e 322c 25320x00d0:  326c 6174 2532 323a 382e 327d 2c25 32300x00e0:  7b25 3232 6c6e 6725 3232 3a38 2e32 2c250x00f0:  3232 6c61 7425 3232 3a38 2e32 7d2c 25320x0100:  307b 2532 326c 6e67 2532 323a 382e 322c0x0110:  2532 326c 6174 2532 323a 3130 2e32 7d5d0x0120:  2c25 3232 636f 6f72 6474 7970 6525 32320x0130:  3a32 7d20 4854 5450 2f31 2e31 0d0a 486f0x0140:  7374 3a20 3130 2e39 362e 3932 2e32 31320x0150:  3a37 3038 300d 0a55 7067 7261 6465 2d490x0160:  6e73 6563 7572 652d 5265 7175 6573 74730x0170:  3a20 310d 0a41 6363 6570 743a 2074 65780x0180:  742f 6874 6d6c 2c61 7070 6c69 6361 74690x0190:  6f6e 2f78 6874 6d6c 2b78 6d6c 2c61 70700x01a0:  6c69 6361 7469 6f6e 2f78 6d6c 3b71 3d300x01b0:  2e39 2c2a 2f2a 3b71 3d30 2e38 0d0a 55730x01c0:  6572 2d41 6765 6e74 3a20 4d6f 7a69 6c6c0x01d0:  612f 352e 3020 284d 6163 696e 746f 73680x01e0:  3b20 496e 7465 6c20 4d61 6320 4f53 20580x01f0:  2031 305f 3133 5f36 2920 4170 706c 65570x0200:  6562 4b69 742f 3630 352e 312e 3135 20280x0210:  4b48 544d 4c2c 206c 696b 6520 4765 636b0x0220:  6f29 2056 6572 7369 6f6e 2f31 322e 302e0x0230:  3220 5361 6661 7269 2f36 3035 2e31 2e310x0240:  350d 0a41 6363 6570 742d 4c61 6e67 75610x0250:  6765 3a20 7a68 2d63 6e0d 0a41 6363 65700x0260:  742d 456e 636f 6469 6e67 3a20 677a 69700x0270:  2c20 6465 666c 6174 650d 0a43 6f6e 6e650x0280:  6374 696f 6e3a 206b 6565 702d 616c 69760x0290:  650d 0a0d 0a</code></pre><p>我们来逐字节分析。</p><table><thead><tr><th>字节值</th><th>字节含义</th></tr></thead><tbody><tr><td>0x4</td><td>IP版本为ipv4</td></tr><tr><td>0x5</td><td>首部长度为5 * 4字节=20B</td></tr><tr><td>0x00</td><td>服务类型，现在基本都置为0</td></tr><tr><td>0x0295</td><td>总长度为661字节，即整个包的长度是661字节</td></tr><tr><td>0x0000</td><td>标识。同一个数据报的唯一标识。当IP数据报被拆分时，会复制到每一个数据中。</td></tr><tr><td>0x4000</td><td><code>3bit 标志 + 13bit 片偏移</code>。3bit 标志对应 R、DF、MF。目前只有后两位有效，DF位：为1表示不分片，为0表示分片。MF：为1表示“更多的片”，为0表示这是最后一片。13bit 片位移：本分片在原先数据报文中相对首位的偏移位。（需要再乘以8 )</td></tr><tr><td>0x36</td><td>生存时间TTL。IP报文所允许通过的路由器的最大数量。每经过一个路由器，TTL减1，当为 0 时，路由器将该数据报丢弃。TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字 RFC 指定。发送 ICMP 回显应答时经常把 TTL 设为最大值 255。TTL可以防止数据报陷入路由循环。 此处为54.</td></tr><tr><td>0x06</td><td>协议类型。指出IP报文携带的数据使用的是哪种协议，以便目的主机的IP层能知道要将数据报上交到哪个进程。TCP 的协议号为6，UDP 的协议号为17。ICMP 的协议号为1，IGMP 的协议号为2。该 IP 报文携带的数据使用 TCP 协议，得到了验证。</td></tr><tr><td>0x623b</td><td>16bitIP首部校验和。</td></tr><tr><td>0xac17 ccdc</td><td>32bit源ip地址。</td></tr><tr><td>0x0a60 5cd4</td><td>32bit目的ip地址。</td></tr></tbody></table><p>剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。</p><table><thead><tr><th align="left">字节值</th><th align="left">字节含义</th></tr></thead><tbody><tr><td align="left">0xdb9b</td><td align="left">16bit源端口。56219</td></tr><tr><td align="left">0x1ba8</td><td align="left">16bit目的端口7080</td></tr><tr><td align="left">0xa59a 46ce</td><td align="left">32bit序列号。2778351310</td></tr><tr><td align="left">0x6d03 e87d</td><td align="left">32bit确认号。1828972669</td></tr><tr><td align="left">0x8</td><td align="left">4bit首部长度，以4byte为单位。共8*4=32字节。因此TCP报文的可选长度为32-20=12字节</td></tr><tr><td align="left">0b000000</td><td align="left">6bit保留位。目前置为0.</td></tr><tr><td align="left">0b011000</td><td align="left">6bitTCP标志位。从左到右依次是紧急 URG、确认 ACK、推送 PSH、复位 RST、同步 SYN 、终止 FIN。ack有效，同时psh有效</td></tr><tr><td align="left">0x1015</td><td align="left">滑动窗口大小，滑动窗口即tcp接收缓冲区的大小，用于tcp拥塞控制。4117</td></tr><tr><td align="left">0x0ee7</td><td align="left">16bit校验和。</td></tr><tr><td align="left">0x0000</td><td align="left">紧急指针。仅在 URG = 1时才有意义，它指出本报文段中的紧急数据的字节数。当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。</td></tr></tbody></table><p>可变长度部分，协议如下：</p><table><thead><tr><th align="left">字节值</th><th align="left">字节含义</th></tr></thead><tbody><tr><td align="left">0x01</td><td align="left">无操作</td></tr><tr><td align="left">0x01</td><td align="left">无操作</td></tr><tr><td align="left">0x0402</td><td align="left">表示支持SACK</td></tr><tr><td align="left">0x080a 2e4c b2ef 0f20 3acf</td><td align="left">时间戳。Ts val=0x2e4c b2ef=776778479, ecr=0x0f20 3acf=253770447</td></tr></tbody></table><p>剩下来的就是数据部分了。我们一行一行地看。因为http是字符流，所以我们先看一下ascii字符集，执行命令：</p><pre class=" language-shell"><code class="language-shell">man ascii</code></pre><p>可以得到ascii码，我们直接看十六进制的结果：</p><p><img src="https://user-images.githubusercontent.com/7698088/51357121-5f06bf00-1af8-11e9-9171-fa1e7a8b0228.png" alt="ascii"></p><table><thead><tr><th align="left">行首地址</th><th align="left">字节流</th><th align="left">字符</th></tr></thead><tbody><tr><td align="left">0x0030</td><td align="left">4745 5420 2f64 6174 613f 636d</td><td align="left">GE T  /d at a? cm</td></tr><tr><td align="left">0x0040</td><td align="left">643d 4665 6e63 6532 4172 6561 266d 6574</td><td align="left">d= Fe nc e2 Ar ea &amp;m et</td></tr><tr><td align="left">0x0050</td><td align="left">613d 7b25 3232 6361 6c6c 6572 2532 323a</td><td align="left">a= {% 22 ca ll er %2 2:</td></tr><tr><td align="left">0x0060</td><td align="left">2532 3274 6573 7425 3232 2c25 3232 5472</td><td align="left">%2 2t es t% 22 ,% 22 Tr</td></tr><tr><td align="left">0x0070</td><td align="left">6163 6549 6425 3232 3a25 3232 7465 7374</td><td align="left">ac eI d% 22 :% 22 te st</td></tr><tr><td align="left">0x0080</td><td align="left">2532 327d 2672 6571 7565 7374 3d7b 2532</td><td align="left">%2 2} &amp;r eq ue st ={ %2</td></tr><tr><td align="left">0x0090</td><td align="left">3266 656e 6365 2532 323a 5b7b 2532 326c</td><td align="left">2f en ce %2 2: [{ %2 2l</td></tr><tr><td align="left">0x00a0</td><td align="left">6e67 2532 323a 3130 2e32 2c25 3232 6c61</td><td align="left">ng %2 2: 10 .2 ,% 22 la</td></tr><tr><td align="left">0x00b0</td><td align="left">7425 3232 3a31 302e 327d 2c25 3230 7b25</td><td align="left">t% 22 :1 0. 2} ,% 20 {%</td></tr><tr><td align="left">0x00c0</td><td align="left">3232 6c6e 6725 3232 3a31 302e 322c 2532</td><td align="left">22 ln g% 22 :1 0. 2, %2</td></tr><tr><td align="left">0x00d0</td><td align="left">326c 6174 2532 323a 382e 327d 2c25 3230</td><td align="left">2l at %2 2: 8. 2} ,% 20</td></tr><tr><td align="left">0x00e0</td><td align="left">7b25 3232 6c6e 6725 3232 3a38 2e32 2c25</td><td align="left">{% 22 ln g% 22 :8 .2 ,%</td></tr><tr><td align="left">0x00f0</td><td align="left">3232 6c61 7425 3232 3a38 2e32 7d2c 2532</td><td align="left">22 la t% 22 :8 .2 }, %2</td></tr><tr><td align="left">0x0100</td><td align="left">307b 2532 326c 6e67 2532 323a 382e 322c</td><td align="left">0{ %2 2l ng %2 2: 8. 2,</td></tr><tr><td align="left">0x0110</td><td align="left">2532 326c 6174 2532 323a 3130 2e32 7d5d</td><td align="left">%2 2l at %2 2: 10 .2 } ]</td></tr><tr><td align="left">0x0120</td><td align="left">2c25 3232 636f 6f72 6474 7970 6525 3232</td><td align="left">,% 22 co or dt yp e% 22</td></tr><tr><td align="left">0x0130</td><td align="left">3a32 7d20 4854 5450 2f31 2e31 0d0a 486f</td><td align="left">:2 } HT TP /1 .1 crnl Ho</td></tr><tr><td align="left">0x0140</td><td align="left">7374 3a20 3130 2e39 362e 3932 2e32 3132</td><td align="left">st :  10 .9 6. 92 .2 12</td></tr><tr><td align="left">0x0150</td><td align="left">3a37 3038 300d 0a55 7067 7261 6465 2d49</td><td align="left">:7 08 0cr nlU pg ra de -I</td></tr><tr><td align="left">0x0160</td><td align="left">6e73 6563 7572 652d 5265 7175 6573 7473</td><td align="left">ns ec ur e- Re qu es ts</td></tr><tr><td align="left">0x0170</td><td align="left">3a20 310d 0a41 6363 6570 743a 2074 6578</td><td align="left">: 1cr nlA cc ep t: t ex</td></tr><tr><td align="left">0x0180</td><td align="left">742f 6874 6d6c 2c61 7070 6c69 6361 7469</td><td align="left">t/ ht ml ,a pp li ca ti</td></tr><tr><td align="left">0x0190</td><td align="left">6f6e 2f78 6874 6d6c 2b78 6d6c 2c61 7070</td><td align="left">on /x ht ml +x ml ,a pp</td></tr><tr><td align="left">0x01a0</td><td align="left">6c69 6361 7469 6f6e 2f78 6d6c 3b71 3d30</td><td align="left">li ca ti on /x ml ;q =0</td></tr><tr><td align="left">0x01b0</td><td align="left">2e39 2c2a 2f2a 3b71 3d30 2e38 0d0a 5573</td><td align="left">.9 ,* /* ;q =0 .8 crnl Us</td></tr><tr><td align="left">0x01c0</td><td align="left">6572 2d41 6765 6e74 3a20 4d6f 7a69 6c6c</td><td align="left">er -A ge nt : Mo zi ll</td></tr><tr><td align="left">0x01d0</td><td align="left">612f 352e 3020 284d 6163 696e 746f 7368</td><td align="left">a/ 5. 0 (M ac in to sh</td></tr><tr><td align="left">0x01e0</td><td align="left">3b20 496e 7465 6c20 4d61 6320 4f53 2058</td><td align="left">; In te  l  Ma c OS  X</td></tr><tr><td align="left">0x01f0</td><td align="left">2031 305f 3133 5f36 2920 4170 706c 6557</td><td align="left">1 0_ 13 _6 )   Ap pl eW</td></tr><tr><td align="left">0x0200</td><td align="left">6562 4b69 742f 3630 352e 312e 3135 2028</td><td align="left">eb Ki t/ 60 5. 1. 15  (</td></tr><tr><td align="left">0x0210</td><td align="left">4b48 544d 4c2c 206c 696b 6520 4765 636b</td><td align="left">KH TM L,  l i k e  Ge ck</td></tr><tr><td align="left">0x0220</td><td align="left">6f29 2056 6572 7369 6f6e 2f31 322e 302e</td><td align="left">o)  V er si o n /1 2. 0.</td></tr><tr><td align="left">0x0230</td><td align="left">3220 5361 6661 7269 2f36 3035 2e31 2e31</td><td align="left">2  Sa fa ri /6 05 .1 .1</td></tr><tr><td align="left">0x0240</td><td align="left">350d 0a41 6363 6570 742d 4c61 6e67 7561</td><td align="left">5cr nlA cc ep t- La ng ua</td></tr><tr><td align="left">0x0250</td><td align="left">6765 3a20 7a68 2d63 6e0d 0a41 6363 6570</td><td align="left">ge :  zh -c ncr nlA cc ep</td></tr><tr><td align="left">0x0260</td><td align="left">742d 456e 636f 6469 6e67 3a20 677a 6970</td><td align="left">t- En co di ng :  gz ip</td></tr><tr><td align="left">0x0270</td><td align="left">2c20 6465 666c 6174 650d 0a43 6f6e 6e65</td><td align="left">,  de fl at ecr nlC on ne</td></tr><tr><td align="left">0x0280</td><td align="left">6374 696f 6e3a 206b 6565 702d 616c 6976</td><td align="left">ct io n: k ee p- al iv</td></tr><tr><td align="left">0x0290</td><td align="left">650d 0a0d 0a</td><td align="left">ecr nl cr nl</td></tr></tbody></table><p>把上表的最后一列连起来，就是：</p><pre class=" language-shell"><code class="language-shell">GET /data?cmd=Fence2Area&meta={%22caller%22:%22test%22,%22TraceId%22:%22test%22}&request={%22fence%22:[{%22lng%22:10.2,%22lat%22:10.2},%20{%22lng%22:10.2,%22lat%22:8.2},%20{%22lng%22:8.2,%22lat%22:8.2},%20{%22lng%22:8.2,%22lat%22:10.2}],%22coordtype%22:2} HTTP/1.1 Host: 10.96.92.212:7080 Upgrade-Insecure-Requests: 1 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0.2 Safari/605.1.15 Accept-Language: zh-cn Accept-Encoding: gzip, deflate Connection: keep-alive</code></pre><p>其中，cr nl表示回车，换行。</p><p>docker收到数据后，会回复一个ack包。第四个包的总长度为661字节，去掉IP头部20字节，TCP头部固定部分20字节，TCP头部可选长度为12字节，共52字节，因此TCP数据部分总长度为661-52=609字节。另外，序列号为2778351310.</p><p>再来看第5个包，字节流如下：</p><pre class=" language-shell"><code class="language-shell">0x0000:  4500 0034 d28b 4000 4006 8810 0a60 5cd40x0010:  ac17 ccdc 1ba8 db9b 6d03 e87d a59a 492f0x0020:  8010 00ec e04e 0000 0101 080a 0f20 3af70x0030:  2e4c b2ef</code></pre><table><thead><tr><th>字节值</th><th>字节含义</th></tr></thead><tbody><tr><td>0x4</td><td>IP版本为ipv4</td></tr><tr><td>0x5</td><td>首部长度为5 * 4字节=20B</td></tr><tr><td>0x00</td><td>服务类型，现在基本都置为0</td></tr><tr><td>0x0034</td><td>总长度为52字节，即整个包的长度是52字节</td></tr><tr><td>0xd28b</td><td>标识。同一个数据报的唯一标识。当IP数据报被拆分时，会复制到每一个数据中。</td></tr><tr><td>0x4000</td><td><code>3bit 标志 + 13bit 片偏移</code>。3bit 标志对应 R、DF、MF。目前只有后两位有效，DF位：为1表示不分片，为0表示分片。MF：为1表示“更多的片”，为0表示这是最后一片。13bit 片位移：本分片在原先数据报文中相对首位的偏移位。（需要再乘以8 )</td></tr><tr><td>0x40</td><td>生存时间TTL。IP报文所允许通过的路由器的最大数量。每经过一个路由器，TTL减1，当为 0 时，路由器将该数据报丢弃。TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字 RFC 指定。发送 ICMP 回显应答时经常把 TTL 设为最大值 255。TTL可以防止数据报陷入路由循环。 此处为54.</td></tr><tr><td>0x06</td><td>协议类型。指出IP报文携带的数据使用的是哪种协议，以便目的主机的IP层能知道要将数据报上交到哪个进程。TCP 的协议号为6，UDP 的协议号为17。ICMP 的协议号为1，IGMP 的协议号为2。该 IP 报文携带的数据使用 TCP 协议，得到了验证。</td></tr><tr><td>0x8810</td><td>16bitIP首部校验和。</td></tr><tr><td>0x0a60 5cd4</td><td>32bit源ip地址。</td></tr><tr><td>0xac17 ccdc</td><td>32bit目的ip地址。</td></tr></tbody></table><p>剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。</p><table><thead><tr><th align="left">字节值</th><th align="left">字节含义</th></tr></thead><tbody><tr><td align="left">0x1ba8</td><td align="left">16bit源端口7080</td></tr><tr><td align="left">0xdb9b</td><td align="left">16bit目的端口。56219</td></tr><tr><td align="left">0x6d03 e87d</td><td align="left">32bit序列号。1828972669</td></tr><tr><td align="left">0xa59a 492f</td><td align="left">32bit确认号。2778351919. 第三个包的序列号为2778351310, 加上数据长度609, 正好相等。</td></tr><tr><td align="left">0x8</td><td align="left">4bit首部长度，以4byte为单位。共8*4=32字节。因此TCP报文的可选长度为32-20=12字节</td></tr><tr><td align="left">0b000000</td><td align="left">6bit保留位。目前置为0.</td></tr><tr><td align="left">0b010000</td><td align="left">6bitTCP标志位。从左到右依次是紧急 URG、确认 ACK、推送 PSH、复位 RST、同步 SYN 、终止 FIN。ack有效</td></tr><tr><td align="left">0x00ec</td><td align="left">滑动窗口大小，滑动窗口即tcp接收缓冲区的大小，用于tcp拥塞控制。4117</td></tr><tr><td align="left">0xe04e</td><td align="left">16bit校验和。</td></tr><tr><td align="left">0x0000</td><td align="left">紧急指针。仅在 URG = 1时才有意义，它指出本报文段中的紧急数据的字节数。当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。</td></tr></tbody></table><p>可变长度部分，协议如下：</p><table><thead><tr><th align="left">字节值</th><th align="left">字节含义</th></tr></thead><tbody><tr><td align="left">0x01</td><td align="left">无操作</td></tr><tr><td align="left">0x01</td><td align="left">无操作</td></tr><tr><td align="left">0x0402</td><td align="left">表示支持SACK</td></tr><tr><td align="left">0x080a 2e4c b2ef 0f20 3acf</td><td align="left">时间戳。Ts val=253770487, ecr=776778479</td></tr></tbody></table><p>数据部分为空，这个包仅为确认包。</p><p>再来看第六个包，字节流如下：</p><pre class=" language-shell"><code class="language-shell">0x0000:  4500 00f9 d28c 4000 4006 874a 0a60 5cd40x0010:  ac17 ccdc 1ba8 db9b 6d03 e87d a59a 492f0x0020:  8018 00ec e113 0000 0101 080a 0f20 3af80x0030:  2e4c b2ef 4854 5450 2f31 2e31 2032 30300x0040:  204f 4b0d 0a41 6363 6573 732d 436f 6e740x0050:  726f 6c2d 416c 6c6f 772d 4f72 6967 696e0x0060:  3a20 2a0d 0a44 6174 653a 2054 6875 2c200x0070:  3033 204a 616e 2032 3031 3920 3132 3a320x0080:  333a 3437 2047 4d54 0d0a 436f 6e74 656e0x0090:  742d 4c65 6e67 7468 3a20 3438 0d0a 436f0x00a0:  6e74 656e 742d 5479 7065 3a20 7465 78740x00b0:  2f70 6c61 696e 3b20 6368 6172 7365 743d0x00c0:  7574 662d 380d 0a0d 0a7b 2264 6174 61220x00d0:  3a7b 2261 7265 6122 3a34 3837 3634 31330x00e0:  3535 3937 2e38 3432 3630 367d 2c22 65720x00f0:  7273 7472 223a 2222 7d</code></pre><table><thead><tr><th>字节值</th><th>字节含义</th></tr></thead><tbody><tr><td>0x4</td><td>IP版本为ipv4</td></tr><tr><td>0x5</td><td>首部长度为5 * 4字节=20B</td></tr><tr><td>0x00</td><td>服务类型，现在基本都置为0</td></tr><tr><td>0x00f9</td><td>总长度为249字节，即整个包的长度是249字节</td></tr><tr><td>0xd28c</td><td>标识。同一个数据报的唯一标识。当IP数据报被拆分时，会复制到每一个数据中。</td></tr><tr><td>0x4000</td><td><code>3bit 标志 + 13bit 片偏移</code>。3bit 标志对应 R、DF、MF。目前只有后两位有效，DF位：为1表示不分片，为0表示分片。MF：为1表示“更多的片”，为0表示这是最后一片。13bit 片位移：本分片在原先数据报文中相对首位的偏移位。（需要再乘以8 )</td></tr><tr><td>0x40</td><td>生存时间TTL。IP报文所允许通过的路由器的最大数量。每经过一个路由器，TTL减1，当为 0 时，路由器将该数据报丢弃。TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字 RFC 指定。发送 ICMP 回显应答时经常把 TTL 设为最大值 255。TTL可以防止数据报陷入路由循环。 此处为64.</td></tr><tr><td>0x06</td><td>协议类型。指出IP报文携带的数据使用的是哪种协议，以便目的主机的IP层能知道要将数据报上交到哪个进程。TCP 的协议号为6，UDP 的协议号为17。ICMP 的协议号为1，IGMP 的协议号为2。该 IP 报文携带的数据使用 TCP 协议，得到了验证。</td></tr><tr><td>0x874a</td><td>16bitIP首部校验和。</td></tr><tr><td>0x0a60 5cd4</td><td>32bit源ip地址。</td></tr><tr><td>0xac17 ccdc</td><td>32bit目的ip地址。</td></tr></tbody></table><p>剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。</p><table><thead><tr><th align="left">字节值</th><th align="left">字节含义</th></tr></thead><tbody><tr><td align="left">0x1ba8</td><td align="left">16bit源端口7080</td></tr><tr><td align="left">0xdb9b</td><td align="left">16bit目的端口。56219</td></tr><tr><td align="left">0x6d03 e87d</td><td align="left">32bit序列号。1828972669</td></tr><tr><td align="left">0xa59a 492f</td><td align="left">32bit确认号。2778351919</td></tr><tr><td align="left">0x8</td><td align="left">4bit首部长度，以4byte为单位。共8*4=32字节。因此TCP报文的可选长度为32-20=12字节</td></tr><tr><td align="left">0b000000</td><td align="left">6bit保留位。目前置为0.</td></tr><tr><td align="left">0b011000</td><td align="left">6bitTCP标志位。从左到右依次是紧急 URG、确认 ACK、推送 PSH、复位 RST、同步 SYN 、终止 FIN。ack有效，同时psh有效</td></tr><tr><td align="left">0x00ec</td><td align="left">滑动窗口大小，滑动窗口即tcp接收缓冲区的大小，用于tcp拥塞控制。236</td></tr><tr><td align="left">0xe113</td><td align="left">16bit校验和。</td></tr><tr><td align="left">0x0000</td><td align="left">紧急指针。仅在 URG = 1时才有意义，它指出本报文段中的紧急数据的字节数。当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。</td></tr></tbody></table><p>可变长度部分，协议如下：</p><table><thead><tr><th align="left">字节值</th><th align="left">字节含义</th></tr></thead><tbody><tr><td align="left">0x01</td><td align="left">无操作</td></tr><tr><td align="left">0x01</td><td align="left">无操作</td></tr><tr><td align="left">0x0402</td><td align="left">表示支持SACK</td></tr><tr><td align="left">0x080a 0f20 3af8 2e4c b2ef</td><td align="left">时间戳。Ts val=0x2e4c b2ef=253770488, ecr=0x0f20 3acf=776778479</td></tr></tbody></table><p>剩下来的就是数据部分了。我们一行一行地看。</p><table><thead><tr><th align="left">首地址</th><th align="left">字节流</th><th align="left">字符</th></tr></thead><tbody><tr><td align="left">0x0030</td><td align="left">4854 5450 2f31 2e31 2032 3030</td><td align="left">HTTP/1.1 200</td></tr><tr><td align="left">0x0040</td><td align="left">204f 4b0d 0a41 6363 6573 732d 436f 6e74</td><td align="left">OK \r\n Access-Cont</td></tr><tr><td align="left">0x0050</td><td align="left">726f 6c2d 416c 6c6f 772d 4f72 6967 696e</td><td align="left">rol-Allow-Origin</td></tr><tr><td align="left">0x0060</td><td align="left">3a20 2a0d 0a44 6174 653a 2054 6875 2c20</td><td align="left">: * \r\n Date: Thu,</td></tr><tr><td align="left">0x0070</td><td align="left">3033 204a 616e 2032 3031 3920 3132 3a32</td><td align="left">03 Jan 2019 12:2</td></tr><tr><td align="left">0x0080</td><td align="left">333a 3437 2047 4d54 0d0a 436f 6e74 656e</td><td align="left">3:47 GMT \r\n Conten</td></tr><tr><td align="left">0x0090</td><td align="left">742d 4c65 6e67 7468 3a20 3438 0d0a 436f</td><td align="left">t-Length: 48\r\n Co</td></tr><tr><td align="left">0x00a0</td><td align="left">6e74 656e 742d 5479 7065 3a20 7465 7874</td><td align="left">ntent-Type: text</td></tr><tr><td align="left">0x00b0</td><td align="left">2f70 6c61 696e 3b20 6368 6172 7365 743d</td><td align="left">/plain; charset=</td></tr><tr><td align="left">0x00c0</td><td align="left">7574 662d 380d 0a0d 0a7b 2264 6174 6122</td><td align="left">utf-8\r\n\r\n{“data”</td></tr><tr><td align="left">0x00d0</td><td align="left">3a7b 2261 7265 6122 3a34 3837 3634 3133</td><td align="left">:{“area”:4876413</td></tr><tr><td align="left">0x00e0</td><td align="left">3535 3937 2e38 3432 3630 367d 2c22 6572</td><td align="left">5597.842606},”er</td></tr><tr><td align="left">0x00f0</td><td align="left">7273 7472 223a 2222 7d</td><td align="left">rstr”:””}</td></tr></tbody></table><p>把上表的最后一列连起来，就是：</p><pre class=" language-shell"><code class="language-shell">HTTP/1.1 200 OK Access-Control-Allow-Origin: * Date: Thu, 03 Jan 2019 12:23:47 GMT Content-Length: 48 Content-Type: text/plain; charset=utf-8 {"data":{"area":48764135597.842606},"errstr":""}</code></pre><p>Content-Length: 48，最后一行的长度即为48个字节。</p><p>最后，第七个包，字节流如下：</p><pre class=" language-shell"><code class="language-shell">0x0000:  4500 0034 0000 4000 3606 649c ac17 ccdc0x0010:  0a60 5cd4 db9b 1ba8 a59a 492f 6d03 e9420x0020:  8010 100f 1eb9 0000 0101 080a 2e4c b3140x0030:  0f20 3af8</code></pre><table><thead><tr><th>字节值</th><th>字节含义</th></tr></thead><tbody><tr><td>0x4</td><td>IP版本为ipv4</td></tr><tr><td>0x5</td><td>首部长度为5 * 4字节=20B</td></tr><tr><td>0x00</td><td>服务类型，现在基本都置为0</td></tr><tr><td>0x0034</td><td>总长度为52字节，即整个包的长度是52字节</td></tr><tr><td>0x0000</td><td>标识。同一个数据报的唯一标识。当IP数据报被拆分时，会复制到每一个数据中。</td></tr><tr><td>0x4000</td><td><code>3bit 标志 + 13bit 片偏移</code>。3bit 标志对应 R、DF、MF。目前只有后两位有效，DF位：为1表示不分片，为0表示分片。MF：为1表示“更多的片”，为0表示这是最后一片。13bit 片位移：本分片在原先数据报文中相对首位的偏移位。（需要再乘以8 )</td></tr><tr><td>0x36</td><td>生存时间TTL。IP报文所允许通过的路由器的最大数量。每经过一个路由器，TTL减1，当为 0 时，路由器将该数据报丢弃。TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字 RFC 指定。发送 ICMP 回显应答时经常把 TTL 设为最大值 255。TTL可以防止数据报陷入路由循环。 此处为54.</td></tr><tr><td>0x06</td><td>协议类型。指出IP报文携带的数据使用的是哪种协议，以便目的主机的IP层能知道要将数据报上交到哪个进程。TCP 的协议号为6，UDP 的协议号为17。ICMP 的协议号为1，IGMP 的协议号为2。该 IP 报文携带的数据使用 TCP 协议，得到了验证。</td></tr><tr><td>0x649c</td><td>16bitIP首部校验和。</td></tr><tr><td>0xac17 ccdc</td><td>32bit源ip地址。</td></tr><tr><td>0x0a60 5cd4</td><td>32bit目的ip地址。</td></tr></tbody></table><p>剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。</p><table><thead><tr><th align="left">字节值</th><th align="left">字节含义</th></tr></thead><tbody><tr><td align="left">0xdb9b</td><td align="left">16bit源端口。56219</td></tr><tr><td align="left">0x1ba8</td><td align="left">16bit目的端口7080</td></tr><tr><td align="left">0xa59a 492f</td><td align="left">32bit序列号。2778351919</td></tr><tr><td align="left">0x6d03 e942</td><td align="left">32bit确认号号。1828972866. 第六个包的序列号为1828972669, 加上数据长度197, 正好相等</td></tr><tr><td align="left">0x8</td><td align="left">4bit首部长度，以4byte为单位。共8*4=32字节。因此TCP报文的可选长度为32-20=12字节</td></tr><tr><td align="left">0b000000</td><td align="left">6bit保留位。目前置为0</td></tr><tr><td align="left">0b010000</td><td align="left">6bitTCP标志位。从左到右依次是紧急 URG、确认 ACK、推送 PSH、复位 RST、同步 SYN 、终止 FIN。ack有效</td></tr><tr><td align="left">0x100f</td><td align="left">滑动窗口大小，滑动窗口即tcp接收缓冲区的大小，用于tcp拥塞控制。4111</td></tr><tr><td align="left">0x1eb9</td><td align="left">16bit校验和。</td></tr><tr><td align="left">0x0000</td><td align="left">紧急指针。仅在 URG = 1时才有意义，它指出本报文段中的紧急数据的字节数。当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。</td></tr></tbody></table><p>可变长度部分，协议如下：</p><table><thead><tr><th align="left">字节值</th><th align="left">字节含义</th></tr></thead><tbody><tr><td align="left">0x01</td><td align="left">无操作</td></tr><tr><td align="left">0x01</td><td align="left">无操作</td></tr><tr><td align="left">0x080a 2e4c b314 0f20 3af8</td><td align="left">时间戳。Ts val=0x2e4c b314=776778516, ecr=0x0f20 3af8=253770488</td></tr></tbody></table><p>至此，一次完整的http请求的报文就解析完了。感觉如何，是不是很亲切？</p><h1 id="HTTP协议分析"><a href="#HTTP协议分析" class="headerlink" title="HTTP协议分析"></a>HTTP协议分析</h1><p>上面我们把HTTP协议相关的数据给解构了，下面我将对照上面的数据拆解结果，一步步带你深入理解HTTP协议。</p><h2 id="整体介绍"><a href="#整体介绍" class="headerlink" title="整体介绍"></a>整体介绍</h2><p><code>HTTP</code>(Hypertext Transfer Protocol)超文本传输协议，是在互联网上进行通信时使用的一种协议。说得更形象一点：<code>HTTP</code>是现代互联网中使用的公共语言。它最著名的应用是用在浏览器的服务器间的通信。</p><p>HTTP属于应用层协议，底层是靠TCP进行可靠地信息传输。</p><p><img src="https://user-images.githubusercontent.com/7698088/51079842-4b2f1780-170a-11e9-9b22-ad68fe4541cc.png" alt="HTTP层次"></p><p>HTTP在传输一段报文时，会以<code>流</code>的形式将报文数据的内容通过<code>一条打开</code>的TCP连接按序传输。TCP接到上层应用交给它的数据流之后，会按序将数据流打散成一个个的分段。再交到IP层，通过网络进行传输。另一端的接收方则相反，它们将接收到的分段按序组装好，交给上层HTTP协议进行处理。</p><p><img src="https://user-images.githubusercontent.com/7698088/50802850-15adb700-1323-11e9-87b8-892139c3104d.png" alt="tcp http structure"></p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>我们再来回顾一下：</p><p><img src="https://user-images.githubusercontent.com/7698088/61799702-286e8000-ae5e-11e9-9aad-768f0a522f12.png" alt="编码"></p><p>在之前的报文拆解过程中，我们看到多了很多<code>%22</code>，其实，<code>0x22</code>是单引号<code>&quot;</code>的ascii值，</p><p>一方面，URL描述的资源为了能通过其他各种协议传送，但是有些协议在传输过程中会剥去一些特定的字符；另一方面，URL还是可读的，所以那些不可打印的字符就不能在URL中使用了，比如空格；最后，URL还得是完整的，它需要支持所有语言的字符。</p><p>总之，基于很多原因，URL设计者将US-ASCII码和其转义序列集成到URL中，通过转义序列，就可以用US-ASCII字符集的有限子集对任意字符或数据进行编码了。</p><p>转义的方法：百分号(<code>%</code>)后跟着两个表示ASCII码的十六进制数。比如：</p><p><img src="https://user-images.githubusercontent.com/7698088/51080616-322e6280-171a-11e9-8deb-28ca0a472d51.png" alt="转义法"></p><p>所以上面在浏览器发送给服务器的URL进行了非“安全字符”编码，也就不奇怪了吧？</p><p><img src="https://user-images.githubusercontent.com/7698088/51294507-3aeea380-1a4e-11e9-9f52-2fb248a2d5de.png" alt="url保留及受限的字符"></p><p>在URL中，当上面的保留字符用在保留用途之外的场合时，需要对URL进行编码。</p><h2 id="MIME类型"><a href="#MIME类型" class="headerlink" title="MIME类型"></a>MIME类型</h2><p>响应数据中，我们注意到有一个首部：</p><pre class=" language-shell"><code class="language-shell">Content-Type: text/plain; charset=utf-8</code></pre><p>互联网上有数千种不同的数据类型，HTTP给每种对象都打上了MIME(Multipurpose Internet Media Extension, 多用途因特网邮件扩展)标签，也就是响应数据中的<code>Content-Type</code>. MIME本来是用在邮件协议中的，后来被移植到了HTTP中。浏览器从服务器上取回了一个对象时，会去查看MIME类型，从而得知如何处理这种对象，是该展示图片，还是调用声卡播放声音。MIME通过斜杠来标识对象的主类型和其中的特定的子类型，下表展示了一些常见的类型，其中的实体主体是指body部分：</p><p><img src="https://user-images.githubusercontent.com/7698088/51149947-3768ea00-189f-11e9-8fcd-d40f2f2ccf0a.png" alt="MIME类型"></p><h2 id="URI-URL-URN"><a href="#URI-URL-URN" class="headerlink" title="URI/URL/URN"></a>URI/URL/URN</h2><p>URI(Uniform Resource Identifier, 统一资源标识符)表示服务器资源，URL(Uniform Resource Locator, 统一资源定位符)和URN(Uniform Resource Name, 统一资源名)是URI的具体实现。URI是一个通用的概念，由两个主要的子集URL和URN构成，URL通过位置、URN通过名字来标识资源。</p><p>URL定义了资源的位置，表示资源的实际地址，在使用URL的过程中，如果URL背后的资源发生了位置移动，访问者就找不到它了。这个时候就要用到URN了，它给定资源一个名字，无论它移动到哪里，都可以通过这个名字来访问到它，简直完美！</p><p>URL通常的格式是：</p><pre class=" language-shell"><code class="language-shell">协议方案+服务器地址+具体的资源路径</code></pre><p>协议方案(scheme)，如 <code>http</code>, <code>ftp</code>，告知web客户端怎样访问资源)；服务器地址，如 <code>www.oreilly.com</code>; 具体的资源路径，如 <code>index.html</code>. </p><p><img src="https://user-images.githubusercontent.com/7698088/51070533-b5e64180-167d-11e9-8dc3-4c54b3cbf1a2.png" alt="URL举例"></p><h2 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h2><p>HTTP支持几种不同的请求方法，每种方法对服务器要求的动作不同，如下图是几种常见的方法：</p><p><img src="https://user-images.githubusercontent.com/7698088/51070644-a0721700-167f-11e9-8579-8702abdb860b.png" alt="常见的http方法"></p><p>HEAD方法只获取头部，不获取数据部分。通过头部可以获取比如资源的类型(Content-Type)、资源的长度(Content-Length)这些信息。这样，客户端可以获取即将请求资源的一些情况，可以做到心中有数。</p><p>POST用于向服务器发送数据，常见的是提交表单；PUT用于向服务器上的资源存储数据。</p><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>每条HTTP的响应报文都会带上一个三位数字的状态码和一条解释性的“原因短语”，通知客户端本次请求的状态，帮助客户端快速理解事务处理结果，最常见的是：</p><pre class=" language-shell"><code class="language-shell">200 OK 404 Not Found500 Internal Server Error</code></pre><p>我们平时使用浏览器的时候，很多的错误码其实是由浏览器处理的，我们感知不到。但是<code>404 Not Found</code>会穿透重重迷雾，来到我们面前，为何？那是因为他对我们爱的深沉啊！</p><p>客户端可以据此状态码，决定下一步的行动（如重定向等）。</p><p>三位数字的第一位表示分类：</p><p><img src="https://user-images.githubusercontent.com/7698088/51070802-2f802e80-1682-11e9-8a02-f60e2f11c3e6.png" alt="http状态分类"></p><h2 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h2><p>HTTP报文实际上是由一行行的字符串组成的，每行字符串的末尾用<code>\r\n</code>分隔，人类可以很方便的阅读。顺便说一句，不是所有的协议都对人类这么友好的，像thrift协议，直接甩一堆字节给你，告诉你说<code>0x0001</code>表示调用方法，诸如此类的，你只能对着一个十六进制的数据块一个个地去“解码”。不可能像HTTP协议这样，直接将字符编码，人类可以直接读懂。</p><p>举个简单的请求报文和响应报文的格式的例子：</p><p><img src="https://user-images.githubusercontent.com/7698088/51070991-6dcb1d00-1685-11e9-8dae-25b63ad7ad52.png" alt="请求响应报文示例"></p><p>实际上，请求报文也是可以有body（主体）部分的。请求报文是由<code>请求行（request line）、请求头部（header）、空行、请求数据</code>四个部分组成。唯一要注意的一点就是，请求报文即使body部分是空的，请求头部后的<code>回车换行</code>符也是必须要有的。</p><p><img src="https://user-images.githubusercontent.com/7698088/51071026-c4d0f200-1685-11e9-81ca-87c8da1dfc30.png" alt="请求报文格式"></p><p>响应报文的格式和请求报文的格式类似：</p><p><img src="https://user-images.githubusercontent.com/7698088/51074380-67ef2f00-16b9-11e9-81e7-d5ecaa8d4537.png" alt="响应报文格式"></p><p>请求报文、响应报文的起始行和响应头部里的字段都是文本化、结构化的。而请求body却可以包含任意二进制数据（如图片、视频、软件等），当然也可以包含文本。</p><p>有些首部是通用的，有些则是请求或者响应报文才会有的。</p><table><thead><tr><th align="left">首部</th><th align="left">属性</th><th align="left">值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">Date</td><td align="left">通用</td><td align="left">Thu, 03 Jan 2019 12:23:47 GMT</td><td align="left">报文构建的时间</td></tr><tr><td align="left">Accept</td><td align="left">请求报文</td><td align="left">text/html,application/xhtml+xml,application/xm</td><td align="left">客户端能接收的数据类型</td></tr><tr><td align="left">Content-Type</td><td align="left">通用</td><td align="left">Content-Type: text/plain; charset=utf-8</td><td align="left">报文中的body部分的数据类型。注意，若是请求报文中也有数据部分，也是需要此字段的</td></tr></tbody></table><p>顺便提一下， 用telnet直连服务器的http端口，telnet命令会建立一条TCP通道，然后就可以通过这个通道直接发送HTTP请求数据，获取响应数据了。</p><p><img src="https://user-images.githubusercontent.com/7698088/51079989-318fcf00-170e-11e9-9958-daf87d65972b.png" alt="用telnet进行http对话"></p><h1 id="HTTP协议进阶"><a href="#HTTP协议进阶" class="headerlink" title="HTTP协议进阶"></a>HTTP协议进阶</h1><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>HTTP的代理服务器既是Web服务器，又是Web客户端。</p><p><img src="https://user-images.githubusercontent.com/7698088/51082793-23ab6f80-1749-11e9-8247-1a3fc5ac4d1d.png" alt="HTTP代理"></p><p>使用代理可以“接触”到所有流过的HTTP流量，代理可以对其进行监视和修改。常见的就是对儿童过滤一些“成人”内容；网络工程师会利用代理服务器来提高安全性，它可以限制哪些应用层的协议数据可以通过，过滤“病毒”等数据；代理可以存储缓存的文件，直接返回给访问者，无需请求原始的服务器资源；对于访问慢速网络上的公共内容时，可以假扮服务器提供服务，从而提高访问速度；这被称为<code>反向代理</code>；可以作为内容路由器，如对付费用户，则将请求导到缓存服务器，提高访问速度；可以将页面的语言转换到与客户端相匹配，这称为<code>内容转码器</code>; <code>匿名代理</code>会主动从HTTP报文中删除身份相关的信息，如<code>User-Agent</code>, <code>Cookie</code>等字段。</p><p>现实中，请求通过以下几种方式打到代理服务器上去：</p><p><img src="https://user-images.githubusercontent.com/7698088/51083035-c534c000-174d-11e9-9cab-ddc4a0de2314.png" alt="代理获取流量的方式"></p><p>报文每经过一个中间点（代理或网关），都需要在首部via字段的末尾插入一个可以代表本节点的独特的字符串，包含实现的协议版本和主机地址。注意图中的via字段。</p><p><img src="https://user-images.githubusercontent.com/7698088/51083254-e7304180-1751-11e9-95f8-a833a0d10d51.png" alt="via字段"></p><p>请求和响应的报文传输路径通常都是一致的，只不过方向是相反的。因此，响应报文上的via字段表示的中间节点的顺序是刚好相反的。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>当有很多请求访问同一个页面时，服务器会多次传输同一份数据，这些数据重复地在网络中传输着，消耗着大量带宽。如果将这些数据缓存下来，就可以提高响应速度，节省网络带宽了。</p><p>大部分缓存只有在客户端发起请求，并且副本已经比较旧的情况下才会对副本的新鲜度进行检测。最常用的请求首部是<code>If-Modified-Since</code>, 如果在xx时间(此时间即为If-Modified-Since的值)之后内容没有变化，服务器会回应一个<code>304 Not Modified</code>. 否则，服务器会正常响应，并返回原始的文件数据，而这个过程中被称为<code>再验证命中</code>。</p><p>再验证可能出现命中或未命中的情况。未命中时，服务器回复<code>200 OK</code>，并且返回完整的数据；命中时，服务器回复<code>304 Not Modified</code>; 还有一种情况，缓存被删除了，那么根据响应状态码，缓存服务器也会删除自己缓存的副本。</p><p>顺带提一句，若要在项目中使用缓存，就一定要关注缓存命中比例。若命中比例不高，就要重新考虑设置缓存的必要性了。</p><p>缓存服务器返回响应的时候，是基于已缓存的服务器响应的首部，再对一些首部字段做一些微调。比如向其中插入新鲜度信息（如<code>Age</code>, <code>Expires</code>首部等），而且通常会包含一个<code>via</code>首部来说明缓存是由一个缓存代理提供的。注意，这时不要修改<code>Date</code>字段，它表示原始服务器最初构建这条响应的日期。</p><p>HTTP通过<code>文档过期机制</code>和<code>服务器再验证机制</code>保持已缓存数据和服务器间的数据充分一致。</p><p>文档过期通过如下首部字段来表示缓存的有效期：</p><p><img src="https://user-images.githubusercontent.com/7698088/51092170-60ba4500-17cf-11e9-8689-71b3c552bff3.png" alt="缓存有效期"></p><p>当上面两个字段暗示的过期时间已到，需要向服务器再次验证文档的新鲜度。如果这时缓存仍和服务器上的原始文档一致，缓存只需要更新头部的相关字段。如上表中提到的<code>Expires</code>字段等。</p><p>为了更好的节省网络流量，缓存服务器可以通过相关首部向原始服务器发送一个<code>条件GET</code>请求, 这样只有在缓存真正过期的情况下，才会返回原始的文档，否则只会返回相关的首部。<code>条件GET</code>请求会用到如下的字段：</p><p><img src="https://user-images.githubusercontent.com/7698088/51092289-8562ec80-17d0-11e9-9e35-47a010a3f7a3.png" alt="缓存条件GET"></p><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>cookie是服务器“贴在”客户端身上的标签，由客户端维护的状态片段，并且只会回送给合适的站点。</p><p>有两类cookie: 会话cookie、持久cookie. 会话cookie在退出浏览器后就被删除了；而持久cookie则保存在硬盘中，计算机重启后仍然存在。</p><p>服务器在给客户端的响应字段首部加上<code>Set-cookie</code>或<code>Set-cookie2</code>, 值为<code>名字=值</code>的列表，即可以包含多个字段。当下次浏览器再次访问到相同的网站时，会将这些字段通过<code>Cookie</code>带上。cookie中保留的内容是服务器给此客户端打的标签，方便服务进行追踪的识别码。浏览器会将cookie以特定的格式存储在特定的文件中。</p><p>浏览器只会向产生这条cookie的站点发生cookie. <code>Set-cookie</code>字段的值会包含<code>domain</code>这个字段，告知浏览器可以把这条cookie发送给给相关的匹配的站点。<code>path</code>字段也是相似的功能。如i浏览器收到如下的cookie:</p><pre class=" language-shell"><code class="language-shell">Set-cookie: user="mary"; domain="stefno.com"</code></pre><p>那么浏览器在访问任意以<code>stefno.com</code>结尾的站点都会发送：</p><pre class=" language-shell"><code class="language-shell">Cookie: user="mary"</code></pre><h2 id="实体和编码"><a href="#实体和编码" class="headerlink" title="实体和编码"></a>实体和编码</h2><p>响应报文中的body部分传输的数据本质上都是二进制。我们从上面的报文数据也可以看出来，都是用十六进制数来表示，关键是怎么解释这块内容。如果<code>Content-Type</code>定义是<code>text/plain</code>, 那说明body内容就是文本，我们直接按文本编码来解释；如果<code>Content-Type</code>定义是<code>image/png</code>, 说明body部分是一幅图片，那我们就按图片的格式去解释数据。</p><p><code>Content-Length</code>标示报文主体部分的数据长度大小，如果内容是压缩的，那它表示的就是压缩后的大小。另外，<code>Content-Length</code>在长连接的情况下，可以对多个报文进行正确地分段。所以，如果没有采用分块编码，响应数据中必须带上<code>Content-Length</code>字段。分块编码的情形中，数据被拆分成很多小块，每块都有大小说明。因此，任何带有主体部分的报文（请求或是响应）都应带上正确的<code>Content-Length</code>首部。</p><p>HTTP的早期版本采用关闭连接的方式来划定报文的结束。这带来的问题是显而易见的：客户端并不能分清是因为服务器正常结束还是中途崩溃了。这里，如果是客户端用关闭来表示请求报文主体部分的结束，是不可取的，因为关闭之后，就无法获取服务器的响应了。当然，客户端可以采用半关闭的方式，只关闭数据发送方向，但是很多服务器是不识别的，会把半关闭当成客户端要成服务器断开来处理。</p><p>HTTP报文在传输的过程中可能会遭到代理或是其他通信实体的无意修改，为了让接收方知道这种情况，服务器会对body部分作一个md5, 并把值放到<code>Content-MD5</code>这个字段中。但是，如果中间的代理即修改了报文主体，又修改了md5, 就不好检测了。因此规定代理是不能修改<code>Content-MD5</code>首部的。这样，客户端在收到数据后，先进行解码，再算出md5, 并与<code>Content-MD5</code>首部进行比较。这主要是防止代理对报文进行了无意的改动。</p><p>HTTP在发送内容之前需要对其进行编码，它是对报文主体进行的可逆变换。比如将报文用gzip格式进行压缩，减少传输时间。常见的编码类型如下：</p><p><img src="https://user-images.githubusercontent.com/7698088/51150609-12c24180-18a2-11e9-9ca4-032f5abcd474.png" alt="编码类型"></p><p>当然，客户端为了避免服务器返回自己不能解码的数据，请求的时候，会在<code>Accept-Encoding</code>首部里带上自己支持的编码方式。如果不传输的话，默认可以接受任何编码方式。</p><p>上面提到的编码是内容编码，它只是在响应报文的主体报文将原始数据进行编码，改变的是内容的格式。还有另一种编码：<code>传输编码</code>。它与内容无关，它是为了改变报文数据在网络上传输的方式。传输编码是在HTTP 1.1中引入的一个新特性。</p><p>通常，服务器需要先生成数据，再进行传输，这时，可以计算数据的长度，并将其编码到<code>Content-Length</code>中。但是，有时，内容是动态生成的，服务器希望在数据生成之前就开始传输，这时，是没有办法知道数据大小的。这种情况下，就要用到<code>传输编码</code>来标注数据的结束的。</p><p>HTTP协议中通过如下两个首部来描述和控制传输编码：</p><table><thead><tr><th align="left">字段</th><th align="left">含义</th><th align="left">典型值</th></tr></thead><tbody><tr><td align="left">Transfer-Encoding</td><td align="left">发送方告知接收方，我方已经进行了何种传输编码</td><td align="left">chuncked 分块编码</td></tr><tr><td align="left">TE</td><td align="left">请求方告知服务器可以用哪种传输编码</td><td align="left">trailers, chuncked 接受分块编码，并且愿意接受在报文结尾上的拖挂</td></tr></tbody></table><p>分块编码的报文形式是这样的：</p><p><img src="https://user-images.githubusercontent.com/7698088/51151337-671af080-18a5-11e9-80ad-926461f90f6a.png" alt="分块编码"></p><p>每个分块包含一个长度值（十六进制，字节数）和该分块的数据。<code>&lt;CR&gt;&lt;LF&gt;</code>用于区隔长度值和数据。长度值不包含分块中的任何<code>&lt;CR&gt;&lt;LF&gt;</code>序列。最后一个分块，用长度值0来表示结束。注意报文首部包含一个<code>Trailer: Content-MD5</code>, 所以在紧跟着最后一个报文结束之后，就是一个拖挂。其他如，<code>Content-Length</code>, <code>Trailer</code>, <code>Transfer-Encoding</code>也可以作为拖挂。</p><p>内容编码和传输编码是可以结合起来使用的。</p><p><img src="https://user-images.githubusercontent.com/7698088/51151680-ae55b100-18a6-11e9-819c-5cffcc35cd69.png" alt="内容编码和传输编码结合"></p><h2 id="国际化支持"><a href="#国际化支持" class="headerlink" title="国际化支持"></a>国际化支持</h2><p>HTTP为了支持国际化的内容，客户端要告知服务器自己能理解的何种语言，以及浏览器上安装了何种字母表编码算法。这通过<code>Accept-Charset</code>和<code>Accept-Language</code>首部实现。</p><p>比如：</p><pre><code>Accept-Language: fr, en;q=0.8Accept-Charset: iso-8859-1, utf-8</code></pre><p>表示：客户端接受法语(fr, 优先级默认为1.0）、英语（en, 优先级为0.8），支持iso-8859-1, utf-8两种字符集编码。服务器则会在<code>Content-Type</code>首部里放上<code>charset</code>.</p><p>本质上，HTTP报文的body部分存放的就是一串二进制码，我们先把二进制码转换成字符代码（如ascii是一个字节表示一个字符，而utf-8则表示一个字符的字节数不定，每个字符1~6个字节），之后，用字符代码去字符集中找到对应的元素。</p><p>比较常见的字符集是<code>US-ASCII</code>: 这个字符集是所有字符集的始祖，早在1968年就发布了标准。ASCII码的代码值从0到127, 只需要7个bit位就可以覆盖代码空间。HTTP报文的首部、URL使用的字符集就是ASCII码。可以再看下上文报文分析部分的acsii码集。</p><p><code>US-ASCII</code>是把每个字符编码成固定的7位二进制值。<code>UTF-8</code>则是无固定的编码方案。第一个字节的高位用来表示编码后的字符所用的字节数（如果所用的字节数是5，则第一个字节前5bit都是1，第6bit是0），所需的后续的字节都含有6位的代码值，前两个bit位是用<code>10</code>标识。</p><p><img src="https://user-images.githubusercontent.com/7698088/51167193-e2e65e80-18e0-11e9-97da-caea0244386d.png" alt="utf-8编码"></p><p>举个例子，汉字“严”的Unicode编码为<code>4E25</code>(<code>100111000100101</code>), 共有15位，落在上表中的第三行，因此“严”的编码就需要三个字节。将<code>100111000100101</code>填入上表中的<code>c</code>位即可。因此，严的<code>UTF-8</code>编码是11100100 10111000 10100101，转换成十六进制就是E4B8A5. 比如我在谷歌搜索框里搜索“严”字，google发出的请求如下：</p><pre class=" language-json"><code class="language-json">https<span class="token operator">:</span>//www.google.com.hk/search?q=%E4%B8%A5&amp;oq=%E4%B8%A5&amp;aqs=chrome..69i57j0l5.3802j0j4&amp;sourceid=chrome&amp;ie=UTF<span class="token number">-8</span>&amp;gws_rd=cr</code></pre><p><code>q=%E4%B8%A5</code>这个就是搜索的词了。</p><h2 id="重定向与负载均衡"><a href="#重定向与负载均衡" class="headerlink" title="重定向与负载均衡"></a>重定向与负载均衡</h2><p>Web内容通常分散地分布在很多地方，这可以防止“单点故障”，万一某个地方发生地震了，机房被毁了，那还有其他地方的机房可以提供服务。一般都会有所谓的“双活”，“多活”，所谓<code>狡兔三窟</code>嘛。</p><p>这样，用户的请求会根据<code>负载均衡</code>的原则，被<code>重定向</code>到它应该去的地方。</p><h3 id="HTTP重定向"><a href="#HTTP重定向" class="headerlink" title="HTTP重定向"></a>HTTP重定向</h3><p>服务器收到客户端请求后，向客户端返回一条带有状态码<code>302</code>重定向的报文，告诉他们应该去其他的地方试试。web站点将重定向看成一种简单的负载均衡策略来使用，<code>重定向</code>服务器找到可用的负载最小的机器，由于服务器知道客户端的地址，理论上来说，可以做到最优的重定向选择。</p><p>当然，缺点也是显而易见的，由于客户端要发送两次请求，因此会增加耗时。</p><h3 id="DNS重定向"><a href="#DNS重定向" class="headerlink" title="DNS重定向"></a>DNS重定向</h3><p>DNS将几个IP地址关联到一个域上，采用算法决定返回的IP地址。可以是简单的<code>轮转</code>；也可以是更高级的算法，如返回负载最轻的服务器的IP地址，称为<code>负载均衡算法</code>；如果考虑地理位置，返回给客户端最近位置的地址，称为<code>邻接路由算法</code>；还有一种是绕过出现故障的地址，称为<code>故障屏蔽算法</code>。</p><p>DNS服务器总是会返回所有的IP地址，但是DNS客户端一般只会使用第一个IP地址，而且会缓存下来，之后会一直用这个地址。所以，DNS轮转通常不会平衡单个客户端的负载。但是，由于DNS服务器对于不同的请求，总是会返回轮转后的IP地址列表，因此，会把负载分散到多个客户端。</p><h2 id="HTTP连接"><a href="#HTTP连接" class="headerlink" title="HTTP连接"></a>HTTP连接</h2><p>HTTP连接是HTTP报文传输的关键通道。</p><h3 id="并行连接"><a href="#并行连接" class="headerlink" title="并行连接"></a>并行连接</h3><p>对于一个页面上同时出现多个对象的时候，如果浏览器并行地打开多个连接，同时去获取这些对象，多个连接的TCP握手时延可以进行重叠，速度会快起来。</p><p>如一个包含3张图片的页面，浏览器要发送4次HTTP请求来获取页面。1个用于顶层的HTML页面，3个用于图片。如果采用串行方式，那么连接时延会进行叠加。</p><p><img src="https://user-images.githubusercontent.com/7698088/50803988-0f213e80-1327-11e9-93d9-10339ee54864.png" alt="串行连接"></p><p>采用并行连接之后：</p><p><img src="https://user-images.githubusercontent.com/7698088/50803776-13992780-1326-11e9-8752-defd450ca639.png" alt="并行连接"></p><p>但是并行连接也不绝对提升速度，如果一个页面有数百个内嵌对象，那要启动数百个连接，对服务器的性能也是非常大的挑战。所以，通常浏览器会限制并行连接的总数据在一个较小的值，通常是4个，而且服务端可以随意关闭客户端超量的连接。</p><p>另一方面，如果客户端网络带宽较小，每个连接都会去争抢有限的带宽，每个连接都会获取较小的速度，即每个对象都会以较小的速度去加载。这样，并行连接带来的速度提升就会比较小，甚至没有提升。</p><h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><p>HTTP keep-alive机制</p><p>我们知道HTTP请求是“请求-应答”模式，每次请求-应答都要新建一个连接，完成之后要断开连接。HTTP是无状态的，连接之间没有任何关系。</p><p>HTTP是应用层协议，TCP是传输层协议。HTTP底层仍然采用TCP进行传输数据。TCP为HTTP提供了一层可靠的比特传输通道。HTTP一般交换的数据都不大，而每次连接都要进行TCP三次握手，很大一部分时间都消耗在这上面，有时候甚至能达到50%。如果能复用连接，就可以减少由于TCP三次握手所带来的时延。</p><p>HTTP 1.1默认开启keep-alive机制，从上面抓到的包也可以看到。这样，数据传输完成之后保持TCP连接不断开，之后同域名下复用连接，继续用这个通道传输数据。服务器在响应一个请求后，可以保持这个连接keep-alive timeout的时间，在这个时间内没有请求，则关闭此连接；否则，重新开始倒计时keep-alive timeout时间。</p><p><img src="https://user-images.githubusercontent.com/7698088/51286420-e4716d00-1a2d-11e9-9b95-79b1e0a1984a.png" alt="http keep alive"></p><p>HTTP有keep-alive机制，目的是可以在一个TCP<br>连接上传输多个HTTP事务，以此提高通信效率。底层的TCP其实也有keep-alive机制，它是为了探测TCP连接的活跃性。TCP层的keepalive可以在任何一方设置，可以是一端设置、两端同时设置或者两端都没有设置。新建socket的时候需要设置，从而使得协议栈调用相关函数tcp_set_keepalive，来激活连接的keep-alive属性。</p><p>当网络两端建立了TCP连接之后，闲置（双方没有任何数据流发送往来）时间超过<code>tcp_keepalive_time</code>后，服务器内核就会尝试向客户端发送侦测包，来判断TCP连接状况(有可能客户端崩溃、强制关闭了应用、主机不可达等等)。如果没有收到对方的回答(ack包)，则会在 <code>tcp_keepalive_intvl</code>后再次尝试发送侦测包，直到收到对方的ack,如果一直没有收到对方的ack,一共会尝试 tcp_keepalive_probes次，每次的间隔时间在这里分别是15s, 30s, 45s, 60s, 75s。如果尝试<code>tcp_keepalive_probes</code>次后,依然没有收到对方的ack包，则会丢弃该TCP连接。TCP连接默认闲置时间是2小时，一般设置为30分钟足够了。</p><h3 id="管道化连接"><a href="#管道化连接" class="headerlink" title="管道化连接"></a>管道化连接</h3><p>在keep-alive的基础上，我们可以做地更进一步，在响应到达之前，我们将多条请求按序放入请求队列，服务端在收到请求后，必须按照顺序对应请求的响应。但由于网络环境非常复杂，因此即使请求是按顺序发送的，也不一定是按顺序到达服务端的。而且就算是服务端按序处理的，也不一定是按序返回给客户端，所以最好是在响应中附带一些可以标识请求的参数。</p><p>为了安全起见，管道化的连接只适合“幂等”的请求，一般我们认为：GET/HEAD/PUT/DELETE/TRACE/OPTIONS等方法都是幂等的。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>以上，就是所有HTTP的通信细节了，足够在日常开发 作中使用了。更多没有涉及的细节可以在用到的时候再去仔细研究。</p><p>文章看完了，不知道你对HTTP的理解有没有更上一层楼？欢迎一起交流探讨。</p><p><img src="https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png" alt="QR margin2"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【http长连接】<a href="https://www.cnblogs.com/cswuyg/p/3653263.html" target="_blank" rel="noopener">https://www.cnblogs.com/cswuyg/p/3653263.html</a></p><p>【http/tcp keep alive】<a href="https://segmentfault.com/a/1190000012894416" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012894416</a></p><p>【http/tcp keep alive】<a href="http://www.nowamagic.net/academy/detail/23350305" target="_blank" rel="noopener">http://www.nowamagic.net/academy/detail/23350305</a></p><p>【http/tcp keep alive】<a href="https://laravel-china.org/articles/8020/on-the-keep-alive-and-tcp-keep-alive-in-the-http-protocol" target="_blank" rel="noopener">https://laravel-china.org/articles/8020/on-the-keep-alive-and-tcp-keep-alive-in-the-http-protocol</a></p><p>【tcp keep alive】<a href="http://blog.51cto.com/zxtong/1788252" target="_blank" rel="noopener">http://blog.51cto.com/zxtong/1788252</a></p><p>【http权威指南】<a href="https://book.douban.com/subject/10746113/" target="_blank" rel="noopener">https://book.douban.com/subject/10746113/</a></p><p>【HTTP状态码】<a href="https://www.cnblogs.com/starof/p/5035119.html" target="_blank" rel="noopener">https://www.cnblogs.com/starof/p/5035119.html</a></p><p>【HTTP协议】<a href="https://www.cnblogs.com/ranyonsue/p/5984001.html" target="_blank" rel="noopener">https://www.cnblogs.com/ranyonsue/p/5984001.html</a></p><p>【HTTP状态分类】<a href="http://www.runoob.com/http/http-status-codes.html" target="_blank" rel="noopener">http://www.runoob.com/http/http-status-codes.html</a></p><p>【url编码】<a href="http://www.ruanyifeng.com/blog/2010/02/url_encoding.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2010/02/url_encoding.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇&lt;a href=&quot;https://www.cnblogs.com/qcrao-2018/p/10182185.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章&lt;/a&gt;中，我们学会了用wireshark和tcpdump来分析TCP的“三次握
      
    
    </summary>
    
      <category term="HTTP" scheme="https://github.com/qcrao/qcrao.github.io/categories/HTTP/"/>
    
    
      <category term="协议" scheme="https://github.com/qcrao/qcrao.github.io/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>“三次握手，四次挥手”你真的懂吗？</title>
    <link href="https://github.com/qcrao/qcrao.github.io/2019/01/16/dive-into-three-way-handshake/"/>
    <id>https://github.com/qcrao/qcrao.github.io/2019/01/16/dive-into-three-way-handshake/</id>
    <published>2019-01-16T03:10:00.000Z</published>
    <updated>2019-07-24T11:03:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>记得刚毕业找工作面试的时候，经常会被问到：你知道“3次握手，4次挥手”吗？这时候我会“胸有成竹”地“背诵”前期准备好的“答案”，第一次怎么怎么，第二次……答完就没有下文了，面试官貌似也没有深入下去的意思，深入下去我也不懂，皆大欢喜！</p><p>作为程序员，要有“刨根问底”的精神。知其然，更要知其所以然。这篇文章希望能抽丝剥茧，还原背后的原理。<br>[toc]</p><h1 id="什么是“3次握手，4次挥手”"><a href="#什么是“3次握手，4次挥手”" class="headerlink" title="什么是“3次握手，4次挥手”"></a>什么是“3次握手，4次挥手”</h1><p>TCP是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如ip地址、端口号等。</p><p>TCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。</p><p>TCP提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用4次挥手来关闭一个连接。</p><h2 id="TCP服务模型"><a href="#TCP服务模型" class="headerlink" title="TCP服务模型"></a>TCP服务模型</h2><p>在了解了建立连接、关闭连接的“三次握手和四次挥手”后，我们再来看下TCP相关的东西。</p><p>一个TCP连接由一个4元组构成，分别是两个IP地址和两个端口号。一个TCP连接通常分为三个阶段：启动、数据传输、退出（关闭）。</p><p>当TCP接收到另一端的数据时，它会发送一个确认，但这个确认不会立即发送，一般会延迟一会儿。ACK是累积的，一个确认字节号N的ACK表示所有直到N的字节（不包括N）已经成功被接收了。这样的好处是如果一个ACK丢失，很可能后续的ACK就足以确认前面的报文段了。</p><p>一个完整的TCP连接是双向和对称的，数据可以在两个方向上平等地流动。给上层应用程序提供一种<code>双工服务</code>。一旦建立了一个连接，这个连接的一个方向上的每个TCP报文段都包含了相反方向上的报文段的一个ACK。</p><p>序列号的作用是使得一个TCP接收端可丢弃重复的报文段，记录以杂乱次序到达的报文段。因为TCP使用IP来传输报文段，而IP不提供重复消除或者保证次序正确的功能。另一方面，TCP是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。因此TCP接收端会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段被填满。</p><h2 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a>TCP头部</h2><p><img src="http://upload-images.jianshu.io/upload_images/12234098-40089b5b24b9d38b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tcp header"></p><p>源端口和目的端口在TCP层确定双方进程，序列号表示的是报文段数据中的第一个字节号，ACK表示确认号，该确认号的发送方期待接收的下一个序列号，即最后被成功接收的数据字节序列号加1，这个字段只有在ACK位被启用的时候才有效。</p><p>当新建一个连接时，从客户端发送到服务端的第一个报文段的SYN位被启用，这称为SYN报文段，这时序列号字段包含了在本次连接的这个方向上要使用的第一个序列号，即初始序列号<code>ISN</code>，之后发送的数据是ISN加1，因此SYN位字段会<code>消耗</code>一个序列号，这意味着使用重传进行可靠传输。而不消耗序列号的ACK则不是。</p><p>头部长度（图中的数据偏移）以32位字为单位，也就是以4bytes为单位，它只有4位，最大为15，因此头部最大长度为60字节，而其最小为5，也就是头部最小为20字节（可变选项为空）。</p><p>ACK —— 确认，使得确认号有效。<br>RST —— 重置连接（经常看到的reset by peer）就是此字段搞的鬼。<br>SYN —— 用于初如化一个连接的序列号。<br>FIN —— 该报文段的发送方已经结束向对方发送数据。</p><p>当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据。</p><h2 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h2><p>三次握手和四次挥手的状态转换如下图。<br><img src="http://upload-images.jianshu.io/upload_images/12234098-40f65020a755ca18?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tcp connect"></p><h1 id="为什么要“三次握手，四次挥手”"><a href="#为什么要“三次握手，四次挥手”" class="headerlink" title="为什么要“三次握手，四次挥手”"></a>为什么要“三次握手，四次挥手”</h1><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>换个易于理解的视角来看为什么要3次握手。</p><p>客户端和服务端通信前要进行连接，“3次握手”的作用就是<code>双方都能明确自己和对方的收、发能力是正常的</code>。</p><p><code>第一次握手</code>：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p><p><code>第二次握手</code>：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。<br>从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。</p><p><code>第三次握手</code>：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。<br>第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。</p><p>经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。</p><p>每次都是接收到数据包的一方可以得到一些结论，发送的一方其实没有任何头绪。我虽然有发包的动作，但是我怎么知道我有没有发出去，而对方有没有接收到呢？</p><p>而从上面的过程可以看到，最少是需要三次握手过程的。两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论。其实每次收到网络包的一方至少是可以得到：对方的发送、我方的接收是正常的。而每一步都是有关联的，下一次的“响应”是由于第一次的“请求”触发，因此每次握手其实是可以得到额外的结论的。比如第三次握手时，服务端收到数据包，表明看服务端只能得到客户端的发送能力、服务端的接收能力是正常的，但是结合第二次，说明服务端在第二次发送的响应包，客户端接收到了，并且作出了响应，从而得到额外的结论：客户端的接收、服务端的发送是正常的。</p><p>用表格总结一下：</p><table><thead><tr><th align="left">视角</th><th align="left">客收</th><th align="left">客发</th><th align="left">服收</th><th align="left">服发</th></tr></thead><tbody><tr><td align="left">客视角</td><td align="left">二</td><td align="left">一 + 二</td><td align="left">一 + 二</td><td align="left">二</td></tr><tr><td align="left">服视角</td><td align="left">二 + 三</td><td align="left">一</td><td align="left">一</td><td align="left">二 + 三</td></tr></tbody></table><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。这时对方会回一个ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，等到发送完了所有的数据后，会发送一个FIN段来关闭此方向上的连接。接收方发送ACK确认关闭连接。注意，接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，我无法了解<code>“上层的意志”</code>。</p><h1 id="“三次握手，四次挥手”怎么完成？"><a href="#“三次握手，四次挥手”怎么完成？" class="headerlink" title="“三次握手，四次挥手”怎么完成？"></a>“三次握手，四次挥手”怎么完成？</h1><p>其实3次握手的目的并不只是让通信双方都了解到一个连接正在建立，还在于利用数据包的选项来传输特殊的信息，交换初始序列号ISN。</p><p>3次握手是指发送了3个报文段，4次挥手是指发送了4个报文段。注意，SYN和FIN段都是会利用重传进行可靠传输的。</p><p><img src="http://upload-images.jianshu.io/upload_images/12234098-8604b533d42457b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三次握手"></p><h2 id="三次握手-1"><a href="#三次握手-1" class="headerlink" title="三次握手"></a>三次握手</h2><ol><li>客户端发送一个SYN段，并指明客户端的初始序列号，即ISN(c).</li><li>服务端发送自己的SYN段作为应答，同样指明自己的ISN(s)。为了确认客户端的SYN，将ISN(c)+1作为ACK数值。这样，每发送一个SYN，序列号就会加1. 如果有丢失的情况，则会重传。</li><li>为了确认服务器端的SYN，客户端将ISN(s)+1作为返回的ACK数值。</li></ol><h2 id="四次挥手-1"><a href="#四次挥手-1" class="headerlink" title="四次挥手"></a>四次挥手</h2><p><img src="http://upload-images.jianshu.io/upload_images/12234098-3754de754cbcf2af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="四次挥手"></p><ol><li>客户端发送一个FIN段，并包含一个希望接收者看到的自己当前的序列号K. 同时还包含一个ACK表示确认对方最近一次发过来的数据。</li><li>服务端将K值加1作为ACK序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。</li><li>服务端发起自己的FIN段，ACK=K+1, Seq=L</li><li>客户端确认。ACK=L+1</li></ol><h2 id="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"><a href="#为什么建立连接是三次握手，而关闭连接却是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"></a>为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</h2><p>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送。</p><h1 id="“三次握手，四次挥手”进阶"><a href="#“三次握手，四次挥手”进阶" class="headerlink" title="“三次握手，四次挥手”进阶"></a>“三次握手，四次挥手”进阶</h1><h2 id="ISN"><a href="#ISN" class="headerlink" title="ISN"></a>ISN</h2><p>三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</p><p>如果ISN是固定的，攻击者很容易猜出后续的确认号。</p><pre><code>ISN = M + F(localhost, localport, remotehost, remoteport)</code></pre><p>M是一个计时器，每隔4微秒加1。<br>F是一个Hash算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。要保证hash算法不能被外部轻易推算得出。</p><h2 id="序列号回绕"><a href="#序列号回绕" class="headerlink" title="序列号回绕"></a>序列号回绕</h2><p>因为ISN是随机的，所以序列号容易就会超过2^31-1. 而tcp对于丢包和乱序等问题的判断都是依赖于序列号大小比较的。此时就出现了所谓的tcp序列号回绕（sequence wraparound）问题。怎么解决？</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** The next routines deal with comparing 32 bit unsigned ints* and worry about wraparound (automatic with unsigned arithmetic).*/</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">before</span><span class="token punctuation">(</span>__u32 seq1<span class="token punctuation">,</span> __u32 seq2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>__s32<span class="token punctuation">)</span><span class="token punctuation">(</span>seq1<span class="token operator">-</span>seq2<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">define</span> after(seq2, seq1) before(seq1, seq2)</span></code></pre><p>上述代码是内核中的解决回绕问题代码。<strong>s32是有符号整型的意思，而</strong>u32则是无符号整型。序列号发生回绕后，序列号变小，相减之后，把结果变成有符号数了，因此结果成了负数。</p><pre><code>假设seq1=255， seq2=1（发生了回绕）。seq1 = 1111 1111 seq2 = 0000 0001我们希望比较结果是 seq1 - seq2= 1111 1111-0000 0001----------- 1111 1110由于我们将结果转化成了有符号数，由于最高位是1，因此结果是一个负数，负数的绝对值为 0000 0001 + 1 = 0000 0010 = 2因此seq1 - seq2 &lt; 0</code></pre><h2 id="syn-flood攻击"><a href="#syn-flood攻击" class="headerlink" title="syn flood攻击"></a>syn flood攻击</h2><p>最基本的DoS攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。syn flood属于Dos攻击的一种。</p><p>如果恶意的向某个服务器端口发送大量的SYN包，则可以使服务器打开大量的半开连接，分配TCB（Transmission Control Block）, 从而消耗大量的服务器资源，同时也使得正常的连接请求无法被相应。当开放了一个TCP端口后，该端口就处于Listening状态，不停地监视发到该端口的Syn报文，一 旦接收到Client发来的Syn报文，就需要为该请求分配一个TCB，通常一个TCB至少需要280个字节，在某些操作系统中TCB甚至需要1300个字节，并返回一个SYN ACK命令，立即转为SYN-RECEIVED即半开连接状态。系统会为此耗尽资源。</p><p>常见的防攻击方法有：</p><h3 id="无效连接的监视释放"><a href="#无效连接的监视释放" class="headerlink" title="无效连接的监视释放"></a>无效连接的监视释放</h3><p>监视系统的半开连接和不活动连接，当达到一定阈值时拆除这些连接，从而释放系统资源。这种方法对于所有的连接一视同仁，而且由于SYN Flood造成的半开连接数量很大，正常连接请求也被淹没在其中被这种方式误释放掉，因此这种方法属于入门级的SYN Flood方法。</p><h3 id="延缓TCB分配方法"><a href="#延缓TCB分配方法" class="headerlink" title="延缓TCB分配方法"></a>延缓TCB分配方法</h3><p>消耗服务器资源主要是因为当SYN数据报文一到达，系统立即分配TCB，从而占用了资源。而SYN Flood由于很难建立起正常连接，因此，当正常连接建立起来后再分配TCB则可以有效地减轻服务器资源的消耗。常见的方法是使用Syn Cache和Syn Cookie技术。</p><h4 id="Syn-Cache技术"><a href="#Syn-Cache技术" class="headerlink" title="Syn Cache技术"></a>Syn Cache技术</h4><p>系统在收到一个SYN报文时，在一个专用HASH表中保存这种半连接信息，直到收到正确的回应ACK报文再分配TCB。这个开销远小于TCB的开销。当然还需要保存序列号。</p><h4 id="Syn-Cookie技术"><a href="#Syn-Cookie技术" class="headerlink" title="Syn Cookie技术"></a>Syn Cookie技术</h4><p>Syn Cookie技术则完全不使用任何存储资源，这种方法比较巧妙，它使用一种特殊的算法生成Sequence Number，这种算法考虑到了对方的IP、端口、己方IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如MSS(Maximum Segment Size，最大报文段大小，指的是TCP报文的最大数据报长度，其中不包括TCP首部长度。)、时间等，在收到对方 的ACK报文后，重新计算一遍，看其是否与对方回应报文中的（Sequence Number-1）相同，从而决定是否分配TCB资源。</p><h3 id="使用SYN-Proxy防火墙"><a href="#使用SYN-Proxy防火墙" class="headerlink" title="使用SYN Proxy防火墙"></a>使用SYN Proxy防火墙</h3><p>一种方式是防止墙dqywb连接的有效性后，防火墙才会向内部服务器发起SYN请求。防火墙代服务器发出的SYN ACK包使用的序列号为c, 而真正的服务器回应的序列号为c’, 这样，在每个数据报文经过防火墙的时候进行序列号的修改。另一种方式是防火墙确定了连接的安全后，会发出一个safe reset命令，client会进行重新连接，这时出现的syn报文会直接放行。这样不需要修改序列号了。但是，client需要发起两次握手过程，因此建立连接的时间将会延长。</p><h2 id="连接队列"><a href="#连接队列" class="headerlink" title="连接队列"></a>连接队列</h2><p>在外部请求到达时，被服务程序最终感知到前，连接可能处于SYN_RCVD状态或是ESTABLISHED状态，但还未被应用程序接受。</p><p><img src="http://upload-images.jianshu.io/upload_images/12234098-36b3c46688c685c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tcp queue"></p><p>对应地，服务器端也会维护两种队列，处于SYN_RCVD状态的半连接队列，而处于ESTABLISHED状态但仍未被应用程序accept的为全连接队列。如果这两个队列满了之后，就会出现各种丢包的情形。</p><pre class=" language-shell"><code class="language-shell">查看是否有连接溢出netstat -s | grep LISTEN</code></pre><h3 id="半连接队列满了"><a href="#半连接队列满了" class="headerlink" title="半连接队列满了"></a>半连接队列满了</h3><p>在三次握手协议中，服务器维护一个半连接队列，该队列为每个客户端的SYN包开设一个条目(服务端在接收到SYN包的时候，就已经创建了request_sock结构，存储在半连接队列中)，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于Syn_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。</p><blockquote><p>目前，Linux下默认会进行5次重发SYN-ACK包，重试的间隔时间从1s开始，下次的重试间隔时间是前一次的双倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s, 总共31s, 称为<code>指数退避</code>，第5次发出后还要等32s才知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s, TCP才会把断开这个连接。由于，SYN超时需要63秒，那么就给攻击者一个攻击服务器的机会，攻击者在短时间内发送大量的SYN包给Server(俗称SYN flood攻击)，用于耗尽Server的SYN队列。对于应对SYN 过多的问题，linux提供了几个TCP参数：tcp_syncookies、tcp_synack_retries、tcp_max_syn_backlog、tcp_abort_on_overflow 来调整应对。</p></blockquote><table><thead><tr><th align="left">参数</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">tcp_syncookies</td><td align="left">SYNcookie将连接信息编码在ISN(initialsequencenumber)中返回给客户端，这时server不需要将半连接保存在队列中，而是利用客户端随后发来的ACK带回的ISN还原连接信息，以完成连接的建立，避免了半连接队列被攻击SYN包填满。</td></tr><tr><td align="left">tcp_syncookies</td><td align="left">内核放弃建立连接之前发送SYN包的数量。</td></tr><tr><td align="left">tcp_synack_retries</td><td align="left">内核放弃连接之前发送SYN+ACK包的数量</td></tr><tr><td align="left">tcp_max_syn_backlog</td><td align="left">默认为1000. 这表示半连接队列的长度，如果超过则放弃当前连接。</td></tr><tr><td align="left">tcp_abort_on_overflow</td><td align="left">如果设置了此项，则直接reset. 否则，不做任何操作，这样当服务器半连接队列有空了之后，会重新接受连接。<code>Linux坚持在能力许可范围内不忽略进入的连接</code>。客户端在这期间会重复发送sys包，当重试次数到达上限之后，会得到<code>connection time out</code>响应。</td></tr></tbody></table><h3 id="全连接队列满了"><a href="#全连接队列满了" class="headerlink" title="全连接队列满了"></a>全连接队列满了</h3><p>当第三次握手时，当server接收到ACK包之后，会进入一个新的叫 accept 的队列。</p><p>当accept队列满了之后，即使client继续向server发送ACK的包，也会不被响应，此时ListenOverflows+1，同时server通过tcp_abort_on_overflow来决定如何返回，0表示直接丢弃该ACK，1表示发送RST通知client；相应的，client则会分别返回<code>read timeout</code> 或者 <code>connection reset by peer</code>。另外，tcp_abort_on_overflow是0的话，server过一段时间再次发送syn+ack给client（也就是重新走握手的第二步），如果client超时等待比较短，就很容易异常了。而客户端收到多个 SYN ACK 包，则会认为之前的 ACK 丢包了。于是促使客户端再次发送 ACK ，在 accept队列有空闲的时候最终完成连接。若 accept队列始终满员，则最终客户端收到 RST 包（此时服务端发送syn+ack的次数超出了tcp_synack_retries）。</p><p>服务端仅仅只是创建一个定时器，以固定间隔重传syn和ack到服务端</p><table><thead><tr><th align="left">参数</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">tcp_abort_on_overflow</td><td align="left">如果设置了此项，则直接reset. 否则，不做任何操作，这样当服务器半连接队列有空了之后，会重新接受连接。<code>Linux坚持在能力许可范围内不忽略进入的连接</code>。客户端在这期间会重复发送sys包，当重试次数到达上限之后，会得到<code>connection time out</code>响应。</td></tr><tr><td align="left">min(backlog, somaxconn)</td><td align="left">全连接队列的长度。</td></tr></tbody></table><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>netstat -s命令</p><pre class=" language-shell"><code class="language-shell">[root@server ~]#  netstat -s | egrep "listen|LISTEN" 667399 times the listen queue of a socket overflowed667399 SYNs to LISTEN sockets ignored</code></pre><p>上面看到的 667399 times ，表示全连接队列溢出的次数，隔几秒钟执行下，如果这个数字一直在增加的话肯定全连接队列偶尔满了。</p><pre class=" language-shell"><code class="language-shell">[root@server ~]#  netstat -s | grep TCPBacklogDrop</code></pre><p>查看 Accept queue 是否有溢出</p><p>ss命令</p><pre class=" language-shell"><code class="language-shell">[root@server ~]#  ss -lntState Recv-Q Send-Q Local Address:Port Peer Address:PortLISTEN     0      128 *:6379 *:*LISTEN     0      128 *:22 *:*</code></pre><p>如果State是listen状态，Send-Q 表示第三列的listen端口上的全连接队列最大为50，第一列Recv-Q为全连接队列当前使用了多少。<br>非 LISTEN 状态中 Recv-Q 表示 receive queue 中的 bytes 数量；Send-Q 表示 send queue 中的 bytes 数值。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>当外部连接请求到来时，TCP模块会首先查看max_syn_backlog，如果处于SYN_RCVD状态的连接数目超过这一阈值，进入的连接会被拒绝。根据tcp_abort_on_overflow字段来决定是直接丢弃，还是直接reset.</p><p>从服务端来说，三次握手中，第一步server接受到client的syn后，把相关信息放到半连接队列中，同时回复syn+ack给client. 第三步当收到客户端的ack, 将连接加入到全连接队列。</p><p>一般，全连接队列比较小，会先满，此时半连接队列还没满。如果这时收到syn报文，则会进入半连接队列，没有问题。但是如果收到了三次握手中的第3步(ACK)，则会根据tcp_abort_on_overflow字段来决定是直接丢弃，还是直接reset.此时，客户端发送了ACK, 那么客户端认为三次握手完成，它认为服务端已经准备好了接收数据的准备。但此时服务端可能因为全连接队列满了而无法将连接放入，会重新发送第2步的syn+ack, 如果这时有数据到来，服务器TCP模块会将数据存入队列中。一段时间后，client端没收到回复，超时，连接异常，client会主动关闭连接。</p><h1 id="“三次握手，四次挥手”redis实例分析"><a href="#“三次握手，四次挥手”redis实例分析" class="headerlink" title="“三次握手，四次挥手”redis实例分析"></a>“三次握手，四次挥手”redis实例分析</h1><ol><li>我在dev机器上部署redis服务，端口号为6379, </li><li>通过tcpdump工具获取数据包，使用如下命令</li></ol><pre class=" language-shell"><code class="language-shell">tcpdump -w /tmp/a.cap port 6379 -s0-w把数据写入文件，-s0设置每个数据包的大小默认为68字节，如果用-S 0则会抓到完整数据包</code></pre><ol start="3"><li>在dev2机器上用redis-cli访问dev:6379, 发送一个ping, 得到回复pong</li><li>停止抓包，用tcpdump读取捕获到的数据包</li></ol><pre class=" language-shell"><code class="language-shell">tcpdump -r /tmp/a.cap -n -nn -A -x| vim -（-x 以16进制形式展示，便于后面分析）</code></pre><p>共收到了7个包。</p><p>抓到的是IP数据包，IP数据包分为IP头部和IP数据部分，IP数据部分是TCP头部加TCP数据部分。</p><p>IP的数据格式为：<br><img src="http://upload-images.jianshu.io/upload_images/12234098-e6b04f3e9bebdac4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ip head"><br>它由固定长度20B+可变长度构成。</p><pre class=" language-tcpdump"><code class="language-tcpdump">10:55:45.662077 IP dev2.39070 > dev.6379: Flags [S], seq 4133153791, win 29200, options [mss 1460,sackOK,TS val 2959270704 ecr 0,nop,wscale 7], length 0        0x0000:  4500 003c 08cf 4000 3606 14a5 0ab3 b561        0x0010:  0a60 5cd4 989e 18eb f65a ebff 0000 0000        0x0020:  a002 7210 872f 0000 0204 05b4 0402 080a        0x0030:  b062 e330 0000 0000 0103 0307</code></pre><p>对着IP头部格式，来拆解数据包的具体含义。</p><table><thead><tr><th align="left">字节值</th><th align="left">字节含义</th></tr></thead><tbody><tr><td align="left">0x4</td><td align="left">IP版本为ipv4</td></tr><tr><td align="left">0x5</td><td align="left">首部长度为5 * 4字节=20B</td></tr><tr><td align="left">0x00</td><td align="left">服务类型，现在基本都置为0</td></tr><tr><td align="left">0x003c</td><td align="left">总长度为3*16+12=60字节，上面所有的长度就是60字节</td></tr><tr><td align="left">0x08cf</td><td align="left">标识。同一个数据报的唯一标识。当IP数据报被拆分时，会复制到每一个数据中。</td></tr><tr><td align="left">0x4000</td><td align="left"><code>3bit 标志 + 13bit 片偏移</code>。3bit 标志对应 R、DF、MF。目前只有后两位有效，DF位：为1表示不分片，为0表示分片。MF：为1表示“更多的片”，为0表示这是最后一片。13bit 片位移：本分片在原先数据报文中相对首位的偏移位。（需要再乘以8 )</td></tr><tr><td align="left">0x36</td><td align="left">生存时间TTL。IP报文所允许通过的路由器的最大数量。每经过一个路由器，TTL减1，当为 0 时，路由器将该数据报丢弃。TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字 RFC 指定。发送 ICMP 回显应答时经常把 TTL 设为最大值 255。TTL可以防止数据报陷入路由循环。 此处为54.</td></tr><tr><td align="left">0x06</td><td align="left">协议类型。指出IP报文携带的数据使用的是哪种协议，以便目的主机的IP层能知道要将数据报上交到哪个进程。TCP 的协议号为6，UDP 的协议号为17。ICMP 的协议号为1，IGMP 的协议号为2。该 IP 报文携带的数据使用 TCP 协议，得到了验证。</td></tr><tr><td align="left">0x14a5</td><td align="left">16bitIP首部校验和。</td></tr><tr><td align="left">0x0ab3 b561</td><td align="left">32bit源ip地址。</td></tr><tr><td align="left">0x0a60 5cd4</td><td align="left">32bit目的ip地址。</td></tr></tbody></table><p>剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。</p><table><thead><tr><th align="left">字节值</th><th align="left">字节含义</th></tr></thead><tbody><tr><td align="left">0x989e</td><td align="left">16bit源端口。1<em>16</em>16<em>16+8</em>16<em>16+14</em>16+11=39070</td></tr><tr><td align="left">0x18eb</td><td align="left">16bit目的端口6379</td></tr><tr><td align="left">0xf65a ebff</td><td align="left">32bit序列号。4133153791</td></tr><tr><td align="left">0x0000 0000</td><td align="left">32bit确认号。</td></tr><tr><td align="left">0xa</td><td align="left">4bit首部长度，以4byte为单位。共10*4=40字节。因此TCP报文的可选长度为40-20=20</td></tr><tr><td align="left">0b000000</td><td align="left">6bit保留位。目前置为0.</td></tr><tr><td align="left">0b000010</td><td align="left">6bitTCP标志位。从左到右依次是紧急 URG、确认 ACK、推送 PSH、复位 RST、同步 SYN 、终止 FIN。</td></tr><tr><td align="left">0x7210</td><td align="left">滑动窗口大小，滑动窗口即tcp接收缓冲区的大小，用于tcp拥塞控制。29200</td></tr><tr><td align="left">0x872f</td><td align="left">16bit校验和。</td></tr><tr><td align="left">0x0000</td><td align="left">紧急指针。仅在 URG = 1时才有意义，它指出本报文段中的紧急数据的字节数。当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。</td></tr></tbody></table><p>可变长度部分，协议如下：</p><table><thead><tr><th align="left">字节值</th><th align="left">字节含义</th></tr></thead><tbody><tr><td align="left">0x0204 05b4</td><td align="left">最大报文长度为，05b4=1460. 即可接收的最大包长度，通常为MTU减40字节，IP头和TCP头各20字节</td></tr><tr><td align="left">0x0402</td><td align="left">表示支持SACK</td></tr><tr><td align="left">0x080a b062 e330 0000 0000</td><td align="left">时间戳。Ts val=b062 e330=2959270704, ecr=0</td></tr><tr><td align="left">0x01</td><td align="left">无操作</td></tr><tr><td align="left">0x03 0307</td><td align="left">窗口扩大因子为7. 移位7, 乘以128</td></tr><tr><td align="left">这样第一个包分析完了。dev2向dev发送SYN请求。<code>也就是三次握手中的第一次了。</code></td><td align="left"></td></tr><tr><td align="left"><code>SYN seq(c)=4133153791</code></td><td align="left"></td></tr></tbody></table><p>第二个包，dev响应连接，ack=4133153792. 表明dev下次准备接收这个序号的包，用于tcp字节注的顺序控制。dev（也就是server端）的初始序号为seq=4264776963, syn=1.<br><code>SYN ack=seq(c)+1 seq(s)=4264776963</code></p><p>第三个包，client包确认，这里使用了相对值应答。seq=4133153792, 等于第二个包的ack. ack=4264776964.<br><code>ack=seq(s)+1, seq=seq(c)+1</code><br>至此，三次握手完成。接下来就是发送ping和pong的数据了。</p><p>接着第四个包。</p><pre class=" language-tcpdump"><code class="language-tcpdump">10:55:48.090073 IP dev2.39070 > dev.6379: Flags [P.], seq 1:15, ack 1, win 229, options [nop,nop,TS val 2959273132 ecr 3132256230], length 14        0x0000:  4500 0042 08d1 4000 3606 149d 0ab3 b561        0x0010:  0a60 5cd4 989e 18eb f65a ec00 fe33 5504        0x0020:  8018 00e5 4b5f 0000 0101 080a b062 ecac        0x0030:  bab2 6fe6 2a31 0d0a 2434 0d0a 7069 6e67        0x0040:  0d0a</code></pre><p>tcp首部长度为32B, 可选长度为12B. IP报文的总长度为66B, 首部长度为20B, 因此TCP数据部分长度为14B. seq=0xf65a ec00=4133153792<br>ACK, PSH. 数据部分为2a31 0d0a 2434 0d0a 7069 6e67 0d0a</p><pre class=" language-tcpdump"><code class="language-tcpdump">0x2a31         -> *10x0d0a         -> \r\n0x2434         -> $40x0d0a         -> \r\n0x7069 0x6e67  -> ping0x0d0a         -> \r\n</code></pre><p>dev2向dev发送了ping数据，第四个包完毕。</p><p>第五个包，dev2向dev发送ack响应。<br>序列号为0xfe33 5504=4264776964, ack确认号为0xf65a ec0e=4133153806=(4133153792+14). </p><p>第六个包，dev向dev2响应pong消息。序列号fe33 5504，确认号f65a ec0e, TCP头部可选长度为12B, IP数据报总长度为59B, 首部长度为20B, 因此TCP数据长度为7B.<br>数据部分2b50 4f4e 470d 0a, 翻译过来就是<code>+PONG\r\n</code>.</p><p>至此，Redis客户端和Server端的三次握手过程分析完毕。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>“三次握手，四次挥手”看似简单，但是深究进去，还是可以延伸出很多知识点的。比如半连接队列、全连接队列等等。以前关于TCP建立连接、关闭连接的过程很容易就会忘记，可能是因为只是死记硬背了几个过程，没有深入研究背后的原理。</p><p>所以，“三次握手，四次挥手”你真的懂了吗？欢迎一起交流~~</p><p><img src="https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png" alt="image"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【redis】<a href="https://segmentfault.com/a/1190000015044878" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015044878</a></p><p>【tcp option】<a href="https://blog.csdn.net/wdscq1234/article/details/52423272" target="_blank" rel="noopener">https://blog.csdn.net/wdscq1234/article/details/52423272</a></p><p>【滑动窗口】<a href="https://www.zhihu.com/question/32255109" target="_blank" rel="noopener">https://www.zhihu.com/question/32255109</a></p><p>【全连接队列】<a href="http://jm.taobao.org/2017/05/25/525-1/" target="_blank" rel="noopener">http://jm.taobao.org/2017/05/25/525-1/</a></p><p>【client fooling】 <a href="https://github.com/torvalds/linux/commit/5ea8ea2cb7f1d0db15762c9b0bb9e7330425a071">https://github.com/torvalds/linux/commit/5ea8ea2cb7f1d0db15762c9b0bb9e7330425a071</a></p><p>【backlog RECV_Q】<a href="http://blog.51cto.com/59090939/1947443" target="_blank" rel="noopener">http://blog.51cto.com/59090939/1947443</a></p><p>【定时器】<a href="https://www.cnblogs.com/menghuanbiao/p/5212131.html" target="_blank" rel="noopener">https://www.cnblogs.com/menghuanbiao/p/5212131.html</a></p><p>【队列图示】<a href="https://www.itcodemonkey.com/article/5834.html" target="_blank" rel="noopener">https://www.itcodemonkey.com/article/5834.html</a></p><p>【tcp flood攻击】<a href="https://www.cnblogs.com/hubavyn/p/4477883.html" target="_blank" rel="noopener">https://www.cnblogs.com/hubavyn/p/4477883.html</a></p><p>【MSS MTU】<a href="https://blog.csdn.net/LoseInVain/article/details/53694265" target="_blank" rel="noopener">https://blog.csdn.net/LoseInVain/article/details/53694265</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记得刚毕业找工作面试的时候，经常会被问到：你知道“3次握手，4次挥手”吗？这时候我会“胸有成竹”地“背诵”前期准备好的“答案”，第一次怎么怎么，第二次……答完就没有下文了，面试官貌似也没有深入下去的意思，深入下去我也不懂，皆大欢喜！&lt;/p&gt;
&lt;p&gt;作为程序员，要有“刨根问底
      
    
    </summary>
    
      <category term="网络" scheme="https://github.com/qcrao/qcrao.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="协议" scheme="https://github.com/qcrao/qcrao.github.io/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
</feed>
